<?xml version='1.0' encoding='UTF-8'?>
<addon id="templateid"><properties/><dependencies><jsDependency><javaScript name="tools_common" version="1.3.0"/><javaScript name="AlamedaRequire" version="0.3.2"/><javaScript name="knockout" version="3.3.0"/><javaScript name="snap_svg" version="1.0.0"/></jsDependency></dependencies><css><![CDATA[.exam_skin_wood .powerandenergy_wrapper{position:relative;width:100%;height:100%;background-color:#bfd3e2;text-align:center;overflow:hidden}.exam_skin_wood .powerandenergy_wrapper .pae_show_area{position:absolute;left:0;top:0;width:100%;height:100%;padding:2.75em 4.16667em 0;z-index:-10}.exam_skin_wood .powerandenergy_wrapper .pae_show_area .pae_show_inner_area{width:100%;height:100%}.exam_skin_wood .powerandenergy_wrapper .pae_main{display:inline-block;height:40.08333em;padding:2.75em 4.16667em 0;white-space:nowrap}.exam_skin_wood .powerandenergy_wrapper .pae_main_left{display:inline-block;float:left;width:15.58333em;height:32.16667em;padding:2.58333em 0;margin:2.58333em 0 0 1.04167em;background:#b8cdde;vertical-align:middle;color:#333}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_left_bar{position:relative;display:inline-block;width:42%;padding-left:5em}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_right_bar{position:relative;display:inline-block;width:58%;padding-left:4.58333em}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_energy_bar{position:relative;width:1.08333em;height:26.33333em;border:.08333em solid #333;background:#bfd3e2;border-radius:.54167em;box-shadow:inset 1px 1px .41667em #fff,inset -1px -1px .41667em #fff,0 0 .33333em rgba(0,0,0,.5);overflow:hidden}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_measure{position:relative;z-index:20}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_measure li{position:relative;height:.08333em;margin-top:2.54167em;background:-webkit-linear-gradient(left,#bababa,#000 40%,#a0a0a0);background:linear-gradient(90deg,#bababa 0,#000 40%,#a0a0a0)}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_active_bar{position:absolute;top:50%;left:0;width:100%;height:20%;z-index:10;background:#209af6;box-shadow:inset 1px 0 .20833em #fff,inset -1px 0 .20833em #fff}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .pae_active_bar.up{top:auto;bottom:50%}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_original_position{position:absolute;z-index:20;left:5.41667em;top:50%;margin:-.04167em 0 0 -1.16667em;width:1.16667em;height:.08333em;background-color:#333}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .right_original_position{position:absolute;z-index:20;left:4.58333em;top:50%;margin:-.04167em 0 0 -1.16667em;width:1.16667em;height:.08333em;background-color:#333}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_orginal_txt{position:absolute;top:44%;left:.25em;z-index:30;font:italic 2.66667em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_orginal_txt span{font:.54167em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_orginal_txt span:last-child{font:italic .54167em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_dest_txt{position:absolute;top:60%;left:.5em;margin-top:-.5em;z-index:30;font:italic 2.66667em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_dest_txt span{font:.58333em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_dest_txt span:last-child{font:italic .54167em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_dest_txt2{position:absolute;top:80%;left:.875em;margin-top:-.5em;z-index:30;font:italic 2.66667em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .left_dest_txt2 span{font:.54167em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .right_orginal_txt{position:absolute;top:42.1%;left:.375em;z-index:30;font:3.58333em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .right_dest_txt{position:absolute;top:30%;left:.45833em;margin-top:-.5em;z-index:30;font:italic 2.66667em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .right_dest_txt2{position:absolute;top:10%;left:.04167em;margin-top:-.5em;z-index:30;font:italic 2.66667em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_left .right_dest_txt2 span{font:italic .5em Times New Roman}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle{position:relative;display:inline-block;float:left;width:43.875em;height:32.16667em;margin:2.58333em 1.41667em 0;background:#b8cdde;vertical-align:middle;color:#333;z-index:100}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_positive_q_bg{background:url(resources/wood/images/q1.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_negative_q_bg{background:url(resources/wood/images/q2.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .preset_content{width:100%;height:100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .preset_content .svg_container{width:46.70833em;height:37.33333em;margin-left:-1.41667em;margin-top:-2.58333em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .preset_content .bg_svg_container{position:absolute;top:0;left:50%;-webkit-transform:translate(-50%);transform:translate(-50%);width:43.875em;height:100%;z-index:-1}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_rotate{position:absolute;bottom:0;right:.75em;width:2em;height:2em;background:url(resources/wood/images/rotate.png) no-repeat;background-size:100% auto;cursor:pointer}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_rotate:active{background-position:0 -2.41667em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_rotate.disabled{background-position:0 -4.83333em;cursor:default}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_point{position:absolute;width:1.41667em;height:1.41667em;border:.08333em solid #fff;background-color:#06aac3;border-radius:50%;cursor:pointer}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_point:active{width:1.66667em;height:1.66667em;border-width:.20833em;background-color:#00dfe7;-webkit-transform:translate(-.125em,-.125em);transform:translate(-.125em,-.125em)}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_point.disabled{border-color:#75838e;background-color:#2bb2c9;cursor:default}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_point.disabled:active{width:1.41667em;height:1.41667em;border-width:.08333em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_point_txt{position:absolute;left:40%;font:italic 2.5em Times New Roman;color:#333}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_point_txt.grey{color:#626f79}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_E_txt{position:absolute;top:0;right:.625em;font:italic 2em Times New Roman;color:#626f79}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_positive_q{position:absolute;left:10%;top:50%;width:3em;height:3em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_positive_q .light{position:absolute;left:0;top:0;width:100%;height:100%;border-radius:50%;background:#fff;-webkit-animation:light 2s infinite;animation:light 2s infinite;-webkit-transform-origin:center center;transform-origin:center center;z-index:-1}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_positive_q .point{display:inline-block;width:3em;height:3em;background:-webkit-radial-gradient(#fb9d43,#f07603);background:radial-gradient(#fb9d43,#f07603);border:1px solid #c06900;border-radius:50%;box-shadow:0 0 .75em #f67200}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_positive_q .point:before{content:"";position:absolute;left:.5em;top:1em;width:.83333em;height:.83333em;background:url(resources/wood/images/positive_sign.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_positive_q .point span{position:absolute;right:.25em;font:2em Times New Roman;color:#fff}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_negative_q{position:absolute;width:3em;height:3em;left:20%;top:40%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_negative_q .light{position:absolute;left:0;top:0;width:100%;height:100%;border-radius:50%;background:#fff;-webkit-animation:light 2s infinite;animation:light 2s infinite;-webkit-transform-origin:center center;transform-origin:center center;z-index:-1}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_negative_q .point{display:inline-block;width:3em;height:3em;background:-webkit-radial-gradient(#5aafe1,#1caaee);background:radial-gradient(#5aafe1,#1caaee);border:1px solid #1d93c8;border-radius:50%;box-shadow:0 0 .75em #61b2d9}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_negative_q .point:before{content:"";position:absolute;left:.5em;top:1.33333em;width:.75em;height:.16667em;background:url(resources/wood/images/negative_sign.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_negative_q .point span{position:absolute;right:.25em;font:2em Times New Roman;color:#fff}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .positive_line{width:20.83333em;height:.16667em;background-color:#ea7f1b}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_1_1{position:absolute;left:8.33333em;width:21.66667em;padding:.83333em 0 .91667em 2.25em;bottom:-2.29167em;border:1px solid #7e8993;border-radius:.41667em;background:rgba(255,255,255,.95);box-shadow:0 0 .20833em rgba(0,0,0,.4);z-index:10}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_1_1 p.first_explain{width:17.08333em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_1_1.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_1_1 p.second_explain{width:17.08333em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_1_2.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_1_2{position:absolute;left:2.29167em;bottom:-2.29167em;width:39.41667em;border:1px solid #7e8993;border-radius:.41667em;background:rgba(255,255,255,.95);box-shadow:0 0 .20833em rgba(0,0,0,.4);z-index:10;padding:.83333em 0 .91667em 2.25em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_1_2 p.first_explain{width:35em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_1_3.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_1_2 p.second_explain{width:17.08333em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_1_2.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_2_1{position:absolute;left:.58333em;bottom:-2.29167em;width:42.70833em;border:1px solid #7e8993;border-radius:.41667em;background:rgba(255,255,255,.95);box-shadow:0 0 .20833em rgba(0,0,0,.4);z-index:10;padding:.83333em 0 .91667em 1.25em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_2_1 p.first_explain{width:40.41667em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_2_1.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_2_1 p.second_explain{width:17.08333em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_1_2.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_3_1{position:absolute;left:-13.08333em;bottom:-2.29167em;width:65.125em;border:1px solid #7e8993;border-radius:.41667em;background:rgba(255,255,255,.95);box-shadow:0 0 .20833em rgba(0,0,0,.4);z-index:10;padding:.83333em 0 .91667em 1.66667em}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_3_1 p.first_explain{width:61.83333em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_3_1.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_3_1 p.second_explain{width:17.08333em;height:2.83333em;margin-top:.5em;background:url(resources/wood/images/explain_1_2.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_4_1{position:absolute;left:8.33333em;bottom:-2.29167em;width:21.66667em;height:8.33333em;border:1px solid #7e8993;border-radius:.41667em;background:rgba(255,255,255,.95);box-shadow:0 0 .20833em rgba(0,0,0,.4)}.exam_skin_wood .powerandenergy_wrapper .pae_main_middle .pae_explain_4_1 p{width:17.08333em;height:5.83333em;background:url(resources/wood/images/explain_1_1.png) no-repeat;background-size:100% 100%;margin:1.33333em 0 0 2.25em}.exam_skin_wood .powerandenergy_wrapper .pae_main_right{position:relative;float:left;display:inline-block;width:6.83333em;height:32.16667em;margin:2.58333em 1.04167em 0 0;background:#b8cdde;vertical-align:middle;color:#333}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_list{width:100%;height:100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_btn{position:relative;width:100%;height:25%;cursor:pointer}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_btn.on,.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_btn:active{background-color:#8cb1ce}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_btn:after{content:"";position:absolute;top:100%;left:50%;width:4.08333em;height:1px;margin-left:-2.04167em;background-color:#9daebd}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_btn:last-child:after{content:"";display:none}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_txt{display:block;font-size:1.5em;margin-top:.58333em}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_1{padding-top:2.5em}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_1 .pae_preset_img{display:block;width:4.41667em;height:.58333em;margin:0 auto;background:url(resources/wood/images/preset_1.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_2{padding-top:1.33333em}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_2 .pae_preset_img{display:block;width:4.41667em;height:2.33333em;margin:0 auto;background:url(resources/wood/images/preset_2.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_3{padding-top:1.5em}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_3 .pae_preset_img{display:block;width:4.41667em;height:2.375em;margin:0 auto;background:url(resources/wood/images/preset_3.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_4{padding-top:1.125em}.exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_4 .pae_preset_img{display:block;width:4.41667em;height:2.33333em;margin:0 auto;background:url(resources/wood/images/preset_4.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_footer{position:absolute;left:0;bottom:0;display:-webkit-box;display:-ms-flexbox;display:flex;display:-webkit-flex;width:100%;height:4.91667em;padding:0 4.16667em;background:#cfdee9}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_com_btns{display:inline-block;height:100%;vertical-align:middle;white-space:nowrap}.exam_skin_wood .powerandenergy_wrapper .pae_footer .com_applicationset_switch{margin-bottom:.3em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_item{display:inline-block;height:100%;vertical-align:middle}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_item.disabled .com_applicationset_switch{background:#c5cdd2;cursor:default}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_item.disabled .com_applicationset_switch:before{top:-2px;left:-2px;background:#c5cdd2;border-color:#a3a9ae}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_item.disabled .com_applicationset_switch input[type=checkbox]{cursor:default}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_item.disabled .pae_btn_txt{color:#292525}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn{display:block;padding-top:.54167em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_txt{display:block;font:1.5em Microsoft YaHei;cursor:default}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns{padding:0 1.08333em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item:first-child{padding-right:1.25em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns{width:60.5%}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item{min-width:25.8%}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_right_btns{padding:0 1.08333em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_right_btns .pae_btn_item{min-width:6.66667em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item .com_applicationset_switch{position:relative;background:#28b9ff;-webkit-transition:left .3s;transition:left .3s}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item .com_applicationset_switch:before{top:-2px;left:-2px;background:#f5f5f5;border-color:#a3a9ae}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item .com_applicationset_switch:after{content:"";position:absolute;right:.625em;top:50%;width:.83333em;height:.16667em;-webkit-transform:translateY(-50%);transform:translateY(-50%);background:url(resources/wood/images/negative_sign.png) no-repeat;background-size:100% 100%}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item .positive_txt{display:none!important}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item.positive .com_applicationset_switch{position:relative;background:#fb891d;-webkit-transition:left .3s;transition:left .3s}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item.positive .com_applicationset_switch:before{top:-2px;left:2.08333em;background:#f5f5f5;border-color:#a3a9ae}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item.positive .com_applicationset_switch:after{content:"";position:absolute;left:.75em;top:50%;width:.83333em;height:.83333em;-webkit-transform:translateY(-50%);transform:translateY(-50%);background:url(resources/wood/images/positive_sign.png) no-repeat;background-size:100% auto}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item.positive .negative_txt{display:none!important}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_charge_btn_item.positive .positive_txt{display:block!important}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_reset_btn_item .pae_btn{text-align:center;padding-top:.41667em;cursor:pointer}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_reset_btn_item .pae_btn span{display:inline-block;width:2.5em;height:2.25em;background:url(resources/wood/images/reset.png) no-repeat;background-size:100% auto}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_reset_btn_item .pae_btn span:active{background-position:0 -2.75em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_reset_btn_item.disabled .pae_btn{cursor:default}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_reset_btn_item.disabled .pae_btn span{background-position:0 -5.5em}.exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_reset_btn_item.disabled .pae_btn_txt{color:#a5abae}.exam_skin_wood .powerandenergy_wrapper .pae_footer .dividing_line{display:inline-block;height:100%;vertical-align:middle;border-left:1px solid #e7f3fc;border-right:1px solid #b3c1cb}@-webkit-keyframes light{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}to{-webkit-transform:scale(1.4);transform:scale(1.4);opacity:0}}@keyframes light{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}to{-webkit-transform:scale(1.4);transform:scale(1.4);opacity:0}}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_txt{margin-top:2em;padding:0 .5em;font-size:.83333em;white-space:normal;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_txt{margin-top:-.3em;line-height:1;font-size:1.08333em;white-space:normal;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns{padding:0 .41667em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item{padding-right:0}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item:first-child{margin-right:.41667em;width:11.25em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item:nth-child(2){width:14.16667em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns{width:auto}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item:first-child{width:11.66667em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item:nth-child(2){width:12.5em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item:nth-child(3){width:10em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_right_btns .pae_btn{margin-top:1em;margin-left:1em}.typefaces_long .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_right_btns .pae_btn_txt{display:none}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_main_right .pae_preset_txt{margin-top:2em;padding:0 .5em;font-size:.83333em;white-space:normal;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_btn_txt{margin-top:-.3em;line-height:1;font-size:1.08333em;white-space:normal;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns{padding:0 .41667em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item{padding-right:0}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item:first-child{margin-right:.41667em;width:11.25em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_left_btns .pae_btn_item:nth-child(2){width:14.16667em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns{width:auto}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item:first-child{width:11.66667em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item:nth-child(2){width:12.5em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_middle_btns .pae_btn_item:nth-child(3){width:10em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_right_btns .pae_btn{margin-top:1em;margin-left:1em}.typefaces_ru_RU .exam_skin_wood .powerandenergy_wrapper .pae_footer .pae_right_btns .pae_btn_txt{display:none}]]></css><view><![CDATA[<div class="exam_skin_wood"><div class="powerandenergy_wrapper _wrapper"><div class="pae_main"><div class="pae_main_left"><div class="pae_left_bar hide_visibility _energy_bar"><div class="pae_energy_bar"><div class="pae_measure pae_energy_measure"><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul></div><div class="pae_active_bar _energy_bar_value"></div></div><div class="left_original_position"></div><div class="left_orginal_txt">E<span>p</span><span>A</span></div><div class="left_dest_txt _bar_epb">E<span>p</span><span>B</span></div><div class="left_dest_txt2 _bar_ep">E<span>p</span></div></div><div class="pae_right_bar hide_visibility _electrostatic_bar"><div class="pae_energy_bar"><div class="pae_measure pae_work_measure"><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul></div><div class="pae_active_bar up _electrostatic_bar_value"></div></div><div class="right_original_position"></div><div class="right_orginal_txt">0</div><div class="right_dest_txt _bar_w">W</div><div class="right_dest_txt2 _bar_wab">W<span>AB</span></div></div></div><div class="pae_main_middle _main_middle_container"><div class="preset_content _main_content hide_dom"><div class="bg_svg_container _straight_line_bg_container"></div><div class="svg_container _svg_container _straight_line_container"></div><div class="pae_explain_1_1 hide_dom _straight_line_expression1"><p class="first_explain"></p><p class="second_explain"></p></div><div class="pae_explain_1_2 hide_dom _straight_line_expression2"><p class="first_explain"></p><p class="second_explain"></p></div></div><div class="preset_content _main_content hide_dom"><div class="bg_svg_container _polygonal_line_bg_container"></div><div class="svg_container _svg_container _polygonal_line_container"></div><div class="pae_explain_2_1 hide_dom _polygonal_line_expression"><p class="first_explain"></p><p class="second_explain"></p></div></div><div class="preset_content _main_content hide_dom"><div class="bg_svg_container _curve_line_bg_container"></div><div class="svg_container _svg_container _curve_line_container"></div><div class="pae_explain_3_1 hide_dom _curve_line_expression"><p class="first_explain"></p><p class="second_explain"></p></div></div><div class="preset_content _main_content hide_dom"><div class="bg_svg_container _custom_line_bg_container"></div><div class="svg_container _svg_container _custom_line_container"></div><div class="pae_explain_1_1 hide_dom _custom_line_expression"><p class="first_explain"></p><p class="second_explain"></p></div></div></div><div class="pae_main_right"><ul class="pae_preset_list _scene_container"><li class="pae_preset_btn pae_preset_1 _straight_line" data-name="STRAIGHT_LINE"><span class="pae_preset_img"></span> <span class="pae_preset_txt" data-bind="text:power_and_energy_straight_line"></span></li><li class="pae_preset_btn pae_preset_2 _polygonal_line" data-name="POLYGONAL_LINE"><span class="pae_preset_img"></span> <span class="pae_preset_txt" data-bind="text:power_and_energy_polygonal_line"></span></li><li class="pae_preset_btn pae_preset_3 _curve_line" data-name="CURVE_LINE"><span class="pae_preset_img"></span> <span class="pae_preset_txt" data-bind="text:power_and_energy_curve_line"></span></li><li class="pae_preset_btn pae_preset_4 _custom_line" data-name="CUSTOM_LINE"><span class="pae_preset_img"></span> <span class="pae_preset_txt" data-bind="text:power_and_energy_custom_line"></span></li></ul></div></div><div class="pae_footer"><ul class="pae_left_btns pae_com_btns"><li class="pae_btn_item _energy_check"><a class="pae_btn"><label class="com_applicationset_switch"></label></a><span class="pae_btn_txt" data-bind="text:power_and_energy_energy_change"></span></li><li class="pae_btn_item _electrostatic_check"><a class="pae_btn"><label class="com_applicationset_switch"></label></a><span class="pae_btn_txt" data-bind="text:power_and_energy_static_electricity_power"></span></li></ul><div class="dividing_line"></div><ul class="pae_middle_btns pae_com_btns"><li class="pae_btn_item pae_charge_btn_item positive _electric_charge_check"><a class="pae_btn"><label class="com_applicationset_switch pae_charge_switch"></label></a><span class="pae_btn_txt positive_txt" data-bind="text:power_and_energy_positive_charge"></span> <span class="pae_btn_txt negative_txt" data-bind="text:power_and_energy_negative_charge"></span></li><li class="pae_btn_item _force_direction_check"><a class="pae_btn"><label class="com_applicationset_switch"></label></a><span class="pae_btn_txt" data-bind="text:power_and_energy_force_direction"></span></li><li class="pae_btn_item _view_analysis_check"><a class="pae_btn"><label class="com_applicationset_switch"></label></a><span class="pae_btn_txt" data-bind="text:power_and_energy_view_analysis"></span></li></ul><div class="dividing_line"></div><ul class="pae_right_btns pae_com_btns"><li class="pae_btn_item pae_reset_btn_item _reset"><a class="pae_btn"><span></span> </a><span class="pae_btn_txt" data-bind="text:power_and_energy_reset"></span></li></ul></div><div class="pae_show_area"><div class="pae_show_inner_area _pae_show_inner_area"></div></div></div></div>]]></view><presenter><![CDATA['use strict';

(function () {
    var helper = {
        publishSubscribe: null,
        currentScene: 'STRAIGHT_LINE',
        sceneName: {
            STRAIGHT_LINE: 'STRAIGHT_LINE',
            POLYGONAL_LINE: 'POLYGONAL_LINE',
            CURVE_LINE: 'CURVE_LINE',
            CUSTOM_LINE: 'CUSTOM_LINE'
        },

        // VIEW_WIDTH: 1000, VIEW_HEIGHT: 800,
        domObj: {},
        i18n: null
    };
    var powerAndEnergyController = null;
    var Presenter = BasicPresenter.extend({
        metaInfo: {
            name: 'PowerAndEnergy',
            type: PresenterType.PRESENTER_COMPONENT
        },
        /**
         * Presenter的初始化方法
         * @private
         */
        $init: function $init() {
            this._super();
            //定义日志
            this.logger.appendHandler(function (message, context) {
                switch (context.level.name) {
                    case 'DEBUG':
                        console.debug(message);
                        break;
                    case 'INFO':
                        console.info(message);
                        break;
                    case 'WARN':
                        console.warn(message);
                        break;
                    case 'ERROR':
                        console.error(message);
                        break;
                    default:
                        console.log(message);
                        break;
                }
            }, { level: Logger.DEBUG });
        },
        /**
         * Presenter对外暴露的方法
         */
        _service_: {
            constructor: function constructor(parent) {
                this.parent = parent;
            },
            setLocationProperties: function setLocationProperties(properties) {
                helper.i18n = properties;
            },
            getExtendData: function getExtendData() {
                var $svgContainer = powerAndEnergyController._currentScene[helper.currentScene].$currentContainer.find('div._svg_container');
                var options = {
                    currentScene: helper.currentScene,
                    svgWidth: $svgContainer.width(),
                    svgHeight: $svgContainer.height(),
                    straightLine: powerAndEnergyController.getSceneOption(helper.sceneName.STRAIGHT_LINE),
                    polygonalLine: powerAndEnergyController.getSceneOption(helper.sceneName.POLYGONAL_LINE),
                    curveLine: powerAndEnergyController.getSceneOption(helper.sceneName.CURVE_LINE),
                    customLine: powerAndEnergyController.getSceneOption(helper.sceneName.CUSTOM_LINE)
                };
                return options;
            },
            getQuestionInfo: function getQuestionInfo() {
                return {
                    id: helper.model.ID,
                    type_code: 'PowerAndEnergy',
                    type_name: helper.i18n['power_and_energy'],
                    url: '',
                    item: 'PowerAndEnergy',
                    statistics_type: 'no_need',
                    dispatchOnly: true,
                    notExistStatistics: true,
                    noNeedQuizProgress: true
                };
            }
        },
        getService: function getService() {
            this._service_.constructor(this);
            return this._service_;
        },
        /****以下开始为icPlayer的生命周期方法*****/
        run: function run(view, model) {
            var _this = this;

            $.extend(helper, {
                publishSubscribe: null,
                currentScene: 'STRAIGHT_LINE'
            });
            helper.model = model;
            helper.$view = $(view);
            helper.basePath = this.basePath;
            helper.model.index = 1;
            helper.model.initRatio = 1;
            this._initComponent();
            var $deferred = $.Deferred();
            require(['PublishSubscribe', 'PowerAndEnergyController'], function (PublishSubscribe, PowerAndEnergyController) {
                helper.publishSubscribe = new PublishSubscribe();
                powerAndEnergyController = new PowerAndEnergyController(helper, {});
            }).then(function () {
                _this.logger.log('加载[PowerAndEnergyController]模块完成');
                $deferred.resolve();
            }).catch(function () {
                _this.logger.error('加载模块[PowerAndEnergyController]失败');
                $deferred.reject();
            });
            this.__interface = {
                resizeScreen: function resizeScreen(data) {
                    //data {ratio:4/3||3/4}
                    var ratio = eval(data.ratio);
                    helper.model.ratio = ratio;
                    if (helper.model.index == 1) {
                        helper.model.initRatio = helper.model.ratio;
                        helper.model.index++;
                    }
                    helper.saveData = this._saveRatioData();
                    powerAndEnergyController.resizeScreen();
                    this.resizeScreen(ratio);
                }
            };
            return $deferred.promise();
        },
        pageShow: function pageShow(view, model) {
            this._bindEvent();
            this._pushProcess();
            ko.applyBindings(helper.i18n, view);
        },
        pageLeave: function pageLeave() {
            this._unbindEvent();
        },
        destroy: function destroy() {},
        /**如果不需要处理icplayer的状态恢复事件, 请将以下两个方法删除掉**/
        getState: function getState() {},
        setState: function setState(state, options) {},
        /****以下开始为Presenter的私有方法*****/
        _pushProcess: function _pushProcess() {
            //工具窗口是否有推送数据
            var extendData = helper.model['__ExtendModel'];
            if ($.isEmptyObject(extendData)) {
                powerAndEnergyController.init();
                return;
            }

            var svgWidthRatio = void 0;
            var svgHeightRatio = void 0;

            //直线
            var straightLineOpt = extendData.straightLine;
            if (straightLineOpt) {
                //初始化直线预设
                helper.currentScene = helper.sceneName.STRAIGHT_LINE;
                powerAndEnergyController.init();
                //初始化完获取宽高才会准确
                svgWidthRatio = helper.domObj.$straightLineContainer.width() / extendData.svgWidth;
                svgHeightRatio = helper.domObj.$straightLineContainer.height() / extendData.svgHeight;

                var straightLine = powerAndEnergyController._currentScene[helper.sceneName.STRAIGHT_LINE].scene;
                straightLine._energyCheck = straightLineOpt.energyCheck;
                straightLine._electrostaticCheck = straightLineOpt.electrostaticCheck;
                straightLine._electricChargeCheck = straightLineOpt.electricChargeCheck;
                straightLine._forceDirectionCheck = straightLineOpt.forceDirectionCheck;
                straightLine._viewAnalysisCheck = straightLineOpt.viewAnalysisCheck;
                straightLine._resetButton = straightLineOpt.resetButton;
                straightLine._barVal = straightLineOpt.barVal;
                straightLine._epbWabPos = straightLineOpt.epbWabPos;
                straightLine._epWPos = straightLineOpt.epWPos;
                straightLine._qBezierPoints = [];
                for (var i = 0, iLen = straightLineOpt.qBezierPoints.length; i < iLen; i++) {
                    straightLine._qBezierPoints.push({
                        x: straightLineOpt.qBezierPoints[i].x * svgWidthRatio,
                        y: straightLineOpt.qBezierPoints[i].y * svgHeightRatio
                    });
                }
                straightLine._electricField._rotateState = straightLineOpt.electricField.rotateState;
                straightLine._electricField._rotateAngle = straightLineOpt.electricField.rotateAngle;
                if (straightLineOpt.chargeTrajectory.aPos) {
                    straightLine._chargeTrajectory._aPos = {
                        x: straightLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: straightLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (straightLineOpt.chargeTrajectory.bPos) {
                    straightLine._chargeTrajectory._bPos = {
                        x: straightLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: straightLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (straightLineOpt.chargeTrajectory.qPos) {
                    straightLine._chargeTrajectory._qPos = {
                        x: straightLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: straightLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                straightLine._chargeTrajectory._aState = straightLineOpt.chargeTrajectory.aState;
                straightLine._chargeTrajectory._bState = straightLineOpt.chargeTrajectory.bState;
                straightLine._chargeTrajectory._qState = straightLineOpt.chargeTrajectory.qState;
            }

            //折线
            var polygonalLineOpt = extendData.polygonalLine;
            if (polygonalLineOpt) {
                //初始化折线预设
                helper.currentScene = helper.sceneName.POLYGONAL_LINE;
                powerAndEnergyController.init();
                //初始化完获取宽高才会准确
                svgWidthRatio = helper.domObj.$polygonalLineContainer.width() / extendData.svgWidth;
                svgHeightRatio = helper.domObj.$polygonalLineContainer.height() / extendData.svgHeight;

                var polygonalLine = powerAndEnergyController._currentScene[helper.sceneName.POLYGONAL_LINE].scene;
                polygonalLine._energyCheck = polygonalLineOpt.energyCheck;
                polygonalLine._electrostaticCheck = polygonalLineOpt.electrostaticCheck;
                polygonalLine._electricChargeCheck = polygonalLineOpt.electricChargeCheck;
                polygonalLine._forceDirectionCheck = polygonalLineOpt.forceDirectionCheck;
                polygonalLine._viewAnalysisCheck = polygonalLineOpt.viewAnalysisCheck;
                polygonalLine._resetButton = polygonalLineOpt.resetButton;
                polygonalLine._barVal = polygonalLineOpt.barVal;
                polygonalLine._epbWabPos = polygonalLineOpt.epbWabPos;
                polygonalLine._epWPos = polygonalLineOpt.epWPos;
                polygonalLine._qBezierPoints = [];
                for (var _i = 0, _iLen = polygonalLineOpt.qBezierPoints.length; _i < _iLen; _i++) {
                    polygonalLine._qBezierPoints.push({
                        x: polygonalLineOpt.qBezierPoints[_i].x * svgWidthRatio,
                        y: polygonalLineOpt.qBezierPoints[_i].y * svgHeightRatio
                    });
                }
                polygonalLine._electricField._rotateState = polygonalLineOpt.electricField.rotateState;
                polygonalLine._electricField._rotateAngle = polygonalLineOpt.electricField.rotateAngle;
                if (polygonalLineOpt.chargeTrajectory.aPos) {
                    polygonalLine._chargeTrajectory._aPos = {
                        x: polygonalLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: polygonalLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (polygonalLineOpt.chargeTrajectory.bPos) {
                    polygonalLine._chargeTrajectory._bPos = {
                        x: polygonalLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: polygonalLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (polygonalLineOpt.chargeTrajectory.qPos) {
                    polygonalLine._chargeTrajectory._qPos = {
                        x: polygonalLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: polygonalLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                polygonalLine._chargeTrajectory._aState = polygonalLineOpt.chargeTrajectory.aState;
                polygonalLine._chargeTrajectory._bState = polygonalLineOpt.chargeTrajectory.bState;
                polygonalLine._chargeTrajectory._qState = polygonalLineOpt.chargeTrajectory.qState;
            }

            //曲线
            var curveLineOpt = extendData.curveLine;
            if (curveLineOpt) {
                //初始化曲线预设
                helper.currentScene = helper.sceneName.CURVE_LINE;
                powerAndEnergyController.init();
                //初始化完获取宽高才会准确
                svgWidthRatio = helper.domObj.$curveLineContainer.width() / extendData.svgWidth;
                svgHeightRatio = helper.domObj.$curveLineContainer.height() / extendData.svgHeight;

                var curveLine = powerAndEnergyController._currentScene[helper.sceneName.CURVE_LINE].scene;
                curveLine._energyCheck = curveLineOpt.energyCheck;
                curveLine._electrostaticCheck = curveLineOpt.electrostaticCheck;
                curveLine._electricChargeCheck = curveLineOpt.electricChargeCheck;
                curveLine._forceDirectionCheck = curveLineOpt.forceDirectionCheck;
                curveLine._viewAnalysisCheck = curveLineOpt.viewAnalysisCheck;
                curveLine._resetButton = curveLineOpt.resetButton;
                curveLine._barVal = curveLineOpt.barVal;
                curveLine._epbWabPos = curveLineOpt.epbWabPos;
                curveLine._epWPos = curveLineOpt.epWPos;
                curveLine._qBezierPoints = [];
                for (var _i2 = 0, _iLen2 = curveLineOpt.qBezierPoints.length; _i2 < _iLen2; _i2++) {
                    curveLine._qBezierPoints.push({
                        x: curveLineOpt.qBezierPoints[_i2].x * svgWidthRatio,
                        y: curveLineOpt.qBezierPoints[_i2].y * svgHeightRatio
                    });
                }
                curveLine._electricField._rotateState = curveLineOpt.electricField.rotateState;
                curveLine._electricField._rotateAngle = curveLineOpt.electricField.rotateAngle;
                if (curveLineOpt.chargeTrajectory.aPos) {
                    curveLine._chargeTrajectory._aPos = {
                        x: curveLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: curveLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (curveLineOpt.chargeTrajectory.bPos) {
                    curveLine._chargeTrajectory._bPos = {
                        x: curveLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: curveLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (curveLineOpt.chargeTrajectory.qPos) {
                    curveLine._chargeTrajectory._qPos = {
                        x: curveLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: curveLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                curveLine._chargeTrajectory._aState = curveLineOpt.chargeTrajectory.aState;
                curveLine._chargeTrajectory._bState = curveLineOpt.chargeTrajectory.bState;
                curveLine._chargeTrajectory._qState = curveLineOpt.chargeTrajectory.qState;
            }

            //自定义路径
            var customLineOpt = extendData.customLine;
            if (customLineOpt) {
                //初始化自定义路径预设
                helper.currentScene = helper.sceneName.CUSTOM_LINE;
                powerAndEnergyController.init();
                //初始化完获取宽高才会准确
                svgWidthRatio = helper.domObj.$customLineContainer.width() / extendData.svgWidth;
                svgHeightRatio = helper.domObj.$customLineContainer.height() / extendData.svgHeight;

                var customLine = powerAndEnergyController._currentScene[helper.sceneName.CUSTOM_LINE].scene;
                customLine._energyCheck = customLineOpt.energyCheck;
                customLine._electrostaticCheck = customLineOpt.electrostaticCheck;
                customLine._electricChargeCheck = customLineOpt.electricChargeCheck;
                customLine._forceDirectionCheck = customLineOpt.forceDirectionCheck;
                customLine._viewAnalysisCheck = customLineOpt.viewAnalysisCheck;
                customLine._resetButton = customLineOpt.resetButton;
                customLine._barVal = customLineOpt.barVal;
                customLine._epbWabPos = customLineOpt.epbWabPos;
                customLine._epWPos = customLineOpt.epWPos;
                customLine._qBezierPoints = [];
                for (var _i3 = 0, _iLen3 = customLineOpt.qBezierPoints.length; _i3 < _iLen3; _i3++) {
                    customLine._qBezierPoints.push({
                        x: customLineOpt.qBezierPoints[_i3].x * svgWidthRatio,
                        y: customLineOpt.qBezierPoints[_i3].y * svgHeightRatio
                    });
                }
                customLine._electricField._rotateState = customLineOpt.electricField.rotateState;
                customLine._electricField._rotateAngle = customLineOpt.electricField.rotateAngle;
                if (customLineOpt.chargeTrajectory.aPos) {
                    customLine._chargeTrajectory._aPos = {
                        x: customLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: customLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (customLineOpt.chargeTrajectory.bPos) {
                    customLine._chargeTrajectory._bPos = {
                        x: customLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: customLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (customLineOpt.chargeTrajectory.qPos) {
                    customLine._chargeTrajectory._qPos = {
                        x: customLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: customLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                customLine._chargeTrajectory._aState = customLineOpt.chargeTrajectory.aState;
                customLine._chargeTrajectory._bState = customLineOpt.chargeTrajectory.bState;
                customLine._chargeTrajectory._qState = customLineOpt.chargeTrajectory.qState;
            }

            //初始化当前的预设
            helper.currentScene = extendData.currentScene;
            powerAndEnergyController._currentScene[helper.currentScene].$current.removeClass('on');
            powerAndEnergyController.init();
        },
        _saveRatioData: function _saveRatioData() {
            var $svgContainer = powerAndEnergyController._currentScene[helper.currentScene].$currentContainer.find('div._svg_container');
            var $svgBgContainer = powerAndEnergyController._currentScene[helper.currentScene].$currentContainer.find('div.bg_svg_container');
            var lines = powerAndEnergyController._currentScene[helper.currentScene].scene._bgSvg.selectAll('g');
            var svgbgLeft = powerAndEnergyController._currentScene[helper.currentScene].scene._bgSvg.node.getBoundingClientRect().left;
            var svgLeft = powerAndEnergyController._currentScene[helper.currentScene].scene._svg.node.getBoundingClientRect().left;
            var svgbgTop = powerAndEnergyController._currentScene[helper.currentScene].scene._bgSvg.node.getBoundingClientRect().top;
            var svgTop = powerAndEnergyController._currentScene[helper.currentScene].scene._svg.node.getBoundingClientRect().top;
            var arrow = lines[0].select('path');
            var forceArrowGroupHeight = powerAndEnergyController._currentScene[helper.currentScene].scene._svg.select('g.arrow').node.getBoundingClientRect().height;
            var options = {
                currentScene: helper.currentScene,
                svgWidth: $svgContainer.width(),
                svgHeight: $svgContainer.height(),
                svgbgWidth: $svgBgContainer.width(),
                svgbgHeight: $svgBgContainer.height(),
                svgLeft: svgLeft,
                svgTop: svgTop,
                svgbgLeft: svgbgLeft,
                svgbgTop: svgbgTop,
                arrowHeight: arrow.node.getBoundingClientRect().height,
                leftBound: svgbgLeft - svgLeft,
                rightBound: svgbgLeft - svgLeft + $svgBgContainer.width(),
                topBound: svgbgTop - svgTop,
                bottomBound: svgbgTop - svgTop + $svgBgContainer.height(),
                forceArrowGroupHeight: forceArrowGroupHeight,
                straightLine: powerAndEnergyController.getSceneOption(helper.sceneName.STRAIGHT_LINE),
                polygonalLine: powerAndEnergyController.getSceneOption(helper.sceneName.POLYGONAL_LINE),
                curveLine: powerAndEnergyController.getSceneOption(helper.sceneName.CURVE_LINE),
                customLine: powerAndEnergyController.getSceneOption(helper.sceneName.CUSTOM_LINE)
            };
            return options;
        },
        _ratioFunction: function _ratioFunction() {
            var extendData = helper.saveData;
            if ($.isEmptyObject(extendData)) {
                powerAndEnergyController.init();
                return;
            }

            var svgWidthRatio = void 0;
            var svgHeightRatio = void 0;
            //初始化完获取宽高才会准确
            svgWidthRatio = helper.model.ratio;
            svgHeightRatio = helper.model.ratio;

            //直线
            var straightLineOpt = extendData.straightLine;
            if (straightLineOpt) {
                //初始化直线预设
                helper.currentScene = helper.sceneName.STRAIGHT_LINE;
                //powerAndEnergyController.init();

                var straightLine = powerAndEnergyController._currentScene[helper.sceneName.STRAIGHT_LINE].scene;
                straightLine._energyCheck = straightLineOpt.energyCheck;
                straightLine._electrostaticCheck = straightLineOpt.electrostaticCheck;
                straightLine._electricChargeCheck = straightLineOpt.electricChargeCheck;
                straightLine._forceDirectionCheck = straightLineOpt.forceDirectionCheck;
                straightLine._viewAnalysisCheck = straightLineOpt.viewAnalysisCheck;
                straightLine._resetButton = straightLineOpt.resetButton;
                straightLine._barVal = straightLineOpt.barVal;
                straightLine._epbWabPos = straightLineOpt.epbWabPos;
                straightLine._epWPos = straightLineOpt.epWPos;
                straightLine._qBezierPoints = [];
                for (var i = 0, iLen = straightLineOpt.qBezierPoints.length; i < iLen; i++) {
                    straightLine._qBezierPoints.push({
                        x: straightLineOpt.qBezierPoints[i].x * svgWidthRatio,
                        y: straightLineOpt.qBezierPoints[i].y * svgHeightRatio
                    });
                }
                straightLine._electricField._rotateState = straightLineOpt.electricField.rotateState;
                straightLine._electricField._rotateAngle = straightLineOpt.electricField.rotateAngle;
                if (straightLineOpt.chargeTrajectory.aPos) {
                    straightLine._chargeTrajectory._aPos = {
                        x: straightLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: straightLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (straightLineOpt.chargeTrajectory.bPos) {
                    straightLine._chargeTrajectory._bPos = {
                        x: straightLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: straightLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (straightLineOpt.chargeTrajectory.qPos) {
                    straightLine._chargeTrajectory._qPos = {
                        x: straightLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: straightLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                straightLine._chargeTrajectory._aState = straightLineOpt.chargeTrajectory.aState;
                straightLine._chargeTrajectory._bState = straightLineOpt.chargeTrajectory.bState;
                straightLine._chargeTrajectory._qState = straightLineOpt.chargeTrajectory.qState;
            }

            //折线
            var polygonalLineOpt = extendData.polygonalLine;
            if (polygonalLineOpt) {
                //初始化折线预设
                helper.currentScene = helper.sceneName.POLYGONAL_LINE;
                //powerAndEnergyController.init();

                var polygonalLine = powerAndEnergyController._currentScene[helper.sceneName.POLYGONAL_LINE].scene;
                polygonalLine._energyCheck = polygonalLineOpt.energyCheck;
                polygonalLine._electrostaticCheck = polygonalLineOpt.electrostaticCheck;
                polygonalLine._electricChargeCheck = polygonalLineOpt.electricChargeCheck;
                polygonalLine._forceDirectionCheck = polygonalLineOpt.forceDirectionCheck;
                polygonalLine._viewAnalysisCheck = polygonalLineOpt.viewAnalysisCheck;
                polygonalLine._resetButton = polygonalLineOpt.resetButton;
                polygonalLine._barVal = polygonalLineOpt.barVal;
                polygonalLine._epbWabPos = polygonalLineOpt.epbWabPos;
                polygonalLine._epWPos = polygonalLineOpt.epWPos;
                polygonalLine._qBezierPoints = [];
                for (var _i4 = 0, _iLen4 = polygonalLineOpt.qBezierPoints.length; _i4 < _iLen4; _i4++) {
                    polygonalLine._qBezierPoints.push({
                        x: polygonalLineOpt.qBezierPoints[_i4].x * svgWidthRatio,
                        y: polygonalLineOpt.qBezierPoints[_i4].y * svgHeightRatio
                    });
                }
                polygonalLine._electricField._rotateState = polygonalLineOpt.electricField.rotateState;
                polygonalLine._electricField._rotateAngle = polygonalLineOpt.electricField.rotateAngle;
                if (polygonalLineOpt.chargeTrajectory.aPos) {
                    polygonalLine._chargeTrajectory._aPos = {
                        x: polygonalLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: polygonalLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (polygonalLineOpt.chargeTrajectory.bPos) {
                    polygonalLine._chargeTrajectory._bPos = {
                        x: polygonalLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: polygonalLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (polygonalLineOpt.chargeTrajectory.qPos) {
                    polygonalLine._chargeTrajectory._qPos = {
                        x: polygonalLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: polygonalLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                polygonalLine._chargeTrajectory._aState = polygonalLineOpt.chargeTrajectory.aState;
                polygonalLine._chargeTrajectory._bState = polygonalLineOpt.chargeTrajectory.bState;
                polygonalLine._chargeTrajectory._qState = polygonalLineOpt.chargeTrajectory.qState;
            }

            //曲线
            var curveLineOpt = extendData.curveLine;
            if (curveLineOpt) {
                //初始化曲线预设
                helper.currentScene = helper.sceneName.CURVE_LINE;
                //powerAndEnergyController.init();

                var curveLine = powerAndEnergyController._currentScene[helper.sceneName.CURVE_LINE].scene;
                curveLine._energyCheck = curveLineOpt.energyCheck;
                curveLine._electrostaticCheck = curveLineOpt.electrostaticCheck;
                curveLine._electricChargeCheck = curveLineOpt.electricChargeCheck;
                curveLine._forceDirectionCheck = curveLineOpt.forceDirectionCheck;
                curveLine._viewAnalysisCheck = curveLineOpt.viewAnalysisCheck;
                curveLine._resetButton = curveLineOpt.resetButton;
                curveLine._barVal = curveLineOpt.barVal;
                curveLine._epbWabPos = curveLineOpt.epbWabPos;
                curveLine._epWPos = curveLineOpt.epWPos;
                curveLine._qBezierPoints = [];
                for (var _i5 = 0, _iLen5 = curveLineOpt.qBezierPoints.length; _i5 < _iLen5; _i5++) {
                    curveLine._qBezierPoints.push({
                        x: curveLineOpt.qBezierPoints[_i5].x * svgWidthRatio,
                        y: curveLineOpt.qBezierPoints[_i5].y * svgHeightRatio
                    });
                }
                curveLine._electricField._rotateState = curveLineOpt.electricField.rotateState;
                curveLine._electricField._rotateAngle = curveLineOpt.electricField.rotateAngle;
                if (curveLineOpt.chargeTrajectory.aPos) {
                    curveLine._chargeTrajectory._aPos = {
                        x: curveLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: curveLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (curveLineOpt.chargeTrajectory.bPos) {
                    curveLine._chargeTrajectory._bPos = {
                        x: curveLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: curveLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (curveLineOpt.chargeTrajectory.qPos) {
                    curveLine._chargeTrajectory._qPos = {
                        x: curveLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: curveLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                curveLine._chargeTrajectory._aState = curveLineOpt.chargeTrajectory.aState;
                curveLine._chargeTrajectory._bState = curveLineOpt.chargeTrajectory.bState;
                curveLine._chargeTrajectory._qState = curveLineOpt.chargeTrajectory.qState;
            }

            //自定义路径
            var customLineOpt = extendData.customLine;
            if (customLineOpt) {
                //初始化自定义路径预设
                helper.currentScene = helper.sceneName.CUSTOM_LINE;
                //powerAndEnergyController.init();

                var customLine = powerAndEnergyController._currentScene[helper.sceneName.CUSTOM_LINE].scene;
                customLine._energyCheck = customLineOpt.energyCheck;
                customLine._electrostaticCheck = customLineOpt.electrostaticCheck;
                customLine._electricChargeCheck = customLineOpt.electricChargeCheck;
                customLine._forceDirectionCheck = customLineOpt.forceDirectionCheck;
                customLine._viewAnalysisCheck = customLineOpt.viewAnalysisCheck;
                customLine._resetButton = customLineOpt.resetButton;
                customLine._barVal = customLineOpt.barVal;
                customLine._epbWabPos = customLineOpt.epbWabPos;
                customLine._epWPos = customLineOpt.epWPos;
                customLine._qBezierPoints = [];
                for (var _i6 = 0, _iLen6 = customLineOpt.qBezierPoints.length; _i6 < _iLen6; _i6++) {
                    customLine._qBezierPoints.push({
                        x: customLineOpt.qBezierPoints[_i6].x * svgWidthRatio,
                        y: customLineOpt.qBezierPoints[_i6].y * svgHeightRatio
                    });
                }
                customLine._electricField._rotateState = customLineOpt.electricField.rotateState;
                customLine._electricField._rotateAngle = customLineOpt.electricField.rotateAngle;
                if (customLineOpt.chargeTrajectory.aPos) {
                    customLine._chargeTrajectory._aPos = {
                        x: customLineOpt.chargeTrajectory.aPos.x * svgWidthRatio,
                        y: customLineOpt.chargeTrajectory.aPos.y * svgHeightRatio
                    };
                }
                if (customLineOpt.chargeTrajectory.bPos) {
                    customLine._chargeTrajectory._bPos = {
                        x: customLineOpt.chargeTrajectory.bPos.x * svgWidthRatio,
                        y: customLineOpt.chargeTrajectory.bPos.y * svgHeightRatio
                    };
                }
                if (customLineOpt.chargeTrajectory.qPos) {
                    customLine._chargeTrajectory._qPos = {
                        x: customLineOpt.chargeTrajectory.qPos.x * svgWidthRatio,
                        y: customLineOpt.chargeTrajectory.qPos.y * svgHeightRatio
                    };
                }
                customLine._chargeTrajectory._aState = customLineOpt.chargeTrajectory.aState;
                customLine._chargeTrajectory._bState = customLineOpt.chargeTrajectory.bState;
                customLine._chargeTrajectory._qState = customLineOpt.chargeTrajectory.qState;
            }

            //初始化当前的预设
            helper.currentScene = extendData.currentScene;
            powerAndEnergyController._currentScene[helper.currentScene].$current.removeClass('on');
            powerAndEnergyController.resizeInit();
        },

        resizeScreen: function resizeScreen() {
            this._ratioFunction();
        },
        _initComponent: function _initComponent() {
            //容器
            helper.domObj.$wrapper = helper.$view.find('._wrapper');
            helper.domObj.$paeShowInnerArea = helper.$view.find('._pae_show_inner_area');
            //中间的容器
            helper.domObj.$mainMiddleContainer = helper.$view.find('div._main_middle_container');
            //中间的容器的内容
            helper.domObj.$mainMiddleContentItems = helper.$view.find('div._main_middle_container ._main_content');

            //沿直线预设的容器
            helper.domObj.$straightLineContainer = helper.$view.find('div._straight_line_container');
            //沿直线预设的背景容器
            helper.domObj.$straightLineBgContainer = helper.$view.find('div._straight_line_bg_container');
            //沿折线预设的容器
            helper.domObj.$polygonalLineContainer = helper.$view.find('div._polygonal_line_container');
            ////沿折线预设的背景容器
            helper.domObj.$polygonalLineBgContainer = helper.$view.find('div._polygonal_line_bg_container');
            //沿曲线预设的容器
            helper.domObj.$curveLineContainer = helper.$view.find('div._curve_line_container');
            //沿曲线预设的背景容器
            helper.domObj.$curveLineBgContainer = helper.$view.find('div._curve_line_bg_container');
            //自由路径预设的容器
            helper.domObj.$customLineContainer = helper.$view.find('div._custom_line_container');
            //自由路径预设的背景容器
            helper.domObj.$customLineBgContainer = helper.$view.find('div._custom_line_bg_container');

            //直线公式1
            helper.domObj.$straightLineExpression1 = helper.$view.find('div._straight_line_expression1');
            //直线公式2
            helper.domObj.$straightLineExpression2 = helper.$view.find('div._straight_line_expression2');
            //折线公式
            helper.domObj.$polygonalLineExpression = helper.$view.find('div._polygonal_line_expression');
            //曲线公式
            helper.domObj.$curveLineExpression = helper.$view.find('div._curve_line_expression');
            //自定义路径公式
            helper.domObj.$customLineExpression = helper.$view.find('div._custom_line_expression');

            //预设按钮容器
            helper.domObj.$sceneContainer = helper.$view.find('ul._scene_container');
            //预设按钮容器li选项
            helper.domObj.$sceneItems = helper.$view.find('ul._scene_container li');
            //沿直线预设按钮
            helper.domObj.$straightLine = helper.$view.find('li._straight_line');
            //沿折线预设按钮
            helper.domObj.$polygonalLine = helper.$view.find('li._polygonal_line');
            //沿曲线预设按钮
            helper.domObj.$curveLine = helper.$view.find('li._curve_line');
            //沿自定义路径按钮
            helper.domObj.$customLine = helper.$view.find('li._custom_line');

            //电势能变化按钮
            helper.domObj.$energyCheck = helper.$view.find('li._energy_check');
            //静电力做功按钮
            helper.domObj.$electrostaticCheck = helper.$view.find('li._electrostatic_check');
            //正负电荷切换按钮
            helper.domObj.$electricChargeCheck = helper.$view.find('li._electric_charge_check');
            //受力方向按钮
            helper.domObj.$forceDirectionCheck = helper.$view.find('li._force_direction_check');
            //查看分析按钮
            helper.domObj.$viewAnalysisCheck = helper.$view.find('li._view_analysis_check');
            //重置按钮
            helper.domObj.$reset = helper.$view.find('li._reset');

            //电势能变化条形
            helper.domObj.$energyBar = helper.$view.find('div._energy_bar');
            //电势能变化条形值
            helper.domObj.$energyBarValue = helper.$view.find('div._energy_bar_value');
            //静电力做功变化条形
            helper.domObj.$electrostaticBar = helper.$view.find('div._electrostatic_bar');
            //静电力做功变化条形值
            helper.domObj.$electrostaticBarValue = helper.$view.find('div._electrostatic_bar_value');

            //Epb
            helper.domObj.$barEpb = helper.$view.find('div._bar_epb');
            //Ep
            helper.domObj.$barEp = helper.$view.find('div._bar_ep');
            //Wab
            helper.domObj.$barWab = helper.$view.find('div._bar_wab');
            //W
            helper.domObj.$barW = helper.$view.find('div._bar_w');
        },
        _bindEvent: function _bindEvent() {
            //侧边预设按钮点击事件
            helper.domObj.$sceneItems.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.sceneClickHandler(e, $(this).data('name'));
            });

            //电势能变化按钮
            helper.domObj.$energyCheck.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.energyCheckClickHandler(e);
            });
            //静电力做功按钮
            helper.domObj.$electrostaticCheck.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.electrostaticCheckClickHandler(e);
            });
            //正负电荷切换按钮
            helper.domObj.$electricChargeCheck.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.electricChargeCheckClickHandler(e);
            });
            //受力方向按钮
            helper.domObj.$forceDirectionCheck.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.forceDirectionCheckClickHandler(e);
            });
            //查看分析按钮
            helper.domObj.$viewAnalysisCheck.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.viewAnalysisCheckClickHandler(e);
            });
            //重置按钮
            helper.domObj.$reset.on('click', function (e) {
                e.preventDefault();
                powerAndEnergyController.resetClickHandler(e);
            });
            helper.domObj.$straightLineExpression1.on('mousedown', function (e) {});
            helper.domObj.$straightLineExpression1.on('mousemove', function (e) {
                console.log(helper.domObj.$straightLineExpression1.offset().left);
            });
            helper.domObj.$straightLineExpression2.on('mousedown', function (e) {});
            helper.domObj.$straightLineExpression2.on('mousemove', function (e) {
                console.log(helper.domObj.$straightLineExpression2.offset().left);
            });
            helper.$view.on('mouseup', function (e) {});
        },
        _unbindEvent: function _unbindEvent() {}
    }, 'PowerAndEnergy');

    window.AddonPowerAndEnergy_create = function () {
        return new Presenter();
    };
})();
'use strict';

/**
 * BaseView 四个预设模块的基类
 */
define('BaseView', ['ElectricField', 'ChargeTrajectory'], function (ElectricField, ChargeTrajectory) {
    var BaseView = Class.extend({
        $init: function $init(helper, opt) {
            opt = opt || {};
            this._helper = helper;
            //当前预设的名字
            this._name = opt.name;
            //svg容器的父容器
            this._$svgContainer = opt.svgContainer;
            //背景svg容器的父容器，用于画电场
            this._$bgSvgContainer = opt.bgSvgContainer;
            //svg容器，Snap对象
            this._svg = null;
            //背景svg容器，Snap对象
            this._bgSvg = null;
            //电势能变化，true打开，false关闭
            this._energyCheck = opt.energyCheck === undefined ? false : opt.energyCheck;
            //静电力做功,true打开，false关闭
            this._electrostaticCheck = opt.electrostaticCheck === undefined ? true : opt.electrostaticCheck;
            //正负电荷开关，true正电荷，false负电荷
            this._electricChargeCheck = opt.electricChargeCheck === undefined ? true : opt.electricChargeCheck;
            //受力方向开关,true打开，false关闭
            this._forceDirectionCheck = opt.forceDirectionCheck === undefined ? false : opt.forceDirectionCheck;
            //查看分析，true打开，false关闭，null不可用
            this._viewAnalysisCheck = opt.viewAnalysisCheck === undefined ? null : opt.viewAnalysisCheck;
            //重置按钮
            this._resetButton = opt.resetButton === undefined ? true : opt.resetButton;
            // //电势能条形值
            // this._energyBarValue = 0;
            // //电势能条形值Ep文本的位置
            // this._epPos = 0;
            // //电势能条形值Epb文本的位置
            // this._epbPos = 0;
            // //静电力条形值
            // this._electrostaticBarValue = 0;
            // //静电力条形值W文本的位置
            // this._wPos = 0;
            // //静电力条形值Wab文本的位置
            // this._wabPos = 0;

            //条形值
            this._barVal = opt.barVal === undefined ? 0 : opt.barVal;
            //条形Epb和Wab的位置
            this._epbWabPos = opt.epbWabPos === undefined ? 0 : opt.epbWabPos;
            //条形Ep和W的位置
            this._epWPos = opt.epWPos === undefined ? 0 : opt.epWPos;

            this._linePoints = [];
            this._qBezierPoints = [];
        },
        /**
         * 初始化
         */
        init: function init(opt) {
            opt = opt || {};
            var helper = this._helper;

            var electricField = opt.electricField || {};
            this._electricFieldOption = {
                rotateAngle: electricField.rotateAngle === undefined ? 0 : electricField.rotateAngle,
                rotateState: electricField.rotateState === undefined ? true : electricField.rotateState
            };
            var chargeTrajectoryOption = opt.chargeTrajectoryOption || {};
            this._chargeTrajectoryOption = {
                aPos: chargeTrajectoryOption.aPos === undefined ? {
                    x: this._$svgContainer[0].getBoundingClientRect().width / 4,
                    y: this._$svgContainer[0].getBoundingClientRect().height / 3 * 2
                } : chargeTrajectoryOption.aPos,
                bPos: chargeTrajectoryOption.bPos === undefined ? {
                    x: this._$svgContainer[0].getBoundingClientRect().width / 5 * 4,
                    y: this._$svgContainer[0].getBoundingClientRect().height / 4
                } : chargeTrajectoryOption.bPos,
                qPos: chargeTrajectoryOption.qPos === undefined ? {
                    x: this._$svgContainer[0].getBoundingClientRect().width / 4,
                    y: this._$svgContainer[0].getBoundingClientRect().height / 3 * 2
                } : chargeTrajectoryOption.qPos
            };

            //初始化容器
            if (this._svg === null) {
                //背景svg容器初始化
                var bgSvgContainerWidth = this._$bgSvgContainer[0].getBoundingClientRect().width;
                var bgSvgContainerHeight = this._$bgSvgContainer[0].getBoundingClientRect().height;

                this._bgSvg = Snap().attr({
                    width: bgSvgContainerWidth,
                    height: bgSvgContainerHeight,
                    preserveAspectRatio: 'xMidYMid meet',
                    viewBox: '0 0 ' + bgSvgContainerWidth + ' ' + bgSvgContainerHeight
                });
                this._$bgSvgContainer.html(this._bgSvg.node);
                //svg容器初始化
                var svgContainerWidth = this._$svgContainer[0].getBoundingClientRect().width;
                var svgContainerHeight = this._$svgContainer[0].getBoundingClientRect().height;
                this._svg = Snap().attr({
                    width: svgContainerWidth,
                    height: svgContainerHeight,
                    overflow: 'visible',
                    preserveAspectRatio: 'xMidYMid meet',
                    viewBox: '0 0 ' + svgContainerWidth + ' ' + svgContainerHeight
                });
                this._$svgContainer.html(this._svg.node);
                this._electricField = new ElectricField(helper, {
                    svg: this._svg,
                    bgSvg: this._bgSvg,
                    sceneName: this._name,
                    context: this,
                    rotateAngle: this._electricFieldOption.rotateAngle,
                    rotateState: this._electricFieldOption.rotateState
                });

                var leftBound = this._bgSvg.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
                var rightBound = leftBound + this._bgSvg.node.getBoundingClientRect().width;
                this._chargeTrajectory = new ChargeTrajectory(helper, {
                    svg: this._svg,
                    sceneName: this._name,
                    bound: {
                        top: this._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top, //Q点的半径
                        left: leftBound,
                        bottom: this._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top + this._bgSvg.node.getBoundingClientRect().height,
                        right: rightBound
                    },
                    context: this,
                    aPos: this._chargeTrajectoryOption.aPos,
                    bPos: this._chargeTrajectoryOption.bPos,
                    qPos: this._chargeTrajectoryOption.qPos
                });
            }

            this._electricField.init();
            this._chargeTrajectory.init();

            //电势能变化按钮
            var $energyCheckLabel = helper.domObj.$energyCheck.find('label');
            if (this._energyCheck) {
                $energyCheckLabel.addClass('checked');
                helper.domObj.$energyBar.removeClass('hide_visibility');
            } else {
                $energyCheckLabel.removeClass('checked');
                helper.domObj.$energyBar.addClass('hide_visibility');
            }
            //静电力做功按钮
            var $electrostaticCheckLabel = helper.domObj.$electrostaticCheck.find('label');
            if (this._electrostaticCheck) {
                $electrostaticCheckLabel.addClass('checked');
                helper.domObj.$electrostaticBar.removeClass('hide_visibility');
            } else {
                $electrostaticCheckLabel.removeClass('checked');
                helper.domObj.$electrostaticBar.addClass('hide_visibility');
            }
            //正负电荷按钮
            this._electricChargeCheck ? helper.domObj.$electricChargeCheck.addClass('positive') : helper.domObj.$electricChargeCheck.removeClass('positive');
            //受力方向
            var $forceDirectionCheckLabel = helper.domObj.$forceDirectionCheck.find('label');
            this._forceDirectionCheck ? $forceDirectionCheckLabel.addClass('checked') : $forceDirectionCheckLabel.removeClass('checked');
            //初始化查看分析
            this.initViewAnalysis();

            //初始化两个条形
            this.initBar();

            //重置按钮
            this._resetButton ? helper.domObj.$reset.removeClass('disabled') : helper.domObj.$reset.addClass('disabled');

            this._unbindEvent();
            this._bindEvent();
        },
        resizeScreen: function resizeScreen() {
            var helper = this._helper;
            console.log('BasicView');
            //svg容器初始化
            if (this._svg) {
                var svgContainerWidth = helper.saveData.svgWidth;
                var svgContainerHeight = helper.saveData.svgHeight;
                var bgSvgContainerWidth = helper.saveData.svgbgWidth;
                var bgSvgContainerHeight = helper.saveData.svgbgHeight;
                var svgLeft = helper.saveData.svgLeft;
                var svgTop = helper.saveData.svgTop;
                var svgbgLeft = helper.saveData.svgbgLeft;
                var svgbgTop = helper.saveData.svgbgTop;
                this._svg.attr({
                    width: svgContainerWidth,
                    height: svgContainerHeight,
                    overflow: 'visible',
                    preserveAspectRatio: 'xMidYMid meet',
                    viewBox: '0 0 ' + svgContainerWidth + ' ' + svgContainerHeight
                });
                this._bgSvg.attr({
                    width: bgSvgContainerWidth,
                    height: bgSvgContainerHeight,
                    preserveAspectRatio: 'xMidYMid meet',
                    viewBox: '0 0 ' + bgSvgContainerWidth + ' ' + bgSvgContainerHeight
                });

                //let leftBound = svgbgLeft - svgLeft;
                //let rightBound = leftBound +  bgSvgContainerWidth;
                //this._chargeTrajectory._bound = {
                //    top: svgbgTop - svgTop,//Q点的半径
                //    left: leftBound,
                //    bottom: svgbgTop - svgTop + bgSvgContainerHeight,
                //    right: rightBound
                //};
                //let leftBound = this._bgSvg.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
                //let rightBound = leftBound + this._bgSvg.node.getBoundingClientRect().width;
                //this._chargeTrajectory._bound ={
                //    top: this._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top,//Q点的半径
                //    left: leftBound,
                //    bottom: this._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top + this._bgSvg.node.getBoundingClientRect().height,
                //    right: rightBound
                //};
                var ratio = helper.model.ratio;
                if (helper.model.ratio !== helper.model.initRatio) {
                    ratio = 1;
                }
                var leftBound = helper.saveData.leftBound * ratio;
                this._chargeTrajectory._bound = {
                    top: helper.saveData.topBound, //Q点的半径
                    left: leftBound,
                    bottom: helper.saveData.bottomBound,
                    right: leftBound + bgSvgContainerWidth
                };
                this._electricField.resizeScreen();
                this._chargeTrajectory.resizeScreen();
            }
        },

        /**
         * 电势能变化
         */
        energyChange: function energyChange() {
            //barChange
        },
        /**
         * 静电力做功变化
         */
        electrostaticChange: function electrostaticChange() {
            //barChange
        },
        /**
         * 电势能变化和静电力做功变化
         * @param $barEpW
         * @param $epbWab
         * @param $barValue
         */
        barChange: function barChange($barEpW, $epbWab, $barValue) {
            var helper = this._helper;
            var aPos = this._chargeTrajectory._aPos;
            var bPos = this._chargeTrajectory._bPos;
            var qPos = this._chargeTrajectory._qPos;
            this._barVal = this._epWPos = this._calcEpW();
            var barVal = this._barVal * 100 * 0.5;
            var result = this.isForwardDirectionAction(aPos, qPos);

            var epWPos = this._epWPos * 100 * 0.5;
            var ep = void 0,
                w = void 0;
            if (this._electricChargeCheck) {
                //正电荷
                //result为true做正功，false做负功
                if (result) {
                    //正功
                    helper.domObj.$energyBarValue.removeClass('up');
                    helper.domObj.$electrostaticBarValue.addClass('up');

                    ep = epWPos < 10 ? 60 : epWPos + 50;
                    w = epWPos < 10 ? 40 : 50 - epWPos;
                } else {
                    //负功
                    helper.domObj.$energyBarValue.addClass('up');
                    helper.domObj.$electrostaticBarValue.removeClass('up');

                    ep = epWPos < 10 ? 40 : 50 - epWPos;
                    w = epWPos < 10 ? 60 : epWPos + 50;
                }
            } else {
                //负电荷
                //result为false做正功，true做负功
                if (result) {
                    //负功
                    helper.domObj.$energyBarValue.addClass('up');
                    helper.domObj.$electrostaticBarValue.removeClass('up');

                    ep = epWPos < 10 ? 40 : 50 - epWPos;
                    w = epWPos < 10 ? 60 : epWPos + 50;
                } else {
                    //正功
                    helper.domObj.$energyBarValue.removeClass('up');
                    helper.domObj.$electrostaticBarValue.addClass('up');

                    ep = epWPos < 10 ? 60 : epWPos + 50;
                    w = epWPos < 10 ? 40 : 50 - epWPos;
                }
            }
            if (this._epWPos >= this._epbWabPos && bPos.x === qPos.x && bPos.y === qPos.y) {
                helper.domObj.$barEp.css({
                    top: ep + '%'
                }).addClass('hide_dom');
                helper.domObj.$barW.css({
                    top: w + '%'
                }).addClass('hide_dom');

                helper.domObj.$barEpb.removeClass('hide_dom');
                helper.domObj.$barWab.removeClass('hide_dom');
            } else {
                helper.domObj.$barEp.css({
                    top: ep + '%'
                });
                helper.domObj.$barW.css({
                    top: w + '%'
                });
                if (barVal === 0) {
                    helper.domObj.$barEp.addClass('hide_dom');
                    helper.domObj.$barW.addClass('hide_dom');
                } else {
                    helper.domObj.$barEp.removeClass('hide_dom');
                    helper.domObj.$barW.removeClass('hide_dom');
                }

                helper.domObj.$barEpb.addClass('hide_dom');
                helper.domObj.$barWab.addClass('hide_dom');
            }

            helper.domObj.$energyBarValue.css({
                height: barVal + '%'
            });
            helper.domObj.$electrostaticBarValue.css({
                height: barVal + '%'
            });
        },
        /**
         * 获取当前线上的所有点
         */
        getLinePoints: function getLinePoints(a, b) {
            return this._linePoints;
        },
        showAnalysisPath: function showAnalysisPath() {
            var aPos = this._chargeTrajectory._aPos;
            var bPos = this._chargeTrajectory._bPos;
            var rotateAngle = this._electricField._rotateAngle;

            var points = [];
            //A点
            points.push([aPos.x, aPos.y]);
            //求交点
            var breakPoint = this._breakPoint(rotateAngle, aPos, bPos);
            points.push([breakPoint.x, breakPoint.y]);
            //B点
            points.push([bPos.x, bPos.y]);

            this._chargeTrajectory._analysisPath.attr({
                points: points.join(',')
            });
            //显示M点
            this._showMText(breakPoint);
            //显示垂足
            this._showFootPoint(breakPoint);
            //显示B(M)字母位置
            this._showBMText(breakPoint);
            //显示A(M)字母位置
            this._showAMText(breakPoint);
            //微分
            this.segmentation();
        },
        removeAnalysisPath: function removeAnalysisPath() {
            this._chargeTrajectory._analysisPath.attr({
                points: '0,0,0,0'
            });
            //隐藏M点
            this._chargeTrajectory._mText.addClass('hide_dom');
            //隐藏B(M)
            this._chargeTrajectory._bmTextGroup.addClass('hide_dom');
            //隐藏A(M)
            this._chargeTrajectory._amTextGroup.addClass('hide_dom');
            //隐藏垂足
            this._chargeTrajectory._footPoint.addClass('hide_dom');
            //显示B字母
            this._chargeTrajectory._bText.removeClass('hide_dom');
            //显示A字母
            this._chargeTrajectory._aText.removeClass('hide_dom');
        },
        /**
         * 移动A点
         */
        moveA: function moveA() {
            var helper = this._helper;
            //移动A时，AQ之间的路径点要清除
            this._qBezierPoints = [];
            this.initBar();
            helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnAPointMoveEvent, {
                source: this.name
            });
        },
        /**
         * 移动B点
         */
        moveB: function moveB() {
            var helper = this._helper;
            this.initBar();
            helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnBPointMoveEvent, {
                source: this.name
            });
        },
        /**
         * 移动Q点
         */
        moveQ: function moveQ() {
            var helper = this._helper;
            //电势能变化和静电力做功变化
            this.barChange();
            helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnQPointMoveEvent, {
                source: this.name
            });
        },
        /**
         * 切分电荷运动轨迹
         */
        segmentation: function segmentation() {},
        /**
         * 获取公式对应的DOM
         */
        getCurrentExpressionDom: function getCurrentExpressionDom() {
            //do nothing
        },
        /**
         * 获取当前预设的所有公式数组
         */
        getExpressionsDom: function getExpressionsDom() {
            //do nothing
        },
        //重置
        reset: function reset() {
            //电势能变化，true打开，false关闭
            this._energyCheck = false;
            //静电力做功,true打开，false关闭
            this._electrostaticCheck = true;
            //正负电荷开关，true正电荷，false负电荷
            this._electricChargeCheck = true;
            //受力方向开关,true打开，false关闭
            this._forceDirectionCheck = false;
            //查看分析，true打开，false关闭，null不可用
            this._viewAnalysisCheck = null;
            //重置按钮
            this._resetButton = false;
            //电势能条形值
            this._energyBarValue = 0;
            //电势能条形值文本的位置
            this._energyBarTxtPos = { x: 0, y: 0 };
            //静电力条形值
            this._electrostaticBarValue = 0;
            //静电力条形值文本的位置
            this._electrostaticBarTxtPos = { x: 0, y: 0 };

            this.init();
        },
        /**
         * 取两点间的贝塞尔曲线点,返回：{x:*,y:*}对象的数组
         * @param p1
         * @param p2
         */
        getBezierPoints: function getBezierPoints(start, end) {
            //do nothing
        },
        /**
         * 取两点间的贝塞尔曲线点,返回：{x:*,y:*}对象的数组
         * @param p1
         * @param p2
         */
        getQBezierPoints: function getQBezierPoints(start, end) {
            this._qBezierPoints = this.getBezierPoints(start, end);
            return this._qBezierPoints;
        },
        /**
         * 获取一个控制点的贝塞尔曲线上对应的点
         * @param start
         * @param end
         * @param t 值为0-1之间
         * @return {{x: *, y: *}}
         * @private
         */
        get1Bezier: function get1Bezier(start, end, t) {
            var x = start.x + (end.x - start.x) * t;
            var y = start.y + (end.y - start.y) * t;
            return {
                x: x,
                y: y
            };
        },
        /**
         * 获取二个控制点的贝塞尔曲线上对应的点
         * @param start
         * @param ctrl
         * @param end
         * @param t
         * @return {{x: number, y: number}}
         * @private
         */
        get2Bezier: function get2Bezier(start, ctrl, end, t) {
            var x = Math.pow(1 - t, 2) * start.x + 2 * t * (1 - t) * ctrl.x + Math.pow(t, 2) * end.x;
            var y = Math.pow(1 - t, 2) * start.y + 2 * t * (1 - t) * ctrl.y + Math.pow(t, 2) * end.y;
            return {
                x: x,
                y: y
            };
        }, /**
           * 求两点间的距离
           * @param start
           * @param end
           * @return {number}
           * @private
           */
        get2PointDistance: function get2PointDistance(start, end) {
            return Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2));
        },
        /**
         * 判断是否正向做功,两个向量相乘大于0同向，小于0反向
         */
        isForwardDirectionAction: function isForwardDirectionAction(start, end) {
            var breakPoint = this._breakPoint(this._electricField._rotateAngle, start, end);
            var qVector = {
                x: breakPoint.x - start.x,
                y: breakPoint.y - start.y
            };
            var eVector = this._electricFieldVector();
            return qVector.x * eVector.x + qVector.y * eVector.y > 0 ? true : false;
        },
        initBar: function initBar() {
            var helper = this._helper;
            this._epbWabPos = this._calcEpbWab();
            this._barVal = this._epWPos = this._calcEpW();

            var aPos = this._chargeTrajectory._aPos;
            var bPos = this._chargeTrajectory._bPos;

            var epbWabPos = void 0,
                epWPos = void 0,
                barVal = void 0;
            var epb = void 0,
                wab = void 0,
                ep = void 0,
                w = void 0;
            var result = this.isForwardDirectionAction(aPos, bPos);
            epb = wab = epbWabPos = this._epbWabPos * 100 * 0.5;
            ep = w = epWPos = this._epWPos * 100 * 0.5;
            barVal = this._barVal * 100 * 0.5;

            if (this._electricChargeCheck) {
                //正电荷
                //result为true做正功，false做负功
                if (result) {
                    //正功
                    helper.domObj.$energyBarValue.removeClass('up');
                    helper.domObj.$electrostaticBarValue.addClass('up');
                    //60不会被挡住
                    epb = epbWabPos < 10 ? 60 : epbWabPos + 50;
                    ep = epWPos < 10 ? 60 : epWPos + 50;
                    //40不会被挡住
                    wab = epbWabPos < 10 ? 40 : 50 - epbWabPos;
                    w = epWPos < 10 ? 40 : 50 - epWPos;
                } else {
                    //负功
                    helper.domObj.$energyBarValue.addClass('up');
                    helper.domObj.$electrostaticBarValue.removeClass('up');
                    //60不会被挡住
                    wab = epbWabPos < 10 ? 60 : epbWabPos + 50;
                    w = epWPos < 10 ? 60 : epWPos + 50;
                    //40不会被挡住
                    epb = epbWabPos < 10 ? 40 : 50 - epbWabPos;
                    ep = epWPos < 10 ? 40 : 50 - epWPos;
                }
            } else {
                //负电荷
                //result为false做正功，true做负功
                if (result) {
                    //负功
                    helper.domObj.$energyBarValue.addClass('up');
                    helper.domObj.$electrostaticBarValue.removeClass('up');
                    //60不会被挡住
                    wab = epbWabPos < 10 ? 60 : epbWabPos + 50;
                    w = epWPos < 10 ? 60 : epWPos + 50;
                    //40不会被挡住
                    epb = epbWabPos < 10 ? 40 : 50 - epbWabPos;
                    ep = epWPos < 10 ? 40 : 50 - epWPos;
                } else {
                    //正功
                    helper.domObj.$energyBarValue.removeClass('up');
                    helper.domObj.$electrostaticBarValue.addClass('up');
                    //60不会被挡住
                    epb = epbWabPos < 10 ? 60 : epbWabPos + 50;
                    ep = epWPos < 10 ? 60 : epWPos + 50;
                    //40不会被挡住
                    wab = epbWabPos < 10 ? 40 : 50 - epbWabPos;
                    w = epWPos < 10 ? 40 : 50 - epWPos;
                }
            }

            //电势能条形
            helper.domObj.$barEpb.css({
                top: epb + '%'
            }).addClass('hide_dom');
            helper.domObj.$barEp.css({
                top: ep + '%'
            }).addClass('hide_dom');
            helper.domObj.$energyBarValue.css({
                height: barVal + '%'
            });

            //静电力做功条形
            helper.domObj.$barWab.css({
                top: wab + '%'
            }).addClass('hide_dom');
            helper.domObj.$barW.css({
                top: w + '%'
            }).addClass('hide_dom');
            helper.domObj.$electrostaticBarValue.css({
                height: barVal + '%'
            });

            if (epWPos >= epbWabPos && epWPos !== 0 && epbWabPos !== 0) {
                //到顶了
                helper.domObj.$barEp.addClass('hide_dom');
                helper.domObj.$barW.addClass('hide_dom');

                helper.domObj.$barEpb.removeClass('hide_dom');
                helper.domObj.$barWab.removeClass('hide_dom');
            } else {
                if (barVal === 0) {
                    helper.domObj.$barEp.addClass('hide_dom');
                    helper.domObj.$barW.addClass('hide_dom');
                } else {
                    helper.domObj.$barEp.removeClass('hide_dom');
                    helper.domObj.$barW.removeClass('hide_dom');
                }

                helper.domObj.$barEpb.addClass('hide_dom');
                helper.domObj.$barWab.addClass('hide_dom');
            }
        },
        /**
         * 初始化查看分析
         */
        initViewAnalysis: function initViewAnalysis() {
            var helper = this._helper;
            var $viewAnalysisCheckLabel = helper.domObj.$viewAnalysisCheck.find('label');
            helper.domObj.$viewAnalysisCheck.removeClass('disabled');
            if (this._viewAnalysisCheck === true) {
                $viewAnalysisCheckLabel.addClass('checked');
            } else if (this._viewAnalysisCheck === false) {
                $viewAnalysisCheckLabel.removeClass('checked');
            } else {
                $viewAnalysisCheckLabel.removeClass('checked');
                helper.domObj.$viewAnalysisCheck.addClass('disabled');
            }

            //---------------------------------
            if (this._viewAnalysisCheck) {
                //查看分析打开
                var $expression = this.getCurrentExpressionDom();
                //显示公式
                $expression.removeClass('hide_dom');
                if (this._energyCheck && this._electrostaticCheck) {
                    // 两个都打开
                    $expression.find('p').removeClass('hide_dom');
                } else if (this._energyCheck) {
                    // 电势能打开
                    $expression.find('p:nth-child(1)').addClass('hide_dom');
                    $expression.find('p:nth-child(2)').removeClass('hide_dom');
                } else if (this._electrostaticCheck) {
                    // 静电力打开
                    $expression.find('p:nth-child(1)').removeClass('hide_dom');
                    $expression.find('p:nth-child(2)').addClass('hide_dom');
                } else {
                    // 两个都关闭
                    $expression.addClass('hide_dom');
                }

                //显示分析路径
                this.showAnalysisPath();
            } else {
                //查看分析关闭
                //隐藏公式
                var $expressions = this.getExpressionsDom();
                for (var i = 0, iLen = $expressions.length; i < iLen; i++) {
                    $expressions[i].addClass('hide_dom');
                }
                //移除分析路径
                this.removeAnalysisPath();
            }
        },
        _showMText: function _showMText(breakPoint) {
            var ct = this._chargeTrajectory;
            ct._mText.removeClass('hide_dom');

            var mTextPos = { x: breakPoint.x, y: breakPoint.y };
            //调整坐标
            if (breakPoint.x >= ct._bound.right - ct._mText.node.getBoundingClientRect().width) {
                // m在最右边
                mTextPos = {
                    x: breakPoint.x - 2 * ct._mText.node.getBoundingClientRect().width,
                    y: breakPoint.y + ct._mText.node.getBoundingClientRect().height / 2
                };
            } else {
                if (breakPoint.x < ct._aPos.x) {
                    mTextPos = {
                        x: breakPoint.x - ct._mText.node.getBoundingClientRect().width,
                        y: breakPoint.y + ct._mText.node.getBoundingClientRect().height / 2
                    };
                } else {
                    mTextPos = {
                        x: breakPoint.x + ct._mText.node.getBoundingClientRect().width / 2,
                        y: breakPoint.y + ct._mText.node.getBoundingClientRect().height / 2
                    };
                }
            }

            var ax = ct._aText.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
            var ay = ct._aText.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top;
            var bx = ct._bText.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
            var by = ct._bText.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top;

            //防止B和M水平重叠
            if (by > mTextPos.y && by < mTextPos.y + ct._mText.node.getBoundingClientRect().height || mTextPos.y > by && mTextPos.y < by + ct._bText.node.getBoundingClientRect().height) {
                if (bx > mTextPos.x && bx < mTextPos.x + ct._mText.node.getBoundingClientRect().width) {
                    //b在m中间
                    if (mTextPos.x + ct._mText.node.getBoundingClientRect().width > ct._bound.right || bx + ct._bText.node.getBoundingClientRect().width > ct._bound.right) {
                        // b和m在最右边
                        mTextPos.x = mTextPos.x - ct._mText.node.getBoundingClientRect().width;
                    } else {
                        mTextPos.x = mTextPos.x + ct._mText.node.getBoundingClientRect().width;
                    }
                }
                if (mTextPos.x > bx && mTextPos.x < bx + ct._bText.node.getBoundingClientRect().width) {
                    //m在b中间
                    if (mTextPos.x + ct._mText.node.getBoundingClientRect().width > ct._bound.right || bx + ct._bText.node.getBoundingClientRect().width > ct._bound.right) {
                        // b和m在最右边
                        mTextPos.x = mTextPos.x - ct._mText.node.getBoundingClientRect().width;
                    } else {
                        mTextPos.x = mTextPos.x + ct._mText.node.getBoundingClientRect().width;
                    }
                }
            }
            //防止B和M垂直重叠
            if (bx > mTextPos.x && bx < mTextPos.x + ct._mText.node.getBoundingClientRect().width || mTextPos.x > bx && mTextPos.x < bx + ct._bText.node.getBoundingClientRect().width) {
                if (by > mTextPos.y && by < mTextPos.y + ct._mText.node.getBoundingClientRect().height) {
                    if (mTextPos.y > by) {
                        mTextPos.y = mTextPos.y - ct._mText.node.getBoundingClientRect().height;
                    } else {
                        mTextPos.y = mTextPos.y + ct._bText.node.getBoundingClientRect().height;
                    }
                }
                if (mTextPos.y > by && mTextPos.y < by + ct._bText.node.getBoundingClientRect().height) {
                    if (mTextPos.y > by) {
                        mTextPos.y = mTextPos.y - ct._mText.node.getBoundingClientRect().height;
                    } else {
                        mTextPos.y = mTextPos.y + ct._bText.node.getBoundingClientRect().height;
                    }
                }
            }
            //防止A和M水平重叠
            if (ay > mTextPos.y && ay < mTextPos.y + ct._mText.node.getBoundingClientRect().height || mTextPos.y > ay && mTextPos.y < ay + ct._bText.node.getBoundingClientRect().height) {
                if (ax > mTextPos.x && ax < mTextPos.x + ct._mText.node.getBoundingClientRect().width) {
                    //b在m中间
                    if (mTextPos.x + ct._mText.node.getBoundingClientRect().width > ct._bound.right || ax + ct._bText.node.getBoundingClientRect().width > ct._bound.right) {
                        // b和m在最右边
                        mTextPos.x = mTextPos.x - ct._mText.node.getBoundingClientRect().width;
                    } else {
                        mTextPos.x = mTextPos.x + ct._mText.node.getBoundingClientRect().width;
                    }
                }
                if (mTextPos.x > ax && mTextPos.x < ax + ct._bText.node.getBoundingClientRect().width) {
                    //m在b中间
                    if (mTextPos.x + ct._mText.node.getBoundingClientRect().width > ct._bound.right || ax + ct._bText.node.getBoundingClientRect().width > ct._bound.right) {
                        // b和m在最右边
                        mTextPos.x = mTextPos.x - ct._mText.node.getBoundingClientRect().width;
                    } else {
                        mTextPos.x = mTextPos.x + ct._mText.node.getBoundingClientRect().width;
                    }
                }
            }
            //防止A和M垂直重叠
            if (ax > mTextPos.x && ax < mTextPos.x + ct._mText.node.getBoundingClientRect().width || mTextPos.x > ax && mTextPos.x < ax + ct._bText.node.getBoundingClientRect().width) {
                if (ay > mTextPos.y && ay < mTextPos.y + ct._mText.node.getBoundingClientRect().height) {
                    if (mTextPos.y > ay) {
                        mTextPos.y = mTextPos.y - ct._mText.node.getBoundingClientRect().height;
                    } else {
                        mTextPos.y = mTextPos.y + ct._bText.node.getBoundingClientRect().height;
                    }
                }
                if (mTextPos.y > ay && mTextPos.y < ay + ct._bText.node.getBoundingClientRect().height) {
                    if (mTextPos.y > ay) {
                        mTextPos.y = mTextPos.y - ct._mText.node.getBoundingClientRect().height;
                    } else {
                        mTextPos.y = mTextPos.y + ct._bText.node.getBoundingClientRect().height;
                    }
                }
            }

            ct._mText.attr({
                transform: 'translate(' + mTextPos.x + ',' + mTextPos.y + ')'
            });
        },
        _showFootPoint: function _showFootPoint(breakPoint) {
            var aPos = this._chargeTrajectory._aPos;
            var bPos = this._chargeTrajectory._bPos;
            var amDis = this.get2PointDistance(aPos, breakPoint);
            var bmDis = this.get2PointDistance(bPos, breakPoint);
            var bp1 = void 0,
                bp2 = void 0;
            var footPoint = void 0;
            if (amDis < bmDis) {
                bp1 = this.get1Bezier(breakPoint, aPos, 0.1);
                bp2 = this.get1Bezier(breakPoint, bPos, amDis / bmDis * 0.1);
                footPoint = this._breakPoint(this._electricField._rotateAngle, bp2, bp1);
            } else {
                bp1 = this.get1Bezier(breakPoint, bPos, 0.1);
                bp2 = this.get1Bezier(breakPoint, aPos, bmDis / amDis * 0.1);
                footPoint = this._breakPoint(this._electricField._rotateAngle, bp1, bp2);
            }

            var bp = [];
            bp.push([bp1.x, bp1.y]);
            bp.push([footPoint.x, footPoint.y]);
            bp.push([bp2.x, bp2.y]);
            this._chargeTrajectory._footPoint.removeClass('hide_dom');
            this._chargeTrajectory._footPoint.attr({
                points: bp.join(',')
            });
        },
        _showBMText: function _showBMText(breakPoint) {
            var bPos = this._chargeTrajectory._bPos;
            if (breakPoint.x === bPos.x && breakPoint.y === bPos.y) {
                this._chargeTrajectory._bmTextGroup.removeClass('hide_dom');
                var bound = this._chargeTrajectory._bound;
                if (bound.right < this._chargeTrajectory._bmTextGroup.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left + this._chargeTrajectory._bmTextGroup.node.getBoundingClientRect().width) {
                    this._chargeTrajectory._bmTextPos.x = bound.right - this._chargeTrajectory._bmTextGroup.node.getBoundingClientRect().width - this._chargeTrajectory._qPointRadius;
                    this._chargeTrajectory._bmTextGroup.attr({
                        transform: 'translate(' + this._chargeTrajectory._bmTextPos.x + ',' + this._chargeTrajectory._bmTextPos.y + ')'
                    });
                }

                this._chargeTrajectory._bText.addClass('hide_dom');
                this._chargeTrajectory._mText.addClass('hide_dom');
            }
        },
        _showAMText: function _showAMText(breakPoint) {
            var aPos = this._chargeTrajectory._aPos;
            if (breakPoint.x === aPos.x && breakPoint.y === aPos.y) {
                this._chargeTrajectory._amTextGroup.removeClass('hide_dom');
                var bound = this._chargeTrajectory._bound;
                if (bound.right < this._chargeTrajectory._amTextGroup.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left + this._chargeTrajectory._amTextGroup.node.getBoundingClientRect().width) {
                    this._chargeTrajectory._amTextPos.x = bound.right - this._chargeTrajectory._amTextGroup.node.getBoundingClientRect().width;
                    this._chargeTrajectory._amTextGroup.attr({
                        transform: 'translate(' + this._chargeTrajectory._amTextPos.x + ',' + this._chargeTrajectory._amTextPos.y + ')'
                    });
                }

                this._chargeTrajectory._aText.addClass('hide_dom');
                this._chargeTrajectory._mText.addClass('hide_dom');
            }
        },
        /**
         * 计算Epb和Wab位置
         * @private
         */
        _calcEpbWab: function _calcEpbWab() {
            var rotateAngle = this._electricField._rotateAngle;
            var a = this._chargeTrajectory._aPos;
            var b = this._chargeTrajectory._bPos;
            var breakPoint = this._breakPoint(rotateAngle, a, b);
            var dis = this.get2PointDistance(a, breakPoint);
            return Number((dis / this._maxElectricFieldDisplacement()).toFixed(5));
        },
        /**
         * 计算Ep和w位置,电荷Q的做功值
         * @private
         */
        _calcEpW: function _calcEpW() {
            var rotateAngle = this._electricField._rotateAngle;
            var a = this._chargeTrajectory._aPos;
            var q = this._chargeTrajectory._qPos;
            var breakPoint = this._breakPoint(rotateAngle, a, q);
            var dis = this.get2PointDistance(a, breakPoint);
            return Number((dis / this._maxElectricFieldDisplacement()).toFixed(5));
        },
        _breakPoint: function _breakPoint(rotateAngle, a, b) {
            var point = {};
            if (rotateAngle === 0 || rotateAngle === 90 || rotateAngle === 180 || rotateAngle === 270) {
                //0度或90度时，斜率会不存在
                if (a.x === b.x) {
                    //ab在一条垂线上
                    if (rotateAngle === 0 || rotateAngle === 180) {
                        point = a;
                    } else {
                        point = b;
                    }
                } else if (a.y === b.y) {
                    //ab在一条水平线上
                    if (rotateAngle === 0 || rotateAngle === 180) {
                        point = b;
                    } else {
                        point = a;
                    }
                } else if (a.x < b.x && a.y < b.y) {
                    //a在b的左上
                    if (rotateAngle === 0 || rotateAngle === 180) {
                        point = {
                            x: b.x, y: a.y
                        };
                    } else {
                        point = {
                            x: a.x, y: b.y
                        };
                    }
                } else if (a.x < b.x && a.y > b.y) {
                    //a在b的左下
                    if (rotateAngle === 0 || rotateAngle === 180) {
                        point = {
                            x: b.x, y: a.y
                        };
                    } else {
                        point = {
                            x: a.x, y: b.y
                        };
                    }
                } else if (a.x > b.x && a.y < b.y) {
                    //a在b的右上
                    if (rotateAngle === 0 || rotateAngle === 180) {
                        point = {
                            x: b.x, y: a.y
                        };
                    } else {
                        point = {
                            x: a.x, y: b.y
                        };
                    }
                } else if (a.x > b.x && a.y > b.y) {
                    //a在b的右下
                    if (rotateAngle === 0 || rotateAngle === 180) {
                        point = {
                            x: b.x, y: a.y
                        };
                    } else {
                        point = {
                            x: a.x, y: b.y
                        };
                    }
                }
            } else {
                //求交点
                var ak = Math.tan(rotateAngle * Math.PI / 180);
                var bk = -1 / ak;
                //以下推导公式
                /*
                 y-y1=k(x-x1)
                 a:y-a.y = ak(x-a.x) => y=ak*(x-a.x)+a.y
                 b:y-b.y = bk(x-b.x) => y = bk*(x-b.x) + b.y
                 ak*(x-a.x)+a.y = bk*(x-b.x)+b.y
                 ak*x -ak*a.x + a.y = bk*x - bk*b.x + b.y
                 ak*x - bk*x = ak*a.x - a.y - bk*b.x + b.y
                 (ak-bk)x = ak*a.x - a.y - bk*b.x + b.y
                 x = (ak*a.x - a.y - bk*b.x + b.y)/(ak-bk)
                 */
                var x = (ak * a.x - a.y - bk * b.x + b.y) / (ak - bk);
                var y = ak * (x - a.x) + a.y;
                point = {
                    x: x,
                    y: y
                };
            }

            point = {
                x: Number(point.x.toFixed(5)),
                y: Number(point.y.toFixed(5))
            };
            return point;
        },
        /**
         * 求电场最大的位移值
         * @private
         */
        _maxElectricFieldDisplacement: function _maxElectricFieldDisplacement() {
            var rotateAngle = this._electricField._rotateAngle;
            if (rotateAngle === 0 || rotateAngle === 180) {
                return this._bgSvg.node.getBoundingClientRect().width;
            }
            if (rotateAngle === 90 || rotateAngle === 270) {
                return this._bgSvg.node.getBoundingClientRect().height;
            }
            var maxVal = 0;
            var xDiff = this._bgSvg.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
            //斜率k
            var k = Math.tan(rotateAngle * Math.PI / 180);

            if (rotateAngle > 270 && rotateAngle < 360) {
                // 270-360
                var point = {
                    x: 0,
                    y: this._bgSvg.node.getBoundingClientRect().height
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求y=0时，x的值
                var x = (0 + k * point.x - point.y) / k;
                if (x > this._bgSvg.node.getBoundingClientRect().width) {
                    x = this._bgSvg.node.getBoundingClientRect().width;
                }
                var y = k * x - k * point.x + point.y;
                maxVal = this.get2PointDistance(point, { x: x, y: y });
            } else if (rotateAngle > 180 && rotateAngle < 270) {
                //180-270
                var _point = {
                    x: this._bgSvg.node.getBoundingClientRect().width,
                    y: this._bgSvg.node.getBoundingClientRect().height
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求y=0时，x的值
                var _x = (0 + k * _point.x - _point.y) / k;
                if (_x < 0) {
                    _x = 0;
                }
                var _y = k * _x - k * _point.x + _point.y;
                maxVal = this.get2PointDistance(_point, { x: _x, y: _y });
            } else if (rotateAngle > 90 && rotateAngle < 180) {
                //90-180
                var _point2 = {
                    x: this._bgSvg.node.getBoundingClientRect().width,
                    y: 0
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求x=0时，y的值
                var _y2 = k * 0 - k * _point2.x + _point2.y;
                if (_y2 > this._bgSvg.node.getBoundingClientRect().height) {
                    _y2 = this._bgSvg.node.getBoundingClientRect().height;
                }
                var _x2 = (_y2 + k * _point2.x - _point2.y) / k;
                maxVal = this.get2PointDistance(_point2, { x: _x2, y: _y2 });
            } else {
                //0-90
                var _point3 = {
                    x: 0,
                    y: 0
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求x=this._bgSvg.node.getBoundingClientRect().width时，y的值
                var _y3 = k * this._bgSvg.node.getBoundingClientRect().width - k * _point3.x + _point3.y;
                if (_y3 > this._bgSvg.node.getBoundingClientRect().height) {
                    _y3 = this._bgSvg.node.getBoundingClientRect().height;
                }
                var _x3 = (_y3 + k * _point3.x - _point3.y) / k;
                maxVal = this.get2PointDistance(_point3, { x: _x3, y: _y3 });
            }
            return maxVal;
        },
        /**
         * 求电场的向量值
         * @private
         */
        _electricFieldVector: function _electricFieldVector() {
            var rotateAngle = this._electricField._rotateAngle;
            if (rotateAngle === 0) {
                return {
                    x: this._bgSvg.node.getBoundingClientRect().width,
                    y: 0
                };
            }
            if (rotateAngle === 90) {
                return {
                    x: 0,
                    y: this._bgSvg.node.getBoundingClientRect().height
                };
            }
            if (rotateAngle === 180) {
                return {
                    x: -this._bgSvg.node.getBoundingClientRect().width,
                    y: 0
                };
            }
            if (rotateAngle === 270) {
                return {
                    x: 0,
                    y: -this._bgSvg.node.getBoundingClientRect().height
                };
            }

            var vector = void 0;
            //斜率k
            var k = Math.tan(rotateAngle * Math.PI / 180);
            var x = void 0,
                y = void 0;
            var point = void 0;
            if (rotateAngle > 270 && rotateAngle < 360) {
                // 270-360
                point = {
                    x: 0,
                    y: this._bgSvg.node.getBoundingClientRect().height
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求y=0时，x的值
                x = (0 + k * point.x - point.y) / k;
                y = k * x - k * point.x + point.y;
            } else if (rotateAngle > 180 && rotateAngle < 270) {
                //180-270
                point = {
                    x: this._bgSvg.node.getBoundingClientRect().width,
                    y: this._bgSvg.node.getBoundingClientRect().height
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求y=0时，x的值
                x = (0 + k * point.x - point.y) / k;
                y = k * x - k * point.x + point.y;
            } else if (rotateAngle > 90 && rotateAngle < 180) {
                //90-180
                point = {
                    x: this._bgSvg.node.getBoundingClientRect().width,
                    y: 0
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求x=0时，y的值
                y = k * 0 - k * point.x + point.y;
                x = (y + k * point.x - point.y) / k;
            } else {
                //0-90
                point = {
                    x: 0,
                    y: 0
                };
                //y-y1=k(x-x1) => y = k*x - k*x1 + y1 => x = (y + k*x1 - y1) / k
                //求x=this._bgSvg.node.getBoundingClientRect().width时，y的值
                y = k * this._bgSvg.node.getBoundingClientRect().width - k * point.x + point.y;
                x = (y + k * point.x - point.y) / k;
            }
            return {
                x: x - point.x,
                y: y - point.y
            };
        },
        _bindEvent: function _bindEvent() {},
        _unbindEvent: function _unbindEvent() {}
    });
    return BaseView;
});
'use strict';

/**
 * ChargeTrajectory 电荷运动轨迹类
 */
define('ChargeTrajectory', function () {
    var ChargeTrajectory = Class.extend({
        $init: function $init(helper, opt) {
            this._helper = helper;
            this.sceneName = opt.sceneName;
            this._context = opt.context;
            //svg容器,Snap对象
            this._svg = opt.svg;
            //A点的坐标位置
            this._aPos = opt.aPos || { x: 0, y: 0 };
            //B点的坐标位置
            this._bPos = opt.bPos || { x: 200, y: 0 };
            //Q点的坐标位置
            this._qPos = opt.qPos || { x: 0, y: 0 };
            //ABQ可移动的边界
            this._bound = opt.bound;
            //A点的状态，true为可移动，false不可移动
            this._aState = opt.aState === undefined ? true : opt.aState;
            //B点的状态，true为可移动，flase不可移动
            this._bState = opt.bState === undefined ? true : opt.bState;
            //Q点的状态，true为闪烁，flase不闪烁
            this._qState = opt.qState === undefined ? true : opt.qState;

            var ratio = helper.model.ratio;
            if (helper.model.initRatio == ratio) {
                this.threeStroke = 3 * ratio;
                this.fourStroke = 4 * ratio;
                this.oneStroke = 1 * ratio;
                //Q点，snap对象
                this._qPointRadius = opt.qPointRadius || 42 * ratio;
                this._qSmallPointRadius = opt.qSmallPointRadius || 32 * ratio;
                this.qImageWidth = 45 * ratio;
                this.qImageHeight = 35 * ratio;
                this._qTransformX = -25 * ratio;
                this._qTransformY = -15 * ratio;
                //F的路径
                this.d = 'M ' + ' ' + 48.33 * ratio + ' ' + 0.00 * ratio + ' ' + 'L ' + ' ' + 48.71 * ratio + ' ' + 0.00 * ratio + ' ' + 'C' + ' ' + 51.32 * ratio + ' ' + 4.14 * ratio + ' ' + 56.24 * ratio + ' ' + 5.49 * ratio + ' ' + 60.35 * ratio + ' ' + 7.61 * ratio + ' ' + 'C' + ' ' + 69.05 * ratio + ' ' + 10.50 * ratio + ' ' + 78.02 * ratio + ' ' + 12.58 * ratio + ' ' + 86.71 * ratio + ' ' + 15.53 * ratio + ' ' + 'C' + ' ' + 86.76 * ratio + ' ' + 15.77 * ratio + ' ' + 86.88 * ratio + ' ' + 16.24 * ratio + ' ' + 86.94 * ratio + ' ' + 16.48 * ratio + ' ' + 'C' + ' ' + 76.28 * ratio + ' ' + 19.92 * ratio + ' ' + 65.18 * ratio + ' ' + 22.20 * ratio + ' ' + 55.00 * ratio + ' ' + 27.00 * ratio + ' ' + 'C' + ' ' + 52.56 * ratio + ' ' + 28.29 * ratio + ' ' + 49.90 * ratio + ' ' + 29.57 * ratio + ' ' + 48.39 * ratio + ' ' + 32.00 * ratio + ' ' + 'L' + ' ' + 48.34 * ratio + ' ' + 32.00 * ratio + ' ' + 'C' + ' ' + 47.89 * ratio + ' ' + 26.55 * ratio + ' ' + 51.76 * ratio + ' ' + 22.10 * ratio + ' ' + 54.80 * ratio + ' ' + 18.00 * ratio + ' ' + 'C' + ' ' + 36.54 * ratio + ' ' + 17.99 * ratio + ' ' + 18.27 * ratio + ' ' + 18.00 * ratio + ' ' + 0.00 * ratio + ' ' + 18.00 * ratio + ' ' + 'L' + ' ' + 0.00 * ratio + ' ' + 14.00 * ratio + ' ' + 'C' + ' ' + 18.24 * ratio + ' ' + 14.00 * ratio + ' ' + 36.49 * ratio + ' ' + 14.00 * ratio + ' ' + 54.73 * ratio + ' ' + 14.00 * ratio + ' ' + 'C' + ' ' + 51.72 * ratio + ' ' + 9.88 * ratio + ' ' + 47.76 * ratio + ' ' + 5.48 * ratio + ' ' + 48.33 * ratio + ' ' + 0.00 * ratio + ' ' + 'Z';
                this._abPointRadius = opt.abPointRadius || 15 * ratio;
                this.fRatio = ratio;
            } else {
                this.threeStroke = 3;
                this.fourStroke = 4;
                this.oneStroke = 1;
                //Q点，snap对象
                this._qPointRadius = opt.qPointRadius || 42;
                this._qSmallPointRadius = opt.qSmallPointRadius || 32;
                this.qImageWidth = 45;
                this.qImageHeight = 35;
                this._qTransformX = -25;
                this._qTransformY = -15;
                //F的路径
                this.d = 'M 48.33 0.00 L 48.71 0.00 C 51.32 4.14 56.24 5.49 60.35 7.61 C 69.05 10.50 78.02 12.58 86.71 15.53 C 86.76 15.77 86.88 16.24 86.94 16.48 C 76.28 19.92 65.18 22.20 55.00 27.00 C 52.56 28.29 49.90 29.57 48.39 32.00 L 48.34 32.00 C 47.89 26.55 51.76 22.10 54.80 18.00 C 36.54 17.99 18.27 18.00 0.00 18.00 L 0.00 14.00 C 18.24 14.00 36.49 14.00 54.73 14.00 C 51.72 9.88 47.76 5.48 48.33 0.00 Z';
                //ab点
                this._abPointRadius = opt.abPointRadius || 15;
                this.fRatio = 1;
            }

            //AB之间的虚线路径，Snap对象
            this._abPath = this._svg.paper.polyline().attr({
                points: '0,0,0,0',
                stroke: '#000',
                strokeWidth: this.threeStroke,
                fill: 'none',
                strokeDasharray: '10,9'
            });
            //垂足，Snap对象
            this._footPoint = this._svg.paper.polyline().attr({
                class: 'hide_dom',
                points: '0,0,0,0',
                fill: 'none',
                stroke: '#000',
                strokeWidth: this.threeStroke
            });
            //Q运动路线，Snap对象
            this._qPath = this._svg.paper.polyline().attr({
                points: '0,0,0,0',
                stroke: '#ea7f1b',
                strokeWidth: this.fourStroke,
                fill: 'none'
            });
            //查看分析的虚线路径，Snap对象
            this._analysisPath = this._svg.paper.polyline().attr({
                points: '0,0,0,0',
                fill: 'none',
                stroke: '#000',
                strokeWidth: this.threeStroke,
                strokeDasharray: '10,9'
            });
            //微分容器
            this._segmentationGroup = this._svg.paper.g();

            //Q点，Snap对象
            var qPointGroup = this._svg.paper.g();
            this._qPoint = this._svg.paper.g();
            this._qPoint.add(this._svg.paper.circle(0, 0, this._qPointRadius).attr({
                class: 'qPointAnimationCircle',
                fill: '#fff'
            }));
            //箭头的容器
            this._forceArrowGroup = this._svg.paper.g().attr({
                class: 'forceArrow hide_dom'
            });
            //受力箭头
            var arrowGroup = this._svg.paper.g();
            arrowGroup.add(this._svg.paper.path().attr({
                //d: 'M 69.30 0.00 L 69.70 0.00 C 72.32 4.13 77.23 5.50 81.35 7.61 C 90.09 10.51 99.07 12.61 107.79 15.54 C 107.81 15.77 107.83 16.25 107.84 16.48 C 96.98 20.07 85.61 22.28 75.29 27.36 C 73.13 28.58 70.71 29.74 69.45 32.00 L 69.32 32.00 C 68.90 26.55 72.77 22.15 75.75 18.01 C 50.50 17.98 25.25 18.01 0.00 18.00 L 0.00 14.00 C 25.25 13.99 50.50 14.02 75.75 13.99 C 72.67 9.89 68.84 5.49 69.30 0.00 Z'
                d: this.d
            }));
            //控制旋转arrowGroup.rotate(180,0,${arrowGroup.node.getBoundingClientRect().height / 2})
            arrowGroup.attr({
                class: 'arrow',
                transform: 'translate(0,' + -arrowGroup.node.getBoundingClientRect().height / 2 + ')'
            });
            this._forceArrowGroup.add(arrowGroup);
            var fText = this._svg.paper.text(0, 0, 'F').attr({
                class: 'fText',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            // fText.attr({
            //     transform: `translate(${arrowGroup.node.getBoundingClientRect().width - fText.node.getBoundingClientRect().width},${fText.node.getBoundingClientRect().height})`
            // });
            this._forceArrowGroup.add(fText);
            this._forceArrowGroup.attr({
                transform: 'translate(' + this._qPos.x + ',' + this._qPos.y + ')'
            });
            qPointGroup.add(this._forceArrowGroup);

            this._qPointPlusMinus = {
                plus: {
                    fill: this._svg.paper.gradient("r(0.5, 0.5, 0.5)#fb9d43-#f07603"),
                    filter: this._svg.paper.filter(Snap.filter.shadow(0, 0, 5, '#f67200')),
                    stroke: '#c06900',
                    image: helper.basePath + 'resources/wood/images/q1.png'
                },
                minus: {
                    fill: this._svg.paper.gradient("r(0.5, 0.5, 0.5)#5aafe1-#1caaee"),
                    filter: this._svg.paper.filter(Snap.filter.shadow(0, 0, 5, '#61b2d9')),
                    stroke: '#1d93c8',
                    image: helper.basePath + 'resources/wood/images/q2.png'
                }
            };
            var plusMinus = this._context._electricChargeCheck ? this._qPointPlusMinus.plus : this._qPointPlusMinus.minus;
            this._qPoint.add(this._svg.paper.circle(0, 0, this._qSmallPointRadius).attr({
                class: 'qPointMainCircle',
                fill: plusMinus.fill,
                filter: plusMinus.filter,
                stroke: plusMinus.stroke,
                strokeWidth: this.oneStroke
            }));
            this._qPoint.add(this._svg.paper.image(plusMinus.image, 0, 0, this.qImageWidth, this.qImageHeight).attr({
                class: 'qPointImage',
                transform: 'translate(' + this._qTransformX + ',' + this._qTransformY + ')'
            }));
            this._qPoint.attr({
                transform: 'translate(' + this._qPos.x + ',' + this._qPos.y + ')'
            });
            qPointGroup.add(this._qPoint);

            //A点,Snap对象
            this._aPoint = this._svg.paper.circle(this._aPos.x, this._aPos.y, this._abPointRadius).attr({
                fill: '#06aac3',
                opacity: 0.8,
                stroke: '#fff',
                strokeWidth: this.oneStroke
            });

            //B点，Snap对象
            this._bPoint = this._svg.paper.circle(this._bPos.x, this._bPos.y, this._abPointRadius).attr({
                fill: '#06aac3',
                stroke: '#fff',
                strokeWidth: this.oneStroke
            });
            //线上的贝塞尔点
            this._bezierPoints = [];
            //A文本，Snap对象
            this._aText = this._svg.paper.text(0, 0, 'A').attr({
                class: 'aText',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            //B文本，Snap对象
            this._bText = this._svg.paper.text(0, 0, 'B').attr({
                class: 'bText',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            //M文本，Snap对象
            this._mText = this._svg.paper.text(0, 0, 'M').attr({
                class: 'mText hide_dom',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            //B(M)文本，Snap对象
            this._bmTextPos = { x: 0, y: 0 };
            this._bmTextGroup = this._svg.paper.g().attr({
                class: 'hide_dom'
            });
            var bText = this._svg.paper.text(0, 0, 'B').attr({
                class: 'bmTextB',
                fill: '#626f79',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            var mText = this._svg.paper.text(0, 0, '(M)').attr({
                class: 'bmTextM',
                style: 'font:italic 2.66667em "Times New Roman"',
                transform: 'translate(' + bText.node.getBoundingClientRect().width + ',0)'
            });
            this._bmTextGroup.add(bText);
            this._bmTextGroup.add(mText);

            //A(M)文本，Snap对象
            this._amTextPos = { x: 0, y: 0 };
            this._amTextGroup = this._svg.paper.g().attr({
                class: 'hide_dom'
            });
            var amTextA = this._svg.paper.text(0, 0, 'A').attr({
                class: 'amTextA',
                fill: '#626f79',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            var amTextM = this._svg.paper.text(0, 0, '(M)').attr({
                class: 'bmTextM',
                style: 'font:italic 2.66667em "Times New Roman"',
                transform: 'translate(' + amTextA.node.getBoundingClientRect().width + ',0)'
            });
            this._amTextGroup.add(amTextA);
            this._amTextGroup.add(amTextM);
        },
        resizeScreen: function resizeScreen() {
            var helper = this._helper;
            var svgContainerWidth = helper.saveData.svgWidth;
            var svgContainerHeight = helper.saveData.svgHeight;
            var bgSvgContainerWidth = helper.saveData.svgbgWidth;
            var bgSvgContainerHeight = helper.saveData.svgbgHeight;
            var svgLeft = helper.saveData.svgLeft;
            var svgTop = helper.saveData.svgTop;
            var svgbgLeft = helper.saveData.svgbgLeft;
            var svgbgTop = helper.saveData.svgbgTop;
            console.log('电荷运动轨迹类');
            var ratio = helper.model.ratio;
            this._qPointRadius = this._qPointRadius * ratio;
            this._qSmallPointRadius = this._qSmallPointRadius * ratio;
            this.qImageWidth = this.qImageWidth * ratio;
            this.qImageHeight = this.qImageHeight * ratio;
            this._qTransformX = this._qTransformX * ratio;
            this._qTransformY = this._qTransformY * ratio;
            //AB点的半径
            this._abPointRadius = this._abPointRadius * ratio;
            //forceArrowGroupHeight
            var forceArrowGroupHeight = helper.saveData.forceArrowGroupHeight * ratio;
            if (this._abPath) {
                //debugger
                //A点
                this._amTextPos.x = this._amTextPos.x * ratio;
                this._amTextPos.y = this._amTextPos.y * ratio;
                this._amTextGroup.attr({
                    x: this._amTextPos.x,
                    y: this._amTextPos.y
                });
                var _abpathStrokeWidth = this._abPath.attr("stroke-width").replace('px', '');
                var _footPointStrokeWidth = this._footPoint.attr("stroke-width").replace('px', '');
                var _qPathStrokeWidth = this._qPath.attr("stroke-width").replace('px', '');
                var _analysisPathStrokeWidth = this._analysisPath.attr("stroke-width").replace('px', '');
                var _qPointStrokeWidth = this._qPoint.attr("stroke-width").replace('px', '');
                var _aPointStrokeWidth = this._aPoint.attr("stroke-width").replace('px', '');
                var _bPointStrokeWidth = this._bPoint.attr("stroke-width").replace('px', '');
                this._abPath.attr({
                    strokeWidth: _abpathStrokeWidth * ratio
                });

                this._footPoint.attr({
                    strokeWidth: _footPointStrokeWidth * ratio
                });
                this._qPath.attr({
                    strokeWidth: _qPathStrokeWidth * ratio
                });
                this._analysisPath.attr({
                    strokeWidth: _analysisPathStrokeWidth * ratio
                });
                this._qPoint.attr({
                    strokeWidth: _qPointStrokeWidth * ratio
                });
                this._qPoint.selectAll('circle')[0].attr({
                    r: this._qPointRadius
                });
                this._qPoint.selectAll('circle')[1].attr({
                    r: this._qSmallPointRadius
                });
                this._qPoint.select('image').attr({
                    transform: 'translate(' + this._qTransformX + ',' + this._qTransformY + ')',
                    width: this.qImageWidth,
                    height: this.qImageHeight
                });
                this._aPoint.attr({ strokeWidth: _aPointStrokeWidth * ratio, r: this._abPointRadius });
                this._bPoint.attr({ strokeWidth: _bPointStrokeWidth * ratio, r: this._abPointRadius });
                if (helper.model.initRatio !== helper.model.ratio) {
                    ratio = 1;
                }
                //受力箭头
                var arrow = this._forceArrowGroup.select('g.arrow').select('path');
                arrow.attr({
                    d: 'M ' + ' ' + 48.33 * ratio + ' ' + 0.00 * ratio + ' ' + 'L ' + ' ' + 48.71 * ratio + ' ' + 0.00 * ratio + ' ' + 'C' + ' ' + 51.32 * ratio + ' ' + 4.14 * ratio + ' ' + 56.24 * ratio + ' ' + 5.49 * ratio + ' ' + 60.35 * ratio + ' ' + 7.61 * ratio + ' ' + 'C' + ' ' + 69.05 * ratio + ' ' + 10.50 * ratio + ' ' + 78.02 * ratio + ' ' + 12.58 * ratio + ' ' + 86.71 * ratio + ' ' + 15.53 * ratio + ' ' + 'C' + ' ' + 86.76 * ratio + ' ' + 15.77 * ratio + ' ' + 86.88 * ratio + ' ' + 16.24 * ratio + ' ' + 86.94 * ratio + ' ' + 16.48 * ratio + ' ' + 'C' + ' ' + 76.28 * ratio + ' ' + 19.92 * ratio + ' ' + 65.18 * ratio + ' ' + 22.20 * ratio + ' ' + 55.00 * ratio + ' ' + 27.00 * ratio + ' ' + 'C' + ' ' + 52.56 * ratio + ' ' + 28.29 * ratio + ' ' + 49.90 * ratio + ' ' + 29.57 * ratio + ' ' + 48.39 * ratio + ' ' + 32.00 * ratio + ' ' + 'L' + ' ' + 48.34 * ratio + ' ' + 32.00 * ratio + ' ' + 'C' + ' ' + 47.89 * ratio + ' ' + 26.55 * ratio + ' ' + 51.76 * ratio + ' ' + 22.10 * ratio + ' ' + 54.80 * ratio + ' ' + 18.00 * ratio + ' ' + 'C' + ' ' + 36.54 * ratio + ' ' + 17.99 * ratio + ' ' + 18.27 * ratio + ' ' + 18.00 * ratio + ' ' + 0.00 * ratio + ' ' + 18.00 * ratio + ' ' + 'L' + ' ' + 0.00 * ratio + ' ' + 14.00 * ratio + ' ' + 'C' + ' ' + 18.24 * ratio + ' ' + 14.00 * ratio + ' ' + 36.49 * ratio + ' ' + 14.00 * ratio + ' ' + 54.73 * ratio + ' ' + 14.00 * ratio + ' ' + 'C' + ' ' + 51.72 * ratio + ' ' + 9.88 * ratio + ' ' + 47.76 * ratio + ' ' + 5.48 * ratio + ' ' + 48.33 * ratio + ' ' + 0.00 * ratio + ' ' + 'Z'
                });
                this._forceArrowGroup.select('g.arrow').attr({
                    transform: 'translate(' + 0 + ',' + -forceArrowGroupHeight / 2 + ')'
                });
            }
        },
        /**
         * 初始化
         */
        init: function init(opt) {
            opt = opt || {};
            this._aPos = {
                x: Number(this._aPos.x.toFixed(5)),
                y: Number(this._aPos.y.toFixed(5))
            };
            this._bPos = {
                x: Number(this._bPos.x.toFixed(5)),
                y: Number(this._bPos.y.toFixed(5))
            };
            this._qPos = {
                x: Number(this._qPos.x.toFixed(5)),
                y: Number(this._qPos.y.toFixed(5))
            };
            //ab路径
            var abPathPoints = this._context.getLinePoints(this._aPos, this._bPos);
            this._abPath.attr({
                points: abPathPoints.join(',')
            });

            //Q路径
            var qBezierPoints = this._context.getQBezierPoints(this._aPos, this._qPos);
            var qPathBezierPoints = [];
            for (var i = 0, iLen = qBezierPoints.length; i < iLen; i++) {
                qPathBezierPoints.push([qBezierPoints[i].x, qBezierPoints[i].y]);
            }
            this._qPath.attr({
                points: qPathBezierPoints.join(',')
            });

            //箭头
            this._initForceArrowGroup();

            //正负电荷初始化
            this._initPlusMinus(this._context._electricChargeCheck);

            //q点
            this._qPoint.attr({
                transform: 'translate(' + this._qPos.x + ',' + this._qPos.y + ')'
            });

            //a点
            if (this._aPos.x === this._qPos.x && this._aPos.y === this._qPos.y) {
                this._aPoint.attr({
                    cx: this._aPos.x,
                    cy: this._aPos.y,
                    opacity: 0.8,
                    stroke: '#fff'
                });
                this._bPoint.attr({
                    cx: this._bPos.x,
                    cy: this._bPos.y,
                    opacity: 0.8,
                    stroke: '#fff'
                });
            } else {
                this._aPoint.attr({
                    cx: this._aPos.x,
                    cy: this._aPos.y,
                    opacity: 1,
                    stroke: '#626f79'
                });
                this._bPoint.attr({
                    cx: this._bPos.x,
                    cy: this._bPos.y,
                    opacity: 1,
                    stroke: '#626f79'
                });
            }

            //b点
            if (this._bPos.x === this._qPos.x && this._bPos.y === this._qPos.y) {
                this._bPoint.attr({
                    cx: this._bPos.x,
                    cy: this._bPos.y,
                    opacity: 0.8
                });
            } else {
                this._bPoint.attr({
                    cx: this._bPos.x,
                    cy: this._bPos.y,
                    opacity: 1
                });
            }

            //初始化A字母位置
            this._initAText();
            //初始化B字母的位置
            this._initBText();
            //初始化B(M)字母的位置
            this._initBMTextPos();
            //初始化A(M)字母的位置
            this._initAMTextPos();

            this._stopAPointAnimation();
            this._qState && this._startQPointAnimation();
            this._unbindEvent();
            this._bindEvent();
        },

        /**
         * 对路径进行微分
         */
        segmentation: function segmentation() {},
        _bindEvent: function _bindEvent() {
            var _this = this;

            var helper = this._helper;
            //a点的拖拽
            this._aPoint.drag(function (dx, dy, x, y, event) {
                if (!_this._aPointDowned) {
                    return;
                }
                _this._moveA(dx, dy, x, y, event);
            }, function (x, y, event) {
                _this._aPointDowned = true;
                if (_this._aState) {
                    _this._aPoint.attr({
                        fill: '#00dfe7',
                        stroke: '#fff',
                        strokeWidth: 3
                    });
                }
            }, function (event) {
                _this._aPointDowned = false;
                if (_this._aState) {
                    _this._aPoint.attr({
                        fill: '#06aac3',
                        stroke: '#fff',
                        strokeWidth: 1
                    });
                }
            });
            //b点的拖拽
            this._bPoint.drag(function (dx, dy, x, y, event) {
                if (!_this._bPointDowned) {
                    return;
                }
                _this._moveB(dx, dy, x, y, event);
            }, function (x, y, event) {
                _this._bPointDowned = true;
                if (_this._bState) {
                    _this._bPoint.attr({
                        fill: '#00dfe7',
                        stroke: '#fff',
                        strokeWidth: 3
                    });
                }
            }, function (event) {
                _this._bPointDowned = false;
                if (_this._bState) {
                    _this._bPoint.attr({
                        fill: '#06aac3',
                        stroke: '#fff',
                        strokeWidth: 1
                    });
                }
            });
            //q点的拖拽
            this._qPoint.drag(function (dx, dy, x, y, event) {
                _this._moveQ(dx, dy, x, y, event);
            }, function (x, y, event) {
                //按下Q点时，获取线上的所有贝塞尔曲线点
                _this._bezierPoints = _this._context.getBezierPoints(_this._aPos, _this._bPos);
            }, function (event) {});
            this._svg.mouseup(function () {
                _this._aPointDowned = false;
                _this._bPointDowned = false;
                if (_this._aState) {
                    _this._aPoint.attr({
                        fill: '#06aac3',
                        stroke: '#fff',
                        strokeWidth: 1
                    });
                }
                if (_this._bState) {
                    _this._bPoint.attr({
                        fill: '#06aac3',
                        stroke: '#fff',
                        strokeWidth: 1
                    });
                }
            });
            // this._svg.node.addEventListener('mouseleave', (e) => {
            //     this._aPointDowned = false;
            //     this._bPointDowned = false;
            //     if (this._aState) {
            //         this._aPoint.attr({
            //             fill: '#06aac3',
            //             stroke: '#fff',
            //             strokeWidth: 1
            //         });
            //     }
            //     if (this._bState) {
            //         this._bPoint.attr({
            //             fill: '#06aac3',
            //             stroke: '#fff',
            //             strokeWidth: 1
            //         });
            //     }
            // });
            //监听切换正负电荷
            this._onChangePlusMinusElectricChargeEventToken = helper.publishSubscribe.subscribe(helper.publishSubscribe._topicName.OnChangePlusMinusElectricChargeEvent, function (topic, args) {
                _this._initPlusMinus(args.electricChargeCheck);
            });
        },
        _unbindEvent: function _unbindEvent() {
            var helper = this._helper;
            this._aPoint && this._aPoint.undrag();
            this._bPoint && this._bPoint.undrag();
            this._qPoint && this._qPoint.undrag();
            this._onChangePlusMinusElectricChargeEventToken != undefined && helper.publishSubscribe.remove(helper.publishSubscribe._topicName.OnChangePlusMinusElectricChargeEvent, this._onChangePlusMinusElectricChargeEventToken);
        },
        /**
         * 初始化字母A、B、M位置
         */
        _initLettersPosition: function _initLettersPosition() {

            this._bText.attr({
                transform: 'translate(' + this._bPos.x + ',' + this._bPos.y + ')'
            });
            if (this._context._viewAnalysisCheck) {
                var breakPoint = this._context._breakPoint(this._context._electricField._rotateAngle, this._aPos, this._aPos);
                this._mText.removeClass('hide_dom').attr({
                    transform: 'translate(' + breakPoint.x + ',' + breakPoint.y + ')'
                });
            }
        },
        /**
         * 初始化A字母位置
         * @private
         */
        _initAText: function _initAText() {
            var aPos = this._aPos;
            var bPos = this._bPos;
            var aTextPos = { x: 0, y: 0 };
            //调整横坐标
            if (aPos.x <= this._bound.left + this._qPointRadius + this._aText.node.getBoundingClientRect().width) {
                // a在最左边
                aTextPos = {
                    x: aPos.x + this._qPointRadius,
                    y: aPos.y + this._aText.node.getBoundingClientRect().height / 2
                };
            } else {
                //点如果在左边字母就显示左边，在右边就显示在右边
                if (aPos.x <= bPos.x) {
                    aTextPos = {
                        x: aPos.x - this._qPointRadius - this._aText.node.getBoundingClientRect().width,
                        y: aPos.y + this._aText.node.getBoundingClientRect().height / 2
                    };
                } else {
                    aTextPos = {
                        x: aPos.x + this._aText.node.getBoundingClientRect().width,
                        y: aPos.y + this._aText.node.getBoundingClientRect().height / 2
                    };
                }
            }
            //调整纵坐标
            if (aTextPos.y >= this._bound.bottom) {
                aTextPos.y = this._bound.bottom;
            }

            if (this._aPos.x === this._qPos.x && this._aPos.y === this._qPos.y) {
                this._aText.attr({
                    transform: 'translate(' + aTextPos.x + ',' + aTextPos.y + ')',
                    fill: '#333'
                });
            } else {
                this._aText.attr({
                    transform: 'translate(' + aTextPos.x + ',' + aTextPos.y + ')',
                    fill: '#626f79'
                });
            }
        },
        /**
         * 初始化B字母位置
         * @private
         */
        _initBText: function _initBText() {
            var aPos = this._aPos;
            var bPos = this._bPos;
            var bTextPos = { x: 0, y: 0 };
            //调整横坐标
            if (bPos.x >= this._bound.right - this._qPointRadius) {
                // b在最右边
                bTextPos = {
                    x: bPos.x - this._qPointRadius - this._bText.node.getBoundingClientRect().width / 2,
                    y: bPos.y + this._bText.node.getBoundingClientRect().height / 2
                };
            } else {
                //点如果在左边字母就显示左边，在右边就显示在右边
                if (aPos.x <= bPos.x) {
                    bTextPos = {
                        x: bPos.x + this._bText.node.getBoundingClientRect().width,
                        y: bPos.y + this._bText.node.getBoundingClientRect().height / 2
                    };
                } else {
                    bTextPos = {
                        x: bPos.x - this._qPointRadius - this._bText.node.getBoundingClientRect().width,
                        y: bPos.y + this._bText.node.getBoundingClientRect().height / 2
                    };
                }
            }

            //调整纵坐标
            if (bTextPos.y >= this._bound.bottom) {
                bTextPos.y = this._bound.bottom;
            }

            if (this._aPos.x === this._qPos.x && this._aPos.y === this._qPos.y) {
                this._bText.attr({
                    transform: 'translate(' + bTextPos.x + ',' + bTextPos.y + ')',
                    fill: '#333'
                });
            } else {
                this._bText.attr({
                    transform: 'translate(' + bTextPos.x + ',' + bTextPos.y + ')',
                    fill: '#626f79'
                });
            }
        },
        /**
         * 初始化B(M)字母位置
         * @private
         */
        _initBMTextPos: function _initBMTextPos() {
            var bPos = this._bPos;
            //调整横坐标
            if (bPos.x >= this._bound.right - this._qPointRadius) {
                // b在最右边
                this._bmTextPos = {
                    x: bPos.x - this._qPointRadius - this._bText.node.getBoundingClientRect().width / 2,
                    y: bPos.y + this._bText.node.getBoundingClientRect().height / 2
                };
            } else {
                this._bmTextPos = {
                    x: bPos.x + this._bText.node.getBoundingClientRect().width,
                    y: bPos.y + this._bText.node.getBoundingClientRect().height / 2
                };
            }

            this._bmTextGroup.attr({
                transform: 'translate(' + this._bmTextPos.x + ',' + this._bmTextPos.y + ')'
            });
        },
        /**
         * 初始化A(M)字母位置
         * @private
         */
        _initAMTextPos: function _initAMTextPos() {
            var aPos = this._aPos;
            //调整横坐标
            if (aPos.x >= this._bound.right - this._qPointRadius) {
                // b在最右边
                this._amTextPos = {
                    x: aPos.x - this._qPointRadius - this._aText.node.getBoundingClientRect().width / 2,
                    y: aPos.y + this._aText.node.getBoundingClientRect().height / 2
                };
            } else {
                this._amTextPos = {
                    x: aPos.x + this._aText.node.getBoundingClientRect().width,
                    y: aPos.y + this._aText.node.getBoundingClientRect().height / 2
                };
            }

            this._amTextGroup.attr({
                transform: 'translate(' + this._amTextPos.x + ',' + this._amTextPos.y + ')'
            });
        },
        /**
         * 初始化受力方向
         * @private
         */
        _initForceArrowGroup: function _initForceArrowGroup() {
            if (this._context._forceDirectionCheck) {
                // 受力方向
                this._forceArrowGroup.removeClass('hide_dom');
            } else {
                this._forceArrowGroup.addClass('hide_dom');
                return;
            }
            var rotateAngle = this._context._electricField._rotateAngle;
            var qPos = this._qPos;
            var arrowGroup = this._forceArrowGroup.select('g.arrow');
            var fText = this._forceArrowGroup.select('text.fText');

            var fTextX = arrowGroup.node.getBoundingClientRect().width - fText.node.getBoundingClientRect().width;
            var fTextY = fText.node.getBoundingClientRect().height;
            if (!this._context._electricChargeCheck) {
                // 负电荷
                rotateAngle = rotateAngle + 180;
                fTextX = fText.node.getBoundingClientRect().width;
                fTextY = fText.node.getBoundingClientRect().height;
            } else {
                fTextX = fText.node.getBoundingClientRect().width;
                fTextY = fText.node.getBoundingClientRect().height;
            }

            this._forceArrowGroup.attr({
                transform: 'translate(' + qPos.x + ',' + qPos.y + ') rotate(' + rotateAngle + ',0,0)'
            });

            // fText.attr({
            //     style:`font:italic 2.66667em "Times New Roman";
            //     -webkit-transform-origin:50% 50%;
            //     -webkit-transform:translate(80px,20px) rotate(${-rotateAngle}deg);
            //     -ms-transform-origin:50% 50%;
            //     -ms-transform:translate(80px,20px) rotate(${-rotateAngle}deg);
            //     -o-transform-origin:50% 50%;
            //     -o-transform:translate(80px,20px) rotate(${-rotateAngle}deg);
            //     transform-origin:50% 50%;
            //     transform:translate(80px,20px) rotate(${-rotateAngle}deg)`
            // });

            fText.attr({
                transform: 'translate(' + fTextX + ',' + fTextY + ') rotate(' + -rotateAngle + ',' + fText.node.getBoundingClientRect().width / 3 + ',' + -fText.node.getBoundingClientRect().height / 3 + ')'
            });

            // if (rotateAngle === this._context._electricField._rotateAngle) {
            //     fText.attr({
            //         transform: `translate(${fTextX},${fTextY}) rotate(${-rotateAngle},0,0)`
            //     });
            // } else {
            //     fText.attr({
            //         transform: `translate(${fTextX},${fTextY}) rotate(${-rotateAngle},0,0)`
            //     });
            // }
        },
        /**
         * 正负电荷状态初始化
         * @param electricChargeCheck
         * @private
         */
        _initPlusMinus: function _initPlusMinus(electricChargeCheck) {
            var plusMinus = electricChargeCheck ? this._qPointPlusMinus.plus : this._qPointPlusMinus.minus;
            this._qPoint.select('circle.qPointMainCircle').attr({
                fill: plusMinus.fill,
                filter: plusMinus.filter,
                stroke: plusMinus.stroke
            });
            this._qPoint.select('image.qPointImage').attr({
                href: plusMinus.image
            });
        },
        /**
         * 移动A点
         */
        _moveA: function _moveA(dx, dy, x, y, event) {
            if (!this._aState) {
                return;
            }

            var helper = this._helper;
            var newX = x - this._svg.node.getBoundingClientRect().left;
            var newY = y - this._svg.node.getBoundingClientRect().top;
            var abDis = this._get2PointDistance({ x: newX, y: newY }, this._bPos);
            if (abDis < 4 * this._qPointRadius) {
                return;
            }
            //自动吸附
            if (Math.abs(newX - this._bPos.x) < 10) {
                newX = this._bPos.x;
            }
            if (Math.abs(newY - this._bPos.y) < 10) {
                newY = this._bPos.y;
            }
            //超出边界
            var leftDiff = this._context._bgSvg.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
            var rightDiff = this._svg.node.getBoundingClientRect().width - this._context._bgSvg.node.getBoundingClientRect().width - leftDiff;
            var topDiff = this._context._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top;
            var bottomDiff = this._svg.node.getBoundingClientRect().height - this._context._bgSvg.node.getBoundingClientRect().height - topDiff;
            if (newX < this._bound.left + this._forceArrowGroup.node.getBoundingClientRect().width - leftDiff || newX > this._bound.right - this._forceArrowGroup.node.getBoundingClientRect().width + rightDiff || newY < this._bound.top + topDiff || newY > this._bound.bottom - bottomDiff) {
                return;
            }
            newX = Number(newX.toFixed(5));
            newY = Number(newY.toFixed(5));
            this._aPoint.attr({
                cx: newX,
                cy: newY
            });
            this._aPos = { x: newX, y: newY };
            var points = this._context.getLinePoints(this._aPos, this._bPos);
            this._abPath.attr({
                points: points.join(',')
            });

            //同步移动Q
            this._qPos = {
                x: newX,
                y: newY
            };
            this._qPoint.attr({
                transform: 'translate(' + this._qPos.x + ',' + this._qPos.y + ')'
            });

            //移动字母A
            this._initAText();
            //移动字母A
            this._initBText();
            //移动A(M)字母的位置
            this._initAMTextPos();

            //同步移动受力方向箭头
            this._initForceArrowGroup();
            // let rotateAngle = this._context._electricChargeCheck ? this._context._electricField._rotateAngle : this._context._electricField._rotateAngle + 180;
            // this._forceArrowGroup.attr({
            //     transform: `translate(${this._aPos.x},${this._aPos.y}) rotate(${rotateAngle},0,0)`
            // });
            this._context.moveA();
        },
        /**
         * 移动B点
         */
        _moveB: function _moveB(dx, dy, x, y, event) {
            if (!this._bState) {
                return;
            }
            var helper = this._helper;
            var newX = x - this._svg.node.getBoundingClientRect().left;
            var newY = y - this._svg.node.getBoundingClientRect().top;
            var abDis = this._get2PointDistance(this._aPos, { x: newX, y: newY });
            if (abDis < 4 * this._qPointRadius) {
                return;
            }
            //自动吸附
            if (Math.abs(newX - this._aPos.x) < 10) {
                newX = this._aPos.x;
            }
            if (Math.abs(newY - this._aPos.y) < 10) {
                newY = this._aPos.y;
            }
            //超出边界
            var leftDiff = this._context._bgSvg.node.getBoundingClientRect().left - this._svg.node.getBoundingClientRect().left;
            var rightDiff = this._svg.node.getBoundingClientRect().width - this._context._bgSvg.node.getBoundingClientRect().width - leftDiff;
            var topDiff = this._context._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top;
            var bottomDiff = this._svg.node.getBoundingClientRect().height - this._context._bgSvg.node.getBoundingClientRect().height - topDiff;
            if (newX < this._bound.left + this._forceArrowGroup.node.getBoundingClientRect().width - leftDiff || newX > this._bound.right - this._forceArrowGroup.node.getBoundingClientRect().width + rightDiff || newY < this._bound.top + topDiff || newY > this._bound.bottom - bottomDiff) {
                return;
            }
            newX = Number(newX.toFixed(5));
            newY = Number(newY.toFixed(5));
            this._bPoint.attr({
                cx: newX,
                cy: newY
            });
            this._bPos = { x: newX, y: newY };
            var points = this._context.getLinePoints(this._aPos, this._bPos);
            this._abPath.attr({
                points: points.join(',')
            });
            //移动字母A
            this._initAText();
            //移动字母B
            this._initBText();
            //移动B(M)字母的位置
            this._initBMTextPos();

            this._context.moveB();
        },
        /**
         * 移动Q点
         */
        _moveQ: function _moveQ(dx, dy, x, y, event) {
            var helper = this._helper;
            this._aState = false;
            this._bState = false;
            var point = void 0;
            if (this._bezierPoints[0] !== undefined) {
                point = {
                    x: this._bezierPoints[0].x,
                    y: this._bezierPoints[0].y
                };
            }

            var curMovePos = {
                x: x - this._svg.node.getBoundingClientRect().left,
                y: y - this._svg.node.getBoundingClientRect().top
            };
            var distance = void 0;
            var bezierPoints = [];
            for (var i = 0, iLen = this._bezierPoints.length; i < iLen; i++) {
                bezierPoints.push([this._bezierPoints[i].x, this._bezierPoints[i].y]);
                var dis = this._get2PointDistance(curMovePos, this._bezierPoints[i]);
                distance === undefined && (distance = dis);
                if (dis <= distance) {
                    distance = dis;
                    point = this._bezierPoints[i];
                }
            }
            point === undefined && (point = curMovePos);
            //超出边界
            if (point.x < this._bound.left || point.x > this._bound.right || point.y < this._bound.top || point.y > this._bound.bottom) {
                return;
            }
            this._qPos = point;
            //如果距离小于qb之间的半径自动吸附
            var qbDis = this._get2PointDistance(this._qPos, this._bPos);
            if (qbDis <= this._qSmallPointRadius + this._abPointRadius) {
                this._qPos = this._bPos;
                this._qState = false;
                this._stopAPointAnimation();
                this._bPoint.attr({
                    opacity: 0.8
                });
                //Q点进入B点的事件
                helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnQPointEnterBPointEvent, {
                    source: this.sceneName
                });
            } else {
                !this._qState && this._startQPointAnimation();
                this._qState = true;
                //分析路径要隐藏
                this._context.removeAnalysisPath();
                this._bPoint.attr({
                    opacity: 1
                });
                //Q点不在B点的事件
                helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnQPointLeaveBPointEvent, {
                    source: this.sceneName
                });
            }
            //如果距离小球aq自动吸附,并且ab可以拖动
            var aqDis = this._get2PointDistance(this._aPos, this._qPos);
            if (aqDis <= this._qSmallPointRadius + this._abPointRadius) {
                this._qPos = this._aPos;
                this._aState = true;
                this._bState = true;
                this._aText.attr({
                    fill: '#333'
                });
                this._bText.attr({
                    fill: '#333'
                });

                this._aPoint.attr({
                    stroke: '#fff',
                    opacity: 0.8
                });
                this._bPoint.attr({
                    stroke: '#fff'
                });
            } else {
                this._aText.attr({
                    fill: '#626f79'
                });
                this._bText.attr({
                    fill: '#626f79'
                });

                this._aPoint.attr({
                    stroke: '#626f79',
                    opacity: 1
                });
                this._bPoint.attr({
                    stroke: '#626f79'
                });
            }
            //移动Q
            this._qPoint.attr({
                transform: 'translate(' + this._qPos.x + ',' + this._qPos.y + ')'
            });
            //同步移动受力方向箭头
            this._initForceArrowGroup();
            // let rotateAngle = this._context._electricChargeCheck ? this._context._electricField._rotateAngle : this._context._electricField._rotateAngle + 180;
            // this._forceArrowGroup.attr({
            //     transform: `translate(${this._qPos.x},${this._qPos.y}) rotate(${rotateAngle},0,0)`
            // });

            var qPoints = this._context.getQBezierPoints(this._aPos, this._qPos);
            var qPathBezierPoints = [];
            for (var _i = 0, _iLen = qPoints.length; _i < _iLen; _i++) {
                qPathBezierPoints.push([qPoints[_i].x, qPoints[_i].y]);
            }
            this._qPath.attr({ points: qPathBezierPoints });
            this._context.moveQ();
        },
        _startQPointAnimation: function _startQPointAnimation() {
            var _this2 = this;

            this._qPoint.select('circle.qPointAnimationCircle').removeClass('hide_dom');
            this._qPointAnimation = Snap.animate([this.qImageHeight, 1], [this.qImageWidth, 0], function (val) {
                _this2._qPoint.select('circle:first-child').attr({
                    r: val[0],
                    opacity: val[1]
                });
            }, 1500, mina.linear, function () {
                if (_this2._qState) {
                    _this2._startQPointAnimation();
                }
            });
        },
        _stopAPointAnimation: function _stopAPointAnimation() {
            if (this._qPointAnimation) {
                this._qPointAnimation.stop();
                this._qPoint.select('circle.qPointAnimationCircle').addClass('hide_dom');
            }
        },
        /**
         * 求两点间的距离
         * @param start
         * @param end
         * @return {number}
         * @private
         */
        _get2PointDistance: function _get2PointDistance(start, end) {
            return Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2));
        }
    });
    return ChargeTrajectory;
});
'use strict';

/**
 * CurveLine 沿曲线预设
 */
define('CurveLine', ['BaseView'], function (BaseView) {
    var CurveLine = BaseView.extend({
        $init: function $init(helper, opt) {
            opt = $.extend({
                name: helper.sceneName.CURVE_LINE,
                svgContainer: helper.domObj.$curveLineContainer,
                bgSvgContainer: helper.domObj.$curveLineBgContainer
            }, opt);
            this._super(helper, opt);
            this._helper = helper;
        },
        init: function init(opt) {
            this._super(opt);
        },
        resizeScreen: function resizeScreen() {
            console.log('曲线');
            if (this._svg !== null) {
                this.removeAnalysisPath();
            }
            this._super();
        },
        getCurrentExpressionDom: function getCurrentExpressionDom() {
            var helper = this._helper;
            return helper.domObj.$curveLineExpression;
        },
        getExpressionsDom: function getExpressionsDom() {
            var helper = this._helper;
            return [helper.domObj.$curveLineExpression];
        },
        removeAnalysisPath: function removeAnalysisPath() {
            this._super();
            //this._chargeTrajectory._segmentationGroup.select('polyline') && this._chargeTrajectory._segmentationGroup.select('polyline').remove();
            $(this._chargeTrajectory._segmentationGroup.node).find('polyline').remove();
            //该方法无法删除，用jquery删除
            // this._chargeTrajectory._segmentationGroup.select('text') && this._chargeTrajectory._segmentationGroup.select('text').remove();
            $('text.segText').remove();
        },
        segmentation: function segmentation() {
            var points = [];
            var num = 1,
                preIndex = 0,
                nextIndex = 1;
            for (var i = 0; i < 5; i++) {
                var prePos = { x: this._linePoints[20 * preIndex][0], y: this._linePoints[20 * preIndex][1] };
                var nextPos = { x: this._linePoints[20 * nextIndex][0], y: this._linePoints[20 * nextIndex][1] };
                var breakPoint = this._breakPoint(this._electricField._rotateAngle, prePos, nextPos);

                var segText = this._svg.paper.text(0, 0, 'd' + num).attr({
                    class: 'segText',
                    style: 'font:italic 2.66667em "Times New Roman"'
                });
                var dis = this.get2PointDistance(prePos, breakPoint);
                if (dis < segText.node.getBoundingClientRect().width) {
                    segText.remove();
                    nextIndex++;
                    continue;
                } else {
                    segText.attr({
                        transform: 'translate(' + ((prePos.x + breakPoint.x) / 2 - segText.node.getBoundingClientRect().width / 2) + ',' + ((prePos.y + breakPoint.y) / 2 + segText.node.getBoundingClientRect().height) + ')'
                    });
                    this._chargeTrajectory._segmentationGroup.add(segText);
                    preIndex = nextIndex++;
                    num++;
                }
                points.push([prePos.x, prePos.y]);
                points.push([breakPoint.x, breakPoint.y]);
                points.push([nextPos.x, nextPos.y]);
            }
            this._chargeTrajectory._segmentationGroup.add(this._svg.paper.polyline().attr({
                points: points.join(','),
                stroke: '#000',
                strokeWidth: 3,
                fill: 'none'
            }));
        },
        getLinePoints: function getLinePoints(a, b) {
            this._linePoints = [];
            var cp = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
            var abHalfDis = this.get2PointDistance(a, b) / 2;
            //斜率
            var k = null;
            if (a.x !== b.x) {
                k = -(b.y - a.y) / (b.x - a.x);
            }
            var ctrl = void 0;
            if (k === null) {
                ctrl = { x: cp.x - abHalfDis, y: cp.y };
                console.log('k===null');
            } else {
                var sin = Math.sin(Math.atan(k));
                var cos = Math.cos(Math.atan(k));
                ctrl = { x: abHalfDis * cos, y: abHalfDis * sin };

                //y-y1=k(x-x1)
                //垂线：y-cp.y = k * (x-cp.x) => y= k * (x-cp.x) + cp.y
                //ad的斜率：Math.tan(Math.atan(k) - 45 * Math.PI / 180)
                // k * (x-cp.x) + cp.y = adk * (x-a.x) + a.y
                //k * x - k* cp.x + cp.y = adk * x - adk * a.x + a.y
                //k * x - adk * x = k* cp.x - cp.y - adk * a.x + a.y
                //(k-adk)*x = (k* cp.x - cp.y - adk*a.x + a.y)
                //x = (k* cp.x - cp.y - adk*a.x + a.y)/(k-adk)

                // if (Number(k.toFixed(5)) === 1 || Number(k.toFixed(5)) === -1) {
                //     ctrl = {x: a.x, y: b.y};
                //     console.log('垂直了')
                // } else {
                //     let adk = Math.tan(Math.atan(k) + 45 * Math.PI / 180);
                //     let x = (k * cp.x - cp.y - adk * a.x + a.y) / (k - adk);
                //     let y = k * (x - cp.x) + cp.y
                //     ctrl = {x: x, y: y};
                //     console.log('ctrl:',ctrl);
                // }
            }
            for (var i = 0; i <= 100; i++) {
                var point = this.get2Bezier(a, ctrl, b, i / 100);
                this._linePoints.push([point.x, point.y]);
            }
            return this._linePoints;
        },
        getBezierPoints: function getBezierPoints(start, end) {
            var points = [];
            for (var i = 0, iLen = this._linePoints.length; i < iLen; i++) {
                points.push({ x: this._linePoints[i][0], y: this._linePoints[i][1] });
                if (parseInt(this._linePoints[i][0]) === parseInt(end.x) && parseInt(this._linePoints[i][1]) === parseInt(end.y)) {
                    break;
                }
            }
            return points;
        }
    });
    return CurveLine;
});
'use strict';

/**
 * CustomLine 自定义路径预设
 */
define('CustomLine', ['BaseView'], function (BaseView) {
    var CustomLine = BaseView.extend({
        $init: function $init(helper, opt) {
            opt = $.extend({
                name: helper.sceneName.CUSTOM_LINE,
                svgContainer: helper.domObj.$customLineContainer,
                bgSvgContainer: helper.domObj.$customLineBgContainer
            }, opt);
            this._super(helper, opt);
            this._helper = helper;
        },
        init: function init(opt) {
            this._super(opt);
        },
        resizeScreen: function resizeScreen() {
            console.log('自定义线段');
            this._super();
        },
        moveQ: function moveQ() {
            // this._super();
            var helper = this._helper;
            //电势能变化和静电力做功变化
            this.barChange();
            //自定义路径只要移出A点后，A、B两点就不能再移动
            this._chargeTrajectory._aState = false;
            this._chargeTrajectory._bState = false;

            this._chargeTrajectory._aPoint.attr({
                stroke: '#626f79'
            });
            this._chargeTrajectory._bPoint.attr({
                stroke: '#626f79'
            });
            this._chargeTrajectory._aText.attr({
                fill: '#626f79'
            });
            this._chargeTrajectory._bText.attr({
                fill: '#626f79'
            });

            helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnQPointMoveEvent, {
                source: this.name
            });
            this._electricField._rotateState = false;
            this._electricField._rotateButton.attr({
                href: this._electricField._bgImg.disable
            });
        },
        getCurrentExpressionDom: function getCurrentExpressionDom() {
            var helper = this._helper;
            return helper.domObj.$customLineExpression;
        },
        getExpressionsDom: function getExpressionsDom() {
            var helper = this._helper;
            return [helper.domObj.$customLineExpression];
        },
        getLinePoints: function getLinePoints(a, b) {
            this._a = a;
            this._b = b;
            return [];
        },
        getBezierPoints: function getBezierPoints(start, end) {
            return [];
        },
        getQBezierPoints: function getQBezierPoints(start, end) {
            this._qBezierPoints.length === 0 && this._qBezierPoints.push(start);
            this._qBezierPoints.push(end);
            return this._qBezierPoints;
        }
    });
    return CustomLine;
});
'use strict';

/**
 * ElectricField 电场类
 */
define('ElectricField', function () {
    var ElectricField = Class.extend({
        $init: function $init(helper, opt) {
            this._helper = helper;
            this.sceneName = opt.sceneName;
            this._context = opt.context;
            //svg容器,Snap对象
            this._svg = opt.svg;
            this._bgSvg = opt.bgSvg;
            //旋转状态，是否可旋转电场，true为可旋转,false为不可旋转
            this._rotateState = opt.rotateState === undefined ? true : opt.rotateState;
            this._bgImg = {
                normal: helper.basePath + 'resources/wood/images/rotate_com.png',
                active: helper.basePath + 'resources/wood/images/rotate_active.png',
                disable: helper.basePath + 'resources/wood/images/rotate_disabled.png'
            };
            var ratio = helper.model.ratio;
            if (helper.model.initRatio == ratio) {
                this.lineStrokeWidth = 3 * helper.model.ratio;
                this.d = ' M ' + ' ' + 0.45 * ratio + ' ' + 1.35 * ratio + 'C' + 3.92 * ratio + ' ' + 3.36 * ratio + ' ' + 7.39 * ratio + ' ' + 5.48 * ratio + ' ' + 11.25 * ratio + ' ' + 6.69 * ratio + ' ' + 'C' + ' ' + 16.88 * ratio + ' ' + 8.74 * ratio + ' ' + 22.95 * ratio + ' ' + 9.56 * ratio + ' ' + 28.27 * ratio + ' ' + 12.41 * ratio + ' ' + 'C' + ' ' + 24.13 * ratio + ' ' + 13.82 * ratio + ' ' + 19.93 * ratio + ' ' + 15.02 * ratio + ' ' + 15.66 * ratio + ' ' + 15.95 * ratio + ' ' + 'C' + ' ' + 10.20 * ratio + ' ' + 17.85 * ratio + ' ' + 4.95 * ratio + ' ' + 20.32 * ratio + ' ' + 0.00 * ratio + ' ' + 23.30 * ratio + ' ' + 'L' + ' ' + 0.00 * ratio + ' ' + 22.81 * ratio + ' ' + 'C ' + ' ' + 1.65 * ratio + ' ' + 19.54 * ratio + ' ' + 3.61 * ratio + ' ' + 16.42 * ratio + ' ' + 5.05 * ratio + ' ' + 13.06 * ratio + ' ' + 'C' + ' ' + 5.23 * ratio + ' ' + 8.70 * ratio + ' ' + 1.06 * ratio + ' ' + 5.63 * ratio + ' ' + 0.45 * ratio + ' ' + 1.35 * ratio + ' ' + 'Z';
                this.rotateImageWidth = 40 * ratio;
                this._rotateButton = this._svg.paper.image(this._bgImg.normal, 0, 0, this.rotateImageWidth, this.rotateImageWidth);
                this.Two = 2 * ratio;
            } else {
                this.lineStrokeWidth = 3;
                this.d = ' M 0.45 1.35 C 3.92 3.36 7.39 5.48 11.25 6.69 C 16.88 8.74 22.95 9.56 28.27 12.41 C 24.13 13.82 19.93 15.02 15.66 15.95 C 10.20 17.85 4.95 20.32 0.00 23.30 L 0.00 22.81 C 1.65 19.54 3.61 16.42 5.05 13.06 C 5.23 8.70 1.06 5.63 0.45 1.35 Z';
                this.rotateImageWidth = 40;
                this._rotateButton = this._svg.paper.image(this._bgImg.normal, 0, 0, this.rotateImageWidth, this.rotateImageWidth);
                this.Two = 2;
            }
            // this._rotateButton = this._svg.paper.g().add(     this._svg.paper.path({         d: ' M 7.18 15.16 C 11.35 7.13 21.11
            // 2.66 29.91 4.77 C 38.75 6.60 45.83 14.88 45.75 23.99 C 46.16 34.32 37.23 43.67 26.99 44.15 C 19.16 44.90 11.44 40.64
            // 7.41 33.98 C 8.24 31.88 10.62 30.98 12.48 32.48 C 14.98 34.71 17.31 37.36 20.68 38.25 C 28.44 41.02 37.89 36.10 39.82
            // 28.04 C 42.17 20.33 36.78 11.64 28.99 9.94 C 22.17 8.10 14.80 11.86 11.58 18.00 C 13.63 17.62 15.73 15.58 17.85 16.81
            // C 19.21 17.78 19.40 20.15 17.81 20.99 C 15.52 22.41 12.89 23.16 10.56 24.53 C 9.18 25.21 7.38 26.53 5.96 25.14 C 4.00
            // 22.22 2.78 18.85 1.30 15.67 C 0.33 14.15 1.18 11.84 3.06 11.64 C 5.40 10.97 6.30 13.58 7.18 15.16 Z', fill: '#06aac3'
            //     }));
            var rotateButtonX = this._svg.node.getBoundingClientRect().width - this._rotateButton.node.getBoundingClientRect().width * 1.8;
            var rotateButtonY = this._bgSvg.node.getBoundingClientRect().top - this._svg.node.getBoundingClientRect().top + this._bgSvg.node.getBoundingClientRect().height - this._rotateButton.node.getBoundingClientRect().height / 2;
            this._rotateButtonPos = {
                x: rotateButtonX,
                y: rotateButtonY
            };
            this._rotateButton.attr({ x: this._rotateButtonPos.x, y: this._rotateButtonPos.y });
            //旋转角度
            this._rotateAngle = opt.rotateAngle || 360;
            this._rotatePoint = {
                x: this._bgSvg.node.getBoundingClientRect().width / 2,
                y: this._bgSvg.node.getBoundingClientRect().height / 2
            };

            //E字母
            this._eText = this._svg.paper.text(0, 0, 'E').attr({ fill: '#687177', style: 'font:italic 2.66667em "Times New Roman"' });
            var eTranslateX = this._svg.node.getBoundingClientRect().width - (this._svg.node.getBoundingClientRect().width - this._bgSvg.node.getBoundingClientRect().width);
            this._eText.attr({ transform: 'translate(' + eTranslateX + ',' + this._eText.node.getBoundingClientRect().height + ')' });
            //画箭头线
            this._drawLineArrow();
        },
        init: function init(opt) {
            opt = opt || {};
            //初始化旋转按钮
            if (this._rotateState) {
                this._rotateButton.attr({ href: this._bgImg.normal });
            } else {
                this._rotateButton.attr({ href: this._bgImg.disable });
            }
            //初始旋转度数
            this._linesGroup.attr({
                transform: 'translate(0,' + this._perRowHeight / 1.37 + ') rotate(' + this._rotateAngle + ',' + this._rotatePoint.x + ',' + this._rotatePoint.y + ')'
            });
            //移动箭头
            this._moveArrow();
            //移动字母E
            this._moveE();

            this._unbindEvent();
            this._bindEvent();
        },
        resizeScreen: function resizeScreen() {
            console.log('电场类');
            var helper = this._helper;
            var svgContainerWidth = helper.saveData.svgWidth;
            var svgContainerHeight = helper.saveData.svgHeight;
            var bgSvgContainerWidth = helper.saveData.svgbgWidth;
            var bgSvgContainerHeight = helper.saveData.svgbgHeight;
            var svgLeft = helper.saveData.svgLeft;
            var svgTop = helper.saveData.svgTop;
            var svgbgLeft = helper.saveData.svgbgLeft;
            var svgbgTop = helper.saveData.svgbgTop;
            this.rotateImageWidth = this.rotateImageWidth * helper.model.ratio;
            this._rotateButton.attr({ width: this.rotateImageWidth, height: this.rotateImageWidth });
            var rotateButtonX = svgContainerWidth - this.rotateImageWidth * 1.8;
            var rotateButtonY = svgbgTop - svgTop + bgSvgContainerHeight - this.rotateImageWidth / 2;
            this._rotateButtonPos = {
                x: rotateButtonX,
                y: rotateButtonY
            };
            this._rotateButton.attr({ x: this._rotateButtonPos.x, y: this._rotateButtonPos.y });
            //画箭头线
            this._reDrawLineArrow();
        },
        _bindEvent: function _bindEvent() {
            var _this = this;

            var helper = this._helper;
            this._rotateButton.drag(function (dx, dy, x, y, event) {
                if (!_this._rotateState) {
                    return;
                }
                _this._rotate(dx, dy, x, y, event);
            }, function (x, y, event) {
                if (!_this._rotateState) {
                    return;
                }
                _this._rotateButton.attr({ href: _this._bgImg.active });
            }, function (event) {
                if (!_this._rotateState) {
                    return;
                }
                _this._rotateButton.attr({ x: _this._rotateButtonPos.x, y: _this._rotateButtonPos.y, href: _this._bgImg.normal });
            });

            // helper.$view.on('mouseup', () => {     console.log('mouseup国');     if (!this._rotateState) {         return;     }
            // this._rotateButton.attr({         x: this._rotateButtonPos.x,         y: this._rotateButtonPos.y,         href:
            // this._bgImg.normal     }); }); 移动Q点
            this._onQPointMoveEventToken = helper.publishSubscribe.subscribe(helper.publishSubscribe._topicName.OnQPointMoveEvent, function (topic, args) {
                var aPos = _this._context._chargeTrajectory._aPos;
                var qPos = _this._context._chargeTrajectory._qPos;
                if (aPos.x === qPos.x && aPos.y === qPos.y) {
                    _this._rotateState = true;
                    _this._rotateButton.attr({ href: _this._bgImg.normal });
                } else {
                    _this._rotateState = false;
                    _this._rotateButton.attr({ href: _this._bgImg.disable });
                }
            });
        },
        _unbindEvent: function _unbindEvent() {
            var helper = this._helper;
            this._rotateButton && this._rotateButton.undrag();
            this._onQPointMoveEventToken != undefined && helper.publishSubscribe.remove(helper.publishSubscribe._topicName.OnQPointMoveEvent, this._onQPointMoveEventToken);
        },
        _rotate: function _rotate(dx, dy, x, y, event) {
            var helper = this._helper;
            if (x - helper.domObj.$paeShowInnerArea[0].getBoundingClientRect().left < 0 || x - helper.domObj.$paeShowInnerArea[0].getBoundingClientRect().left > helper.domObj.$paeShowInnerArea[0].getBoundingClientRect().width || y - helper.domObj.$paeShowInnerArea[0].getBoundingClientRect().top < 0 || y - helper.domObj.$paeShowInnerArea[0].getBoundingClientRect().top > helper.domObj.$paeShowInnerArea[0].getBoundingClientRect().height - this._rotateButton.node.getBoundingClientRect().height) {
                this._rotateButton.attr({ x: this._rotateButtonPos.x, y: this._rotateButtonPos.y, href: this._bgImg.normal });
                return;
            } else {
                this._rotateButton.attr({ href: this._bgImg.active });
            }
            var curMovePos = {
                x: x - this._svg.node.getBoundingClientRect().left - this._rotateButton.node.getBoundingClientRect().width / 2,
                y: y - this._svg.node.getBoundingClientRect().top - this._rotateButton.node.getBoundingClientRect().height / 2
            };

            var dis = this._context.get2PointDistance({
                x: curMovePos.x,
                y: curMovePos.y
            }, this._rotatePoint);
            var sinVal = (+this._rotateButton.attr('y') - curMovePos.y) / dis;
            var rotateAngle = Math.asin(sinVal) * (180 / Math.PI);
            isNaN(rotateAngle) && (rotateAngle = 0);

            if (curMovePos.x >= this._rotatePoint.x) {
                this._rotateAngle -= rotateAngle;
            } else {
                this._rotateAngle += rotateAngle;
            }
            this._rotateAngle = (this._rotateAngle + 360) % 360;

            // if ((this._rotateAngle > 0 && this._rotateAngle < 5) || (this._rotateAngle > 355 && this._rotateAngle < 360)) {
            // this._rotateAngle = 0; } else if ((this._rotateAngle > 85 && this._rotateAngle < 90) || (this._rotateAngle > 90 &&
            // this._rotateAngle < 95)) {     this._rotateAngle = 90; } else if ((this._rotateAngle > 175 && this._rotateAngle <
            // 180) || (this._rotateAngle > 180 && this._rotateAngle < 185)) {     this._rotateAngle = 180; } else if
            // ((this._rotateAngle > 265 && this._rotateAngle < 270) || (this._rotateAngle > 270 && this._rotateAngle < 275)) {
            // this._rotateAngle = 270; }

            this._linesGroup.attr({
                transform: 'translate(0,' + this._perRowHeight / 1.37 + ') rotate(' + this._rotateAngle + ',' + this._rotatePoint.x + ',' + this._rotatePoint.y + ')'
            });

            this._rotateButton.attr({ x: curMovePos.x, y: curMovePos.y });
            //移动箭头
            this._moveArrow();
            //移动字母E
            this._moveE();
            //发布旋转电场事件
            helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnElectricFieldRotateEvent, {
                source: this.sceneName,
                rotateAngle: this._rotateAngle
            });
        },
        _moveArrow: function _moveArrow() {
            var lines = this._linesGroup.selectAll('g');
            for (var i = 0, iLen = lines.length; i < iLen; i++) {
                var arrow = lines[i].select('path');
                var point = lines[i].select('circle'); //标记点
                var pointX = point.node.getBoundingClientRect().left - this._bgSvg.node.getBoundingClientRect().left;
                var pointY = point.node.getBoundingClientRect().top - this._bgSvg.node.getBoundingClientRect().top;
                var crossPoint = this._calcCrossPoint(pointX, pointY);

                var arrowTranslateX = this._context.get2PointDistance({
                    x: pointX,
                    y: pointY
                }, crossPoint);
                arrowTranslateX = arrowTranslateX - this._calcArrowOffset(arrow); //arrow.node.getBoundingClientRect().width;
                var arrowTranslateY = $(arrow.node).data('arrowTranslateY');
                arrow.attr({ transform: 'translate(' + arrowTranslateX + ',' + arrowTranslateY + ')' });
            }
        },
        /**
         * 旋转电场时，箭头宽度的偏移量
         * @private
         */
        _calcArrowOffset: function _calcArrowOffset(arrow) {
            var offset = 0;
            var rotateAngle = this._rotateAngle % 360;
            if (rotateAngle === 0 || rotateAngle === 180) {
                offset = arrow.node.getBoundingClientRect().width;
            } else if (rotateAngle === 90 || rotateAngle === 270) {
                offset = arrow.node.getBoundingClientRect().height;
            } else if (rotateAngle >= 0 && rotateAngle <= 45) {
                offset = arrow.node.getBoundingClientRect().width * Math.cos(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 45 && rotateAngle <= 90) {
                offset = arrow.node.getBoundingClientRect().height * Math.sin(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 90 && rotateAngle <= 135) {
                offset = arrow.node.getBoundingClientRect().height * Math.sin(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 135 && rotateAngle <= 180) {
                offset = -arrow.node.getBoundingClientRect().height * Math.cos(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 180 && rotateAngle <= 225) {
                offset = -arrow.node.getBoundingClientRect().height * Math.cos(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 225 && rotateAngle <= 270) {
                offset = -arrow.node.getBoundingClientRect().width * Math.sin(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 270 && rotateAngle <= 315) {
                offset = -arrow.node.getBoundingClientRect().width * Math.sin(rotateAngle * Math.PI / 180);
            } else if (rotateAngle >= 315 && rotateAngle <= 360) {
                offset = arrow.node.getBoundingClientRect().height * Math.cos(rotateAngle * Math.PI / 180);
            }

            return offset;
        },
        _calcCrossPoint: function _calcCrossPoint(startX, startY) {
            var point = {
                x: 0,
                y: 0
            };
            var k = Math.tan(this._rotateAngle * Math.PI / 180);
            if (this._rotateAngle === 90) {
                point = {
                    x: startX,
                    y: this._bgSvg.node.getBoundingClientRect().height
                };
            } else if (this._rotateAngle === 270) {
                point = {
                    x: startX,
                    y: 0
                };
            } else if (this._rotateAngle === 0) {
                point = {
                    x: this._bgSvg.node.getBoundingClientRect().width,
                    y: startY
                };
            } else if (this._rotateAngle === 180) {
                point = {
                    x: 0,
                    y: startY
                };
            } else if (this._rotateAngle > 270 && this._rotateAngle < 360) {
                var yBound = 0;
                //y－y1=k（x－x1）点斜式 => x = ((y-y1)+k*x1)/k或y = k(x-x1)+y1
                var x = (yBound - startY + k * startX) / k;
                if (x < this._bgSvg.node.getBoundingClientRect().width) {
                    point = {
                        x: x,
                        y: yBound
                    };
                } else {
                    var y = k * (this._bgSvg.node.getBoundingClientRect().width - startX) + startY;
                    point = {
                        x: this._bgSvg.node.getBoundingClientRect().width,
                        y: y
                    };
                }
            } else if (this._rotateAngle > 180 && this._rotateAngle < 270) {
                var xBound = 0;
                //y－y1=k（x－x1）点斜式 => x = ((y-y1)+k*x1)/k或y = k(x-x1)+y1
                var _y = k * (xBound - startX) + startY;

                if (_y < 0) {
                    var _x = (0 - startY + k * startX) / k;
                    point = {
                        x: _x,
                        y: 0
                    };
                } else {
                    point = {
                        x: 0,
                        y: _y
                    };
                }
            } else if (this._rotateAngle > 90 && this._rotateAngle < 180) {
                var _yBound = this._bgSvg.node.getBoundingClientRect().height;
                //y－y1=k（x－x1）点斜式 => x = ((y-y1)+k*x1)/k或y = k*(x-x1)+y1
                var _x2 = (_yBound - startY + k * startX) / k;
                if (_x2 < 0) {
                    var _y2 = k * (0 - startX) + startY;
                    point = {
                        x: 0,
                        y: _y2
                    };
                } else {
                    point = {
                        x: _x2,
                        y: _yBound
                    };
                }
            } else {
                var _xBound = this._bgSvg.node.getBoundingClientRect().width;
                //y－y1=k（x－x1）点斜式 => x = ((y-y1)+k*x1)/k或y = k(x-x1)+y1
                var _y3 = k * (_xBound - startX) + startY;
                if (_y3 < this._bgSvg.node.getBoundingClientRect().height) {
                    point = {
                        x: _xBound,
                        y: _y3
                    };
                } else {
                    var _x3 = (this._bgSvg.node.getBoundingClientRect().height - startY + k * startX) / k;
                    point = {
                        x: _x3,
                        y: this._bgSvg.node.getBoundingClientRect().height
                    };
                }
            }
            return point;
        },
        _moveE: function _moveE() {
            var width = this._svg.node.getBoundingClientRect().width - (this._svg.node.getBoundingClientRect().width - this._bgSvg.node.getBoundingClientRect().width);
            var height = this._svg.node.getBoundingClientRect().height;
            var widthRatio = width / 90;
            var heightRatio = height / 90;

            var r = this._rotateAngle;
            var rVal = void 0;
            if (r >= 270 && r <= 360) {
                rVal = r - 270;
                this._eText.attr({
                    transform: 'translate(' + (rVal * widthRatio + this._eText.node.getBoundingClientRect().width * 0.5) + ',' + this._eText.node.getBoundingClientRect().height * 0.8 + ')'
                });
            } else if (r >= 180 && r <= 270) {
                rVal = r - 180;
                var translateY = height - rVal * heightRatio;
                translateY = translateY - this._eText.node.getBoundingClientRect().height < 0 ? this._eText.node.getBoundingClientRect().height : translateY;
                this._eText.attr({ transform: 'translate(' + 0 + ',' + translateY + ')' });
            } else if (r >= 90 && r <= 180) {
                rVal = r - 90;
                this._eText.attr({
                    transform: 'translate(' + (90 - rVal) * widthRatio + ',' + height + ')'
                });
            } else if (r >= 0 && r <= 90) {
                rVal = r;
                var _translateY = rVal * heightRatio;
                _translateY = _translateY - this._eText.node.getBoundingClientRect().height < 0 ? this._eText.node.getBoundingClientRect().height * 0.7 : _translateY;
                this._eText.attr({
                    transform: 'translate(' + (width + 1.5 * this._eText.node.getBoundingClientRect().width) + ',' + _translateY + ')'
                });
            }
        },
        _drawLineArrow: function _drawLineArrow() {
            this._linesGroup = this._bgSvg.paper.g();
            this._perRowHeight = this._bgSvg.node.getBoundingClientRect().height / 8.5;
            var lineWidth = this._bgSvg.node.getBoundingClientRect().width;
            for (var i = -5; i < 15; i++) {
                var lineGroup = this._bgSvg.paper.g();
                var arrow = this._bgSvg.paper.path().attr({
                    fill: '#626f79',
                    // d: `M 0.78 1.20 C 7.14 7.37 15.81 10.00 24.07 12.55 C 30.67 14.62 37.46 16.12 43.92 18.62 C 43.89 18.81 43.84 19.20
                    // 43.81 19.39 C 32.11 23.67 19.63 25.88 8.43 31.51 C 5.61 32.86 3.21 34.88 0.82 36.84 C 1.57 31.24 4.48 26.35 7.89
                    // 21.96 C 7.96 19.99 7.92 18.01 7.85 16.04 C 4.45 11.66 1.47 6.82 0.78 1.20 Z`
                    d: this.d
                });
                var dis = this._perRowHeight * i - arrow.node.getBoundingClientRect().height / 2;
                var arrowTranslateX = lineWidth - arrow.node.getBoundingClientRect().width;
                $(arrow.node).data('arrowTranslateX', arrowTranslateX);
                $(arrow.node).data('arrowTranslateY', dis);
                arrow.attr({ transform: 'translate(' + arrowTranslateX + ',' + dis + ')' });
                //箭头
                lineGroup.add(arrow);
                //线
                lineGroup.add(this._bgSvg.paper.line().attr({
                    x1: -lineWidth,
                    y1: dis + arrow.node.getBoundingClientRect().height / 2,
                    x2: 2 * lineWidth,
                    y2: dis + arrow.node.getBoundingClientRect().height / 2 + this.Two,
                    stroke: '#626f79',
                    strokeWidth: this.lineStrokeWidth,
                    strokeLinecap: 'round'
                }));
                //点
                lineGroup.add(this._bgSvg.paper.circle(0, dis + arrow.node.getBoundingClientRect().height / 2, 1).attr({ fill: '#626f79' }));
                this._linesGroup.add(lineGroup);
            }
            this._linesGroup.attr({
                transform: 'translate(0,' + this._perRowHeight / 1.37 + ') rotate(' + this._rotateAngle + ',' + this._rotatePoint.x + ',' + this._rotatePoint.y + ')'
            });
        },
        //全屏画线
        _reDrawLineArrow: function _reDrawLineArrow() {
            var helper = this._helper;
            var svgContainerWidth = helper.saveData.svgWidth;
            var svgContainerHeight = helper.saveData.svgHeight;
            var bgSvgContainerWidth = helper.saveData.svgbgWidth;
            var bgSvgContainerHeight = helper.saveData.svgbgHeight;
            var svgLeft = helper.saveData.svgLeft;
            var svgTop = helper.saveData.svgTop;
            var svgbgLeft = helper.saveData.svgbgLeft;
            var svgbgTop = helper.saveData.svgbgTop;
            var lines = this._linesGroup.selectAll('g');
            var lineWidth = helper.saveData.svgbgWidth;
            this._perRowHeight = bgSvgContainerHeight / 8.5;
            var ratio = helper.model.ratio;
            var ArrowHeight = helper.saveData.arrowHeight * ratio;
            this.lineStrokeWidth = this.lineStrokeWidth * ratio;
            this.Two = this.Two * ratio;
            this._rotatePoint = {
                x: bgSvgContainerWidth / 2,
                y: bgSvgContainerHeight / 2
            };
            var r = ratio;
            if (helper.model.initRatio !== helper.model.ratio) {
                r = 1;
            }
            for (var i = 0, iLen = lines.length; i < iLen; i++) {
                var arrow = lines[i].select('path');
                var line = lines[i].select('line');
                var point = lines[i].select('circle'); //标记点
                arrow.attr({
                    d: ' M ' + ' ' + 0.45 * r + ' ' + 1.35 * r + 'C' + 3.92 * r + ' ' + 3.36 * r + ' ' + 7.39 * r + ' ' + 5.48 * r + ' ' + 11.25 * r + ' ' + 6.69 * r + ' ' + 'C' + ' ' + 16.88 * r + ' ' + 8.74 * r + ' ' + 22.95 * r + ' ' + 9.56 * r + ' ' + 28.27 * r + ' ' + 12.41 * r + ' ' + 'C' + ' ' + 24.13 * r + ' ' + 13.82 * r + ' ' + 19.93 * r + ' ' + 15.02 * r + ' ' + 15.66 * r + ' ' + 15.95 * r + ' ' + 'C' + ' ' + 10.20 * r + ' ' + 17.85 * r + ' ' + 4.95 * r + ' ' + 20.32 * r + ' ' + 0.00 * r + ' ' + 23.30 * r + ' ' + 'L' + ' ' + 0.00 * r + ' ' + 22.81 * r + ' ' + 'C ' + ' ' + 1.65 * r + ' ' + 19.54 * r + ' ' + 3.61 * r + ' ' + 16.42 * r + ' ' + 5.05 * r + ' ' + 13.06 * r + ' ' + 'C' + ' ' + 5.23 * r + ' ' + 8.70 * r + ' ' + 1.06 * r + ' ' + 5.63 * r + ' ' + 0.45 * r + ' ' + 1.35 * r + ' ' + 'Z'
                });
                //debugger
                var dis = this._perRowHeight * (i - 5) - ArrowHeight / 2;
                point.attr({ cy: dis + ArrowHeight / 2 });
                var pointX = point.node.getBoundingClientRect().left * -svgbgLeft;
                var pointY = point.node.getBoundingClientRect().top - svgbgTop;
                var crossPoint = this._calcCrossPoint(pointX, pointY);
                var arrowTranslateX = this._context.get2PointDistance({
                    x: pointX,
                    y: pointY
                }, crossPoint);
                arrowTranslateX = arrowTranslateX - this._calcArrowOffset(arrow); //arrow.node.getBoundingClientRect().width;
                line.attr({
                    x1: -lineWidth,
                    y1: dis + ArrowHeight / 2,
                    x2: 2 * lineWidth,
                    y2: dis + ArrowHeight / 2 + this.Two,
                    strokeWidth: this.lineStrokeWidth
                });
                $(arrow.node).data('arrowTranslateX', arrowTranslateX);
                var arrowTranslateY = $(arrow.node).data('arrowTranslateY') * ratio;
                $(arrow.node).data('arrowTranslateY', arrowTranslateY);
                arrow.attr({ transform: 'translate(' + arrowTranslateX + ',' + arrowTranslateY + ')' });
                this._linesGroup.attr({
                    transform: 'translate(0,' + this._perRowHeight / 1.37 + ') rotate(' + this._rotateAngle + ',' + this._rotatePoint.x + ',' + this._rotatePoint.y + ')'
                });
            }
        }
    });
    return ElectricField;
});
'use strict';

/**
 * PolygonalLine 沿折线预设
 */
define('PolygonalLine', ['BaseView'], function (BaseView) {
    var PolygonalLine = BaseView.extend({
        $init: function $init(helper, opt) {
            opt = $.extend({
                name: helper.sceneName.POLYGONAL_LINE,
                svgContainer: helper.domObj.$polygonalLineContainer,
                bgSvgContainer: helper.domObj.$polygonalLineBgContainer
            }, opt);
            this._super(helper, opt);
            this._helper = helper;
        },
        init: function init(opt) {
            this._super(opt);
        },
        resizeScreen: function resizeScreen() {
            console.log('折线');
            this._super();
        },
        getLinePoints: function getLinePoints(a, b) {
            this._linePoints = [];

            this._linePoints.push([a.x, a.y]);

            // if (a.x <= b.x && a.y <= b.y) { // a在b的左上
            //     this._linePoints.push([a.x, b.y]);
            // } else if (a.x <= b.x && a.y >= b.y) { // a在b的左下
            //     this._linePoints.push([b.x, a.y]);
            // } else if (a.x >= b.x && a.y <= b.y) { //a在b的右上
            //     this._linePoints.push([a.x, b.y]);
            // } else if (a.x >= b.x && a.y >= b.y) { //a在b的右下
            //     this._linePoints.push([b.x, a.y]);
            // }

            var breakPoint = this._breakPoint(this._electricField._rotateAngle, a, b);
            this._linePoints.push([breakPoint.x, breakPoint.y]);

            this._linePoints.push([b.x, b.y]);
            return this._linePoints;
        },
        /**
         * 返回{x:*,y:*}对象的数组
         * @param start
         * @param end
         * @return {Array}
         */
        getBezierPoints: function getBezierPoints(start, end) {
            var points = [];
            var breakPoint = this._breakPoint(this._electricField._rotateAngle, start, end);
            for (var i = 0; i < 100; i++) {
                points.push(this.get1Bezier(start, breakPoint, i / 100));
            }
            for (var _i = 0; _i < 100; _i++) {
                points.push(this.get1Bezier(breakPoint, end, _i / 100));
            }
            return points;
        },
        getCurrentExpressionDom: function getCurrentExpressionDom() {
            var helper = this._helper;
            return helper.domObj.$polygonalLineExpression;
        },
        getExpressionsDom: function getExpressionsDom() {
            var helper = this._helper;
            return [helper.domObj.$polygonalLineExpression];
        },
        _bindEvent: function _bindEvent() {
            var _this = this;

            this._super();
            var helper = this._helper;
            //监听电场旋转事件
            this._onElectricFieldRotateEventToken = helper.publishSubscribe.subscribe(helper.publishSubscribe._topicName.OnElectricFieldRotateEvent, function (topic, args) {
                if (args.source !== helper.sceneName.POLYGONAL_LINE) {
                    return;
                }
                var aPos = _this._chargeTrajectory._aPos;
                var bPos = _this._chargeTrajectory._bPos;

                var points = [];
                //A点
                points.push([aPos.x, aPos.y]);
                //求交点
                var breakPoint = _this._breakPoint(args.rotateAngle, aPos, bPos);
                points.push([breakPoint.x, breakPoint.y]);
                //B点
                points.push([bPos.x, bPos.y]);

                _this._chargeTrajectory._abPath.attr({
                    points: points.join(',')
                });
            });
        },
        _unbindEvent: function _unbindEvent() {
            this._super();
            var helper = this._helper;
            this._onElectricFieldRotateEventToken != undefined && helper.publishSubscribe.remove(helper.publishSubscribe._topicName.OnElectricFieldRotateEvent, this._onElectricFieldRotateEventToken);
        }
    });
    return PolygonalLine;
});
'use strict';

/**
 * PowerAndEnergyController 控制器类
 */
define('PowerAndEnergyController', ['StraightLine', 'PolygonalLine', 'CurveLine', 'CustomLine'], function (StraightLine, PolygonalLine, CurveLine, CustomLine) {
    var PowerAndEnergyController = Class.extend({
        $init: function $init(helper, opt) {
            this._helper = helper;
            this._currentScene = {
                STRAIGHT_LINE: {
                    scene: new StraightLine(helper, {}),
                    $current: helper.domObj.$straightLine,
                    $currentContainer: helper.domObj.$straightLineContainer.parent(),
                    expressions: [helper.domObj.$straightLineExpression1, helper.domObj.$straightLineExpression2]
                },
                POLYGONAL_LINE: {
                    scene: new PolygonalLine(helper, {}),
                    $current: helper.domObj.$polygonalLine,
                    $currentContainer: helper.domObj.$polygonalLineContainer.parent(),
                    expressions: [helper.domObj.$polygonalLineExpression]
                },
                CURVE_LINE: {
                    scene: new CurveLine(helper, {}),
                    $current: helper.domObj.$curveLine,
                    $currentContainer: helper.domObj.$curveLineContainer.parent(),
                    expressions: [helper.domObj.$curveLineExpression]
                },
                CUSTOM_LINE: {
                    scene: new CustomLine(helper, {}),
                    $current: helper.domObj.$customLine,
                    $currentContainer: helper.domObj.$customLineContainer.parent(),
                    expressions: [helper.domObj.$customLineExpression]
                }
            };
        },
        resizeScreen: function resizeScreen() {
            console.log('全屏ddd');
            this._currentScene.STRAIGHT_LINE.scene.resizeScreen();
            this._currentScene.POLYGONAL_LINE.scene.resizeScreen();
            this._currentScene.CURVE_LINE.scene.resizeScreen();
            this._currentScene.CUSTOM_LINE.scene.resizeScreen();
        },
        /**
         * 初始化
         */
        init: function init() {
            var helper = this._helper;
            var $currentScene = helper.domObj.$sceneItems.filter('li[data-name="' + helper.currentScene + '"]');
            $currentScene.trigger('click');
            this._unbindEvent();
            this._bindEvent();
        },
        resizeInit: function resizeInit() {
            var helper = this._helper;
            var $currentScene = helper.domObj.$sceneItems.filter('li[data-name="' + helper.currentScene + '"]');
            $currentScene.trigger('click');
            //this._unbindEvent();
            //this._bindEvent();
        },
        /**
         * 预设切换的处理
         */
        sceneClickHandler: function sceneClickHandler(e, name) {
            var helper = this._helper;
            helper.currentScene = name;
            var currentScene = this._currentScene;
            if (currentScene[name].$current.hasClass('on')) {
                return;
            }
            helper.domObj.$sceneItems.removeClass('on');
            currentScene[name].$current.addClass('on');
            helper.domObj.$mainMiddleContentItems.addClass('hide_dom');
            currentScene[name].$currentContainer.removeClass('hide_dom');
            currentScene[name].scene.init();
        },
        /**
         * 电势能变化按钮点击处理
         */
        energyCheckClickHandler: function energyCheckClickHandler(e) {
            var helper = this._helper;
            var currentScene = this._currentScene;
            var $energyCheckLabel = helper.domObj.$energyCheck.find('label');
            $energyCheckLabel.toggleClass('checked');
            currentScene[helper.currentScene].scene._energyCheck = $energyCheckLabel.hasClass('checked');
            currentScene[helper.currentScene].scene._energyCheck ? helper.domObj.$energyBar.removeClass('hide_visibility') : helper.domObj.$energyBar.addClass('hide_visibility');

            //控制公式显示隐藏
            if (currentScene[helper.currentScene].scene._viewAnalysisCheck) {
                var expression = void 0;
                if (helper.currentScene === helper.sceneName.STRAIGHT_LINE) {
                    // 直线特殊处理
                    var scene = currentScene[helper.currentScene].scene;
                    if (scene._chargeTrajectory._aPos.y === scene._chargeTrajectory._bPos.y) {
                        //AB点在同一水平线上
                        expression = currentScene[helper.currentScene].expressions[0];
                    } else {
                        //AB不在同一水平线上
                        expression = currentScene[helper.currentScene].expressions[1];
                    }
                } else {
                    //其他三种预设
                    expression = currentScene[helper.currentScene].expressions[0];
                }
                var $p = expression.find('p:nth-child(2)');
                currentScene[helper.currentScene].scene._energyCheck ? $p.removeClass('hide_dom') : $p.addClass('hide_dom');

                //如果电势能和静电都关闭，公式容器要隐藏
                if (!currentScene[helper.currentScene].scene._energyCheck && !currentScene[helper.currentScene].scene._electrostaticCheck) {
                    expression.addClass('hide_dom');
                } else {
                    //有一个打开
                    expression.removeClass('hide_dom');
                }
            }
        },
        /**
         * 静电力做功按钮点击的处理
         */
        electrostaticCheckClickHandler: function electrostaticCheckClickHandler(e) {
            var helper = this._helper;
            var currentScene = this._currentScene;
            var $electrostaticCheckLabel = helper.domObj.$electrostaticCheck.find('label');
            $electrostaticCheckLabel.toggleClass('checked');
            currentScene[helper.currentScene].scene._electrostaticCheck = $electrostaticCheckLabel.hasClass('checked');
            currentScene[helper.currentScene].scene._electrostaticCheck ? helper.domObj.$electrostaticBar.removeClass('hide_visibility') : helper.domObj.$electrostaticBar.addClass('hide_visibility');

            //控制公式显示隐藏
            if (currentScene[helper.currentScene].scene._viewAnalysisCheck) {
                var expression = void 0;
                if (helper.currentScene === helper.sceneName.STRAIGHT_LINE) {
                    // 直线特殊处理
                    var scene = currentScene[helper.currentScene].scene;
                    if (scene._chargeTrajectory._aPos.y === scene._chargeTrajectory._bPos.y) {
                        //AB点在同一水平线上
                        expression = currentScene[helper.currentScene].expressions[0];
                    } else {
                        //AB不在同一水平线上
                        expression = currentScene[helper.currentScene].expressions[1];
                    }
                } else {
                    //其他三种预设
                    expression = currentScene[helper.currentScene].expressions[0];
                }
                var $p = expression.find('p:nth-child(1)');
                currentScene[helper.currentScene].scene._electrostaticCheck ? $p.removeClass('hide_dom') : $p.addClass('hide_dom');

                //如果电势能和静电都关闭，公式容器要隐藏
                if (!currentScene[helper.currentScene].scene._energyCheck && !currentScene[helper.currentScene].scene._electrostaticCheck) {
                    expression.addClass('hide_dom');
                } else {
                    //有一个打开
                    expression.removeClass('hide_dom');
                }
            }
        },
        /**
         * 正负电荷开关切换的处理
         */
        electricChargeCheckClickHandler: function electricChargeCheckClickHandler(e) {
            var helper = this._helper;
            var currentScene = this._currentScene;
            helper.domObj.$electricChargeCheck.toggleClass('positive');
            currentScene[helper.currentScene].scene._electricChargeCheck = helper.domObj.$electricChargeCheck.hasClass('positive');

            //受力方向打开，受力方向箭头也要变化
            currentScene[helper.currentScene].scene._chargeTrajectory._initForceArrowGroup();

            //条形上下要发生变化
            currentScene[helper.currentScene].scene.initBar();

            //切换正负电荷事件
            helper.publishSubscribe.publish(helper.publishSubscribe._topicName.OnChangePlusMinusElectricChargeEvent, {
                source: helper.currentScene,
                electricChargeCheck: helper.domObj.$electricChargeCheck.hasClass('positive')
            });
        },
        /**
         * 受力方向开关切换的处理
         */
        forceDirectionCheckClickHandler: function forceDirectionCheckClickHandler(e) {
            var helper = this._helper;
            var currentScene = this._currentScene;
            var $forceDirectionCheckLabel = helper.domObj.$forceDirectionCheck.find('label');
            $forceDirectionCheckLabel.toggleClass('checked');
            currentScene[helper.currentScene].scene._forceDirectionCheck = $forceDirectionCheckLabel.hasClass('checked');

            currentScene[helper.currentScene].scene._chargeTrajectory._initForceArrowGroup();
        },
        /**
         * 点击查看分析的处理
         */
        viewAnalysisCheckClickHandler: function viewAnalysisCheckClickHandler(e) {
            var helper = this._helper;
            var currentScene = this._currentScene;
            if (helper.domObj.$viewAnalysisCheck.hasClass('disabled')) {
                currentScene[helper.currentScene].scene._viewAnalysisCheck = null;
                return;
            }
            currentScene[helper.currentScene].scene._viewAnalysisCheck = !currentScene[helper.currentScene].scene._viewAnalysisCheck;
            currentScene[helper.currentScene].scene.initViewAnalysis();
        },
        /**
         * 重置处理
         */
        resetClickHandler: function resetClickHandler(e) {
            var helper = this._helper;
            var scene = this._currentScene[helper.currentScene].scene;
            scene._energyCheck = false;
            scene._electrostaticCheck = true;
            if (!scene._electricChargeCheck) {
                helper.domObj.$electricChargeCheck.trigger('click');
            }
            scene._electricChargeCheck = true;
            if (scene._forceDirectionCheck) {
                helper.domObj.$forceDirectionCheck.trigger('click');
            }
            scene._forceDirectionCheck = false;
            if (scene._viewAnalysisCheck) {
                helper.domObj.$viewAnalysisCheck.trigger('click');
            }
            scene._viewAnalysisCheck = null;
            scene._linePoints = [];
            scene._qBezierPoints = [];

            //背景电场
            scene._electricField._rotateState = true;
            scene._electricField._rotateAngle = 360;
            scene._electricField._rotateButton.attr({ href: scene._electricField._bgImg.normal });

            //电荷轨迹
            scene._chargeTrajectory._aPos = {
                x: scene._$svgContainer[0].getBoundingClientRect().width / 4,
                y: scene._$svgContainer[0].getBoundingClientRect().height / 3 * 2
            };
            scene._chargeTrajectory._bPos = {
                x: scene._$svgContainer[0].getBoundingClientRect().width / 5 * 4,
                y: scene._$svgContainer[0].getBoundingClientRect().height / 4
            };
            scene._chargeTrajectory._qPos = {
                x: scene._$svgContainer[0].getBoundingClientRect().width / 4,
                y: scene._$svgContainer[0].getBoundingClientRect().height / 3 * 2
            };
            scene._chargeTrajectory._aState = true;
            scene._chargeTrajectory._bState = true;
            scene._chargeTrajectory._qState = true;
            scene._chargeTrajectory._bezierPoints = [];

            scene.init();
        },
        /**
         * 获取对应预设的参数
         * @param sceneName
         */
        getSceneOption: function getSceneOption(sceneName) {
            var scene = this._currentScene[sceneName].scene;
            var option = null;
            if (scene._svg) {
                option = {
                    energyCheck: scene._energyCheck, //电势能变化开关
                    electrostaticCheck: scene._electrostaticCheck, //静电力做功开关
                    electricChargeCheck: scene._electricChargeCheck, //正负电荷开关
                    forceDirectionCheck: scene._forceDirectionCheck, //受力方向开关
                    viewAnalysisCheck: scene._viewAnalysisCheck, //查看分析开关
                    resetButton: scene._resetButton, //重置按钮开关
                    barVal: scene._barVal, //条形值
                    epbWabPos: scene._epbWabPos, //epb和wab的位置
                    epWPos: scene._epWPos, //ep和w的位置
                    qBezierPoints: scene._qBezierPoints, //q路径的点
                    electricField: {
                        rotateState: scene._electricField ? scene._electricField._rotateState : true, //电场是否可旋转
                        rotateAngle: scene._electricField ? scene._electricField._rotateAngle : 0 //电场旋转角度
                    }, //电荷轨迹
                    chargeTrajectory: {
                        aPos: scene._chargeTrajectory ? scene._chargeTrajectory._aPos : undefined, //a点坐标
                        bPos: scene._chargeTrajectory ? scene._chargeTrajectory._bPos : undefined, //b点坐标
                        qPos: scene._chargeTrajectory ? scene._chargeTrajectory._qPos : undefined, //q点坐标
                        aState: scene._chargeTrajectory ? scene._chargeTrajectory._aState : true, //a点是否可移动状态
                        bState: scene._chargeTrajectory ? scene._chargeTrajectory._bState : true, //b点是否可移动的状态
                        qState: scene._chargeTrajectory ? scene._chargeTrajectory._qState : true //q点是否可移动的状态
                    } //背景电场
                };
            }
            return option;
        },
        _bindEvent: function _bindEvent() {
            var _this = this;

            var helper = this._helper;
            //监听Q点进入B点事件
            this._onQPointEnterBPointEventToken = helper.publishSubscribe.subscribe(helper.publishSubscribe._topicName.OnQPointEnterBPointEvent, function (topic, args) {
                helper.domObj.$viewAnalysisCheck.removeClass('disabled');
                var scene = _this._currentScene[helper.currentScene].scene;
                scene._viewAnalysisCheck = false;
            });
            //监听Q点离开B点事件
            this._onQPointLeaveBPointEventToken = helper.publishSubscribe.subscribe(helper.publishSubscribe._topicName.OnQPointLeaveBPointEvent, function (topic, args) {
                var currentScene = _this._currentScene;
                helper.domObj.$viewAnalysisCheck.addClass('disabled');
                helper.domObj.$viewAnalysisCheck.find('label').removeClass('checked');
                currentScene[helper.currentScene].scene._viewAnalysisCheck = null;
                for (var i = 0, iLen = currentScene[helper.currentScene].expressions.length; i < iLen; i++) {
                    _this._currentScene[args.source].expressions[i].addClass('hide_dom');
                }
            });
            //监听电场旋转
            this._onElectricFieldRotateEventToken = helper.publishSubscribe.subscribe(helper.publishSubscribe._topicName.OnElectricFieldRotateEvent, function (topic, args) {
                var currentScene = _this._currentScene;

                //受力方向要改变
                currentScene[helper.currentScene].scene._chargeTrajectory._initForceArrowGroup();

                //条形上下要发生变化
                currentScene[helper.currentScene].scene.initBar();
            });
        },
        _unbindEvent: function _unbindEvent() {
            var helper = this._helper;
            this._onQPointEnterBPointEventToken !== undefined && helper.publishSubscribe.remove(helper.publishSubscribe._topicName.OnQPointEnterBPointEvent, this._onQPointEnterBPointEventToken);
            this._onQPointLeaveBPointEventToken !== undefined && helper.publishSubscribe.remove(helper.publishSubscribe._topicName.OnQPointLeaveBPointEvent, this._onQPointEnterBPointEventToken);
            this._onElectricFieldRotateEventToken !== undefined && helper.publishSubscribe.remove(helper.publishSubscribe._topicName.OnElectricFieldRotateEvent, this._onQPointEnterBPointEventToken);
        }
    });
    return PowerAndEnergyController;
});
'use strict';

define('PublishSubscribe', function () {
    var PublishSubscribe = Class.extend({
        $init: function $init() {
            this._queues = {};
            this._topics = {};
            this._topicIndex = -1;
            this._topicName = {
                //移动A
                OnAPointMoveEvent: Symbol.for('On A Point Event'),
                //移动B
                OnBPointMoveEvent: Symbol.for('On B Point Event'),
                //移动Q
                OnQPointMoveEvent: Symbol.for('On Q Point Event'),
                //Q点进入B点
                OnQPointEnterBPointEvent: Symbol.for('On Q Point Enter B Point Event'),
                //Q点离开B点
                OnQPointLeaveBPointEvent: Symbol.for('On Q Point Leave B Point Event'),
                //切换正负电荷
                OnChangePlusMinusElectricChargeEvent: Symbol.for('On Change Plus-Minus Electric Charge Event'),
                //旋转电场事件
                OnElectricFieldRotateEvent: Symbol.for('On Electric Field Rotate Event')
            };
        },

        //发布消息
        publish: function publish(topic, args) {
            if (!this._topics[topic]) {
                return;
            }
            var subs = this._topics[topic];
            for (var i = 0, iLen = subs.length; i < iLen; i++) {
                subs[i].func(topic, args);
            }
        },
        //监听消息
        subscribe: function subscribe(topic, func) {
            this._topics[topic] = this._topics[topic] ? this._topics[topic] : [];
            var token = (++this._topicIndex).toString();
            this._topics[topic].push({
                token: token,
                func: func
            });
            return token;
        },
        remove: function remove(topic, token) {
            var result = void 0;
            for (var i = 0, iLen = this._topics.length; i < iLen; i++) {
                if (this._topics[i].token === token) {
                    result = this._topics.splice(i, 1);
                    break;
                }
            }
            return result;
        },
        //重置消息发布订阅器
        reset: function reset() {
            this._queues = {};
            this._topics = {};
            this._topicIndex = -1;
        }
    });

    return PublishSubscribe;
});
'use strict';

/**
 * StraightLine 沿直线预设
 */
define('StraightLine', ['BaseView'], function (BaseView) {
    var StraightLine = BaseView.extend({
        $init: function $init(helper, opt) {
            opt = $.extend({
                name: helper.sceneName.STRAIGHT_LINE,
                svgContainer: helper.domObj.$straightLineContainer,
                bgSvgContainer: helper.domObj.$straightLineBgContainer
            }, opt);
            this._super(helper, opt);
            this._helper = helper;
        },
        init: function init(opt) {
            this._super(opt);
        },
        resizeScreen: function resizeScreen() {
            console.log('直线');
            if (this._svg !== null) {
                this.removeAnalysisPath();
            }
            this._super();
        },
        showAnalysisPath: function showAnalysisPath() {
            this._super();
            var aPos = this._chargeTrajectory._aPos;
            var bPos = this._chargeTrajectory._bPos;
            var breakPoint = this._breakPoint(this._electricField._rotateAngle, aPos, bPos);
            var amDis = this.get2PointDistance(aPos, breakPoint);
            var angleRadius = amDis / 5;
            var abDis = this.get2PointDistance(aPos, bPos);
            var rotateAngle = this._electricField._rotateAngle;
            var angleValue = Math.acos(amDis / abDis) * 180 / Math.PI;

            var endX = angleRadius - angleRadius * Math.cos(angleValue * Math.PI / 180);
            var endY = -angleRadius * Math.sin(angleValue * Math.PI / 180);

            if (angleValue === 0 || angleValue === 90) {
                return;
            }
            //θ角
            this._theta = this._svg.paper.path();

            var amp = this.get1Bezier(aPos, breakPoint, 0.2);
            var abp = this.get1Bezier(aPos, bPos, 0.2 * amDis / abDis);

            var dStr = '';

            //判断顺指针还是逆指针,小于0逆指针，大于0顺指针
            var p = (breakPoint.x - aPos.x) * (bPos.y - breakPoint.y) - (breakPoint.y - aPos.y) * (bPos.x - breakPoint.x);

            if (p < 0) {
                //逆指针
                dStr = 'M ' + amp.x + ' ' + amp.y + ' A ' + angleRadius + ' ' + angleRadius + ' 0 0 0 ' + abp.x + ' ' + abp.y + ' ';
            } else {
                //顺指针
                dStr = 'M ' + amp.x + ' ' + amp.y + ' A ' + angleRadius + ' ' + angleRadius + ' 0 0 1 ' + abp.x + ' ' + abp.y + ' ';
            }

            this._theta.attr({
                class: 'theta',
                d: dStr,
                // transform: `translate(${aPos.x - angleRadius},${aPos.y}) rotate(${thetaRotateAngle},${angleRadius},0)`,
                fill: 'none',
                stroke: '#000',
                strokeWidth: 3
            });

            var p1 = this.get1Bezier(aPos, breakPoint, 0.35);
            var p2 = this.get1Bezier(aPos, bPos, 0.35 * amDis / abDis);
            var textPos = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            //θ角文本
            this._thetaText = this._svg.paper.text(0, 0, 'θ');
            this._thetaText.attr({
                class: 'thetaText',
                transform: 'translate(' + (textPos.x - this._thetaText.node.getBoundingClientRect().width / 2) + ',' + (textPos.y + this._thetaText.node.getBoundingClientRect().height / 2) + ')',
                style: 'font:italic 2.66667em "Times New Roman"'
            });
            this._theta.insertBefore(this._chargeTrajectory._aPoint);
            this._thetaText.insertBefore(this._chargeTrajectory._aPoint);
        },
        removeAnalysisPath: function removeAnalysisPath() {
            this._super();
            var theta = void 0,
                thetaText = void 0;
            do {
                theta = this._svg.select('path.theta');
                theta && theta.remove();
            } while (theta);

            do {
                thetaText = this._svg.select('text.thetaText');
                thetaText && thetaText.remove();
            } while (thetaText);
        },
        getLinePoints: function getLinePoints(a, b) {
            this._linePoints = [];
            this._linePoints.push([a.x, a.y]);
            this._linePoints.push([b.x, b.y]);
            return this._linePoints;
        },
        getBezierPoints: function getBezierPoints(start, end) {
            var points = [];
            for (var i = 0; i <= 100; i++) {
                points.push(this.get1Bezier(start, end, i / 100));
            }
            return points;
        },
        getCurrentExpressionDom: function getCurrentExpressionDom() {
            var helper = this._helper;
            var expression = void 0;
            if (this._chargeTrajectory._aPos.y === this._chargeTrajectory._bPos.y) {
                //AB点在同一水平线上
                expression = helper.domObj.$straightLineExpression1;
            } else {
                //AB不在同一水平线上
                expression = helper.domObj.$straightLineExpression2;
            }

            return expression;
        },
        getExpressionsDom: function getExpressionsDom() {
            var helper = this._helper;
            return [helper.domObj.$straightLineExpression1, helper.domObj.$straightLineExpression2];
        }
    });
    return StraightLine;
});]]></presenter><resources><file src="./resources/wood/images/explain_1_1.png"/><file src="./resources/wood/images/explain_1_2.png"/><file src="./resources/wood/images/explain_1_3.png"/><file src="./resources/wood/images/explain_2_1.png"/><file src="./resources/wood/images/explain_3_1.png"/><file src="./resources/wood/images/force_arrow.png"/><file src="./resources/wood/images/negative_sign.png"/><file src="./resources/wood/images/positive_sign.png"/><file src="./resources/wood/images/preset_1.png"/><file src="./resources/wood/images/preset_2.png"/><file src="./resources/wood/images/preset_3.png"/><file src="./resources/wood/images/preset_4.png"/><file src="./resources/wood/images/q1.png"/><file src="./resources/wood/images/q2.png"/><file src="./resources/wood/images/reest_btn_disabled.png"/><file src="./resources/wood/images/reest_btn.png"/><file src="./resources/wood/images/reset_btn_active.png"/><file src="./resources/wood/images/reset.png"/><file src="./resources/wood/images/rotate_active.png"/><file src="./resources/wood/images/rotate_com.png"/><file src="./resources/wood/images/rotate_disabled.png"/><file src="./resources/wood/images/rotate.png"/></resources></addon>