<?xml version='1.0' encoding='UTF-8'?>
<addon id="templateid"><properties/><dependencies><jsDependency><javaScript name="out_frame" version="1.0.7"/><javaScript name="tools_common" version="1.3.0"/></jsDependency></dependencies><css><![CDATA[@charset "UTF-8";@font-face{font-family:iconfont;src:url(resources/images/iconfont.eot);src:url(resources/images/iconfont.eot?#iefix) format("embedded-opentype"),url(resources/images/iconfont.woff) format("woff"),url(resources/images/iconfont.ttf) format("truetype"),url(resources/images/iconfont.svg#iconfont) format("svg")}@-webkit-keyframes showbig{100%{-webkit-transform:scale(1.2)}}@keyframes showbig{100%{transform:scale(1.2)}}@-webkit-keyframes showIn{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1)}}@keyframes showIn{0%{transform:scale(0)}100%{transform:scale(1)}}@-webkit-keyframes startRotate{0%{-webkit-transform:rotate(0)}50%{-webkit-transform:rotate(180deg)}100%{-webkit-transform:rotate(360deg)}}@keyframes startRotate{0%{transform:rotate(0)}50%{transform:rotate(180deg)}100%{transform:rotate(360deg)}}@-webkit-keyframes zoomOff{0%{-webkit-transform:scale(0)}50%{-webkit-transform:scale(.8)}100%{-webkit-transform:scale(2);opacity:0}}@keyframes zoomOff{0%{transform:scale(0)}50%{transform:scale(.8)}100%{transform:scale(2);opacity:0}}@-webkit-keyframes loopMove{0%{-webkit-transform:scale(1)}50%{-webkit-transform:scale(1.1)}100%{-webkit-transform:scale(1)}}@keyframes loopMove{0%{transform:scale(1)}50%{transform:scale(1.1)}100%{transform:scale(1)}}.iconfont{font-family:iconfont!important;font-size:16px;font-style:normal;-webkit-font-smoothing:antialiased;-webkit-text-stroke-width:.2px;-moz-osx-font-smoothing:grayscale}.icon-jiantou:before{content:"\e613"}.icon-youjiantou:before{content:"\e666"}.icon-youjiantou1:before{content:"\e67e"}@font-face{font-family:iconfont;src:url(resources/images/iconfont.eot);src:url(resources/images/iconfont.eot?#iefix) format("embedded-opentype"),url(resources/images/iconfont.woff) format("woff"),url(resources/images/iconfont.ttf) format("truetype"),url(resources/images/iconfont.svg#iconfont) format("svg")}.physicspower_box{width:100%;height:100%;background:#bfd3e2;padding:3.33333em 5.16667em 6.25em}.physicspower_box.font_small .force_name_span_wrapper .force_name_f{font-size:64px}.physicspower_box.font_small .force_name_span_wrapper .force_name_num{font-size:45px}.physicspower_box.font_small .force_name_span_wrapper .force_name_quotation_mark{font-size:64px}.physicspower_box.font_small .force_tips_box .tips-ipt{font-size:64px}.physicspower_box.font_small .circle_name_span_wrapper .circle_name_f{font-size:64px}.physicspower_box.font_small .circle_name_span_wrapper .circle_name_num{font-size:45px}._panel{-webkit-transform-origin:0 0;width:500%;height:500%;transform-origin:0 0;position:absolute;left:0;top:0}.physicspower_main_box{background:url(resources/images/main_bg.png) repeat;width:100%;height:100%;border-radius:.41667em;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.physicspower_main_box .force_circle{box-sizing:content-box}.physicspower_main_box .icon_jt{font-family:iconfont!important}.physicspower_handle_tools{background:#cfdee9;position:absolute;bottom:0;left:0;right:0;z-index:1111;height:4.79167em;padding:0 4em;background:rgba(255,255,255,.25);text-align:center}.physicspower_handle_tools li{display:inline-block;vertical-align:top;margin:0 1.04167em;position:relative}.physicspower_handle_tools li.vertical_line{border-left:1px solid #bfcad2;border-right:1px solid #f8fafc;top:5%;position:relative;height:90%;margin:0 2.29167em}.physicspower_handle_tools li .tool_operate_bar{display:block;min-width:5em;text-align:center}.physicspower_handle_tools li .tool_operate_bar .tool_operate_imgcnt{display:block;width:100%;height:2.91667em}.physicspower_handle_tools li .tool_operate_bar .tool_operate_imgcnt:after{content:'';display:inline-block;width:0;height:100%;vertical-align:bottom}.physicspower_handle_tools li.handle_bg_btn{vertical-align:top;float:right;right:4.375em;cursor:pointer}.physicspower_handle_tools li.handle_bg_btn.click_disabled{color:#a9b6bf;cursor:default}.physicspower_handle_tools li.handle_bg_btn.click_disabled b{border:1px solid #a9b6bf}.physicspower_handle_tools li.handle_bg_btn.click_disabled.ui_btn_active b:after{background:#a9b6bf}.physicspower_handle_tools li.handle_bg_btn b{width:1.41667em;height:1.41667em;display:inline-block;vertical-align:middle;border:1px solid #10afb5;border-radius:100%;margin-right:.41667em;background:#fff;box-shadow:inset 0 1px 3px rgba(0,0,0,.5);position:relative}.physicspower_handle_tools li.handle_bg_btn.ui_btn_active b:after{position:absolute;left:50%;top:50%;margin-left:-.375em;margin-top:-.375em;content:"";width:.75em;height:.75em;overflow:hidden;border-radius:100%;background:#10afb5}.physicspower_handle_tools li.handle_bg_btn span{font-size:1.16667em;line-height:4.125em}.physicspower_compose_prompt{min-width:24.41667em;min-height:13.83333em;background-color:rgba(47,47,47,.8);position:absolute;left:50%;margin-left:-12.20833em;bottom:5em;border-radius:.41667em}.physicspower_compose_prompt:after{content:"";position:absolute;left:50%;top:100%;margin-left:-.41667em;width:0;height:0;border-left:.625em solid transparent;border-right:.625em solid transparent;border-top:.83333em solid rgba(47,47,47,.8)}.physicspower_compose_prompt .foot_group{position:absolute;bottom:2em;text-align:center;left:-45%;right:-45%}.physicspower_compose_prompt .foot_group .dia_btn{font-size:1.5em;display:inline-block;margin:.54167em .68333em 0;padding:0 1em;height:2.0555555em;line-height:2em;min-width:5.777777em;background:#f4f4f4;cursor:pointer;color:#384650;border:1px solid #397274;border-radius:.28em}.physicspower_compose_prompt .foot_group .dia_btn:active{background:#88c4c6;color:#fff}.physicspower_compose_prompt .foot_group .dia_btn.click_disabled{background:#c7d0d5;color:#969fa5;cursor:default}.physicspower_compose_prompt .con_detail{padding:1.5em 3.33333em 0;position:relative;text-align:center}.physicspower_compose_prompt .con_detail .tip_txt_wrap{display:inline-block;text-align:center}.physicspower_compose_prompt .con_detail .tip_choose_wrap{display:inline-block;text-align:center}.physicspower_compose_prompt .con_detail .tip_txt{color:#fff;font-size:1.5em;line-height:1.66667em}.physicspower_compose_prompt .con_detail .tip_choose{color:#fff;font-size:1.5em}.physicspower_compose_prompt .con_detail .tip_choose b{font-weight:400}.physicspower_compose_prompt .con_detail .tip_choose b.error{color:#f33333}.physicspower_compose_prompt .con_detail .tip_choose b.correct{color:#17e317}.physicspower_decompose_prompt{min-width:24.41667em;min-height:13.83333em;background-color:rgba(47,47,47,.8);position:absolute;left:50%;margin-left:-12.20833em;bottom:5em;border-radius:.41667em;text-align:left}.physicspower_decompose_prompt:after{content:"";position:absolute;left:50%;top:100%;margin-left:-.72917em;width:0;height:0;border-left:.625em solid transparent;border-right:.625em solid transparent;border-top:.83333em solid rgba(47,47,47,.8)}.physicspower_decompose_prompt .foot_group{position:absolute;bottom:2em;text-align:center;left:-45%;right:-45%}.physicspower_decompose_prompt .foot_group .dia_btn{font-size:1.5em;display:inline-block;margin:.54167em .68333em 0;padding:0 1em;height:2.0555555em;line-height:2em;min-width:5.777777em;background:#f4f4f4;cursor:pointer;color:#384650;border:1px solid #397274;border-radius:.28em}.physicspower_decompose_prompt .foot_group .dia_btn:active{background:#88c4c6;color:#fff}.physicspower_decompose_prompt .foot_group .dia_btn.click_disabled{background:#c7d0d5;color:#969fa5;cursor:default}.physicspower_decompose_prompt .con_detail{padding:1.5em 3.33333em 0;text-align:center}.physicspower_decompose_prompt .con_detail .tip_txt_wrap{display:inline-block;text-align:center}.physicspower_decompose_prompt .con_detail .tip_choose_wrap{display:inline-block;text-align:center}.physicspower_decompose_prompt .con_detail .tip_txt{color:#fff;font-size:1.5em;line-height:1.66667em}.physicspower_decompose_prompt .con_detail .tip_choose{color:#fff;font-size:1.5em}.physicspower_decompose_prompt .con_detail .tip_choose b{font-weight:400}.physicspower_decompose_prompt .con_detail .tip_choose b.error{color:#f33333}.physicspower_decompose_prompt .con_detail .tip_choose b.correct{color:#17e317}.physicspower_painting_handle{position:absolute}.physicspower_painting_handle a{float:left;width:3.83333em;height:2.5em;text-align:center;line-height:2.5em;color:#fff;position:relative}.physicspower_painting_handle a.confirm{background:#11b1b7;border-top-right-radius:.41667em;border-bottom-right-radius:.41667em}.physicspower_painting_handle a.confirm b{background:url(resources/images/half_arrow_green_down.png) no-repeat left top;left:0;background-size:100% 100%}.physicspower_painting_handle a.cancel{background:#eb6877;border-top-left-radius:.41667em;border-bottom-left-radius:.41667em}.physicspower_painting_handle a.cancel b{background:url(resources/images/half_arrow_red_down.png) no-repeat left top;right:0;background-size:100% 100%}.physicspower_painting_handle a b{width:.375em;height:.45833em;overflow:hidden;position:absolute;bottom:-.375em}.physicspower_dialog_confirm{width:24.41667em;height:13.83333em}.physicspower_dialog_confirm .tip_txt{margin-top:.83333em;font-size:1.5em;line-height:1.66667em}.physicspower_dialog_confirm .tip_txt b{line-height:1.45833em;font-weight:400}.physicspower_dialog_wrapper{position:absolute;left:50%;top:50%;-webkit-transform:translate(-50%,-50%);-ms-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%);z-index:99999999}.physicspower_dialog_wrapper .com_dialog_inner{display:table-cell;vertical-align:middle;text-align:center}.physicspower_dialog_wrapper .com_dialog_box{display:inline-block;background-color:rgba(47,47,47,.8);border-radius:.41667em;padding:1.66667em;color:#fff}.physicspower_dialog_wrapper .com_dialog_box .com_dialog_foot{position:absolute;bottom:2em;left:-45%;right:-45%;text-align:center}.physicspower_dialog_wrapper .com_dialog_box .com_dialog_foot .dia_btn{font-size:1.5em;display:inline-block;margin:.54167em 1.08333em 0;padding:0 1em;height:2.0555555em;line-height:2em;min-width:5.777777em;background:#f4f4f4;cursor:pointer;color:#384650;border:1px solid #397274;border-radius:.28em}.physicspower_dialog_wrapper .com_dialog_box .com_dialog_foot .dia_btn:active{background:#88c4c6;color:#fff}.physicspower_dialog_wrapper .com_dialog_box .com_dialog_foot .dia_btn.click_disabled{background:#c7d0d5;color:#969fa5;cursor:default}.physicspower_dialog_confirm_mask{left:0;top:0;position:absolute;width:100%;height:100%;background-color:rgba(0,0,0,.4);z-index:99999998;display:none;transition:all .5s}.physicspower_dialog_confirm_mask.show{display:block;opacity:1}.physicspower_main_box .force_circle{box-sizing:content-box}.physicspower_main_box .icon_jt{font-family:iconfont!important}.physicspower_main_box .co_origin{position:absolute;left:300px;top:290px}.physicspower_main_box .co_origin .x_positive,.physicspower_main_box .co_origin .x_reverse,.physicspower_main_box .co_origin .y_positive,.physicspower_main_box .co_origin .y_reverse{position:absolute;left:0;top:-1px;height:3px;background:#4d4d4d;color:#7d5827}.physicspower_main_box .co_origin .x_positive{width:355px}.physicspower_main_box .co_origin .x_positive .icon_jt{color:#4d4d4d;margin-top:-9px;left:100%;margin-left:-10px;position:absolute}.physicspower_main_box .co_origin .x_reverse{width:150px;left:0;top:2px;transform-origin:left top;-webkit-transform:rotate(-180deg);transform:rotate(-180deg)}.physicspower_main_box .co_origin .y_positive{width:225px;left:-1px;top:0;transform-origin:left top;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.physicspower_main_box .co_origin .y_positive .icon_jt{color:#4d4d4d;margin-top:-9px;position:absolute;left:100%;margin-left:-10px}.physicspower_main_box .co_origin .y_reverse{width:150px;left:2px;top:0;transform-origin:left top;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.physicspower_main_box .iconfont .icon_jt{font-size:22px;height:22px;line-height:22px}.physicspower_main_box .ph_force.ph_force_merge .force_line{border-top-width:8px!important;border-top-style:solid;margin-top:-4px}.physicspower_main_box .ph_force.ph_force_merge .icon_jt{font-size:22px!important}.physicspower_main_box .ph_force{height:12px;position:absolute;top:284px;transform-origin:left center}.physicspower_main_box .force_line{border-top:8px solid #2383cc;margin-top:-4px;position:absolute;top:50%;left:0;right:10px}.physicspower_main_box .ph_force .iconfont .icon_jt{color:#2383cc;right:-6px}.physicspower_main_box .force_circle{position:absolute;width:22px;height:22px;background:#fff;border:3px solid #1071c0;margin:-14px 0 0 -14px;border-radius:50%;cursor:pointer;z-index:996;box-sizing:content-box}.physicspower_main_box .force_circle.bg_solid{background:#1071c0}.physicspower_main_box .circle_name_box{height:64px;line-height:64px;position:absolute;text-align:center;margin-top:3px;z-index:990}.physicspower_main_box .circle_name_box_stu{height:64px;line-height:64px;position:absolute;text-align:center;margin-top:6px;z-index:990}.physicspower_main_box .circle_name_box_1{margin-left:-98px}.physicspower_main_box .circle_name_box_2{margin-left:-129px}.physicspower_main_box .circle_name_box_3{margin-left:-160px}.physicspower_main_box .circle_name_box_1_stu{margin-left:-75px}.physicspower_main_box .circle_name_box_2_stu{margin-left:-95px}.physicspower_main_box .circle_name_box_3_stu{margin-left:-118px}.physicspower_main_box .force_name_box{height:64px;line-height:64px;position:absolute;right:-80px;top:53px;text-align:left;width:180px}.physicspower_main_box .circle_name_span_wrapper .circle_name_f,.physicspower_main_box .force_name_span_wrapper .force_name_f{font-family:'Times New Roman';font-style:italic;display:inline-block;text-align:center;font-size:85px;padding:0;margin:0;height:100%;color:#4c4c4c;min-width:24px;cursor:pointer}.physicspower_main_box .circle_name_span_wrapper,.physicspower_main_box .force_name_span_wrapper{white-space:nowrap;display:inline-block;height:64px}.physicspower_main_box .circle_name_span_wrapper .circle_name_num,.physicspower_main_box .force_name_span_wrapper .force_name_num{font-family:'Times New Roman';display:inline-block;text-align:center;font-size:60px;padding:0;margin:0;height:100%;color:#4c4c4c;min-width:24px;cursor:pointer}.physicspower_main_box .circle_name_span_wrapper .force_name_quotation_mark,.physicspower_main_box .force_name_span_wrapper .force_name_quotation_mark{font-family:'Times New Roman';display:inline-block;text-align:center;font-size:85px;padding:0;margin:0;height:100%;color:#4c4c4c;min-width:24px;cursor:pointer}.physicspower_main_box .circle_name_box input.circle_name_span_wrapper,.physicspower_main_box .force_name_box input.force_name_span_wrapper{width:70px;padding:0;margin-left:0;border:1px solid #8a9ba5;-webkit-box-shadow:0 0 3px #8a9ba5 inset;box-shadow:0 0 3px #8a9ba5 inset;border-radius:6px;outline:0;display:none}.physicspower_main_box .circle_name_box input.circle_name_span_wrapper{margin-left:0;margin-top:10px}.physicspower_main_box .force_name_box input.force_name_span_wrapper{margin-left:0}.physicspower_main_box .circle_name_box.name_edit .circle_name_span_wrapper,.physicspower_main_box .force_name_box.name_edit .force_name_span_wrapper{display:none}.physicspower_main_box .circle_name_box.name_edit .force_tips_box,.physicspower_main_box .circle_name_box.name_edit input.circle_name_span_wrapper,.physicspower_main_box .force_name_box.name_edit .force_tips_box,.physicspower_main_box .force_name_box.name_edit input.force_name_span_wrapper{display:block}.physicspower_main_box .force_circle.circle_on{border-color:#c5532d;background:#fff;-webkit-animation:showbig .7s ease 0s forwards;animation:showbig .7s ease 0s forwards}.physicspower_main_box .force_circle:hover{border-color:#dc581f}.physicspower_main_box .force_drag{transition:transform .7s ease 0s;transform:scale(0);position:absolute;width:26px;height:26px;margin-top:-13px;margin-left:-13px;border-radius:50%;border:3px dotted #000;opacity:.7;cursor:pointer}.physicspower_main_box .drag_show{transform:scale(1);z-index:1000!important}.physicspower_main_box .force_drag.drag_on{-webkit-animation:startRotate 8s linear infinite;animation:startRotate 8s linear infinite}.physicspower_main_box .ph_force_on .force_line{border-top-color:#e06313!important}.physicspower_main_box .ph_force_on:before{content:"";background:#fff;height:10px;position:absolute;left:0;top:50%;width:99%;margin-top:-5px;right:10px;border-radius:0 4.16667em 4.16667em 0}.physicspower_main_box .ph_force_on .iconfont .icon_jt{color:#fff!important;margin-top:-8px;font-size:20px}.physicspower_main_box .ph_force_on .iconfont:after{position:absolute;right:-1px;top:50%;margin-top:-9px;font-size:20px;content:"\e613";color:#df4d14;font-family:iconfont}.physicspower_main_box .ph_force.dotted_line .force_line,.physicspower_main_box .ph_force.dotted_line .force_line:after{border-top-style:dashed;border-top-width:8px}.physicspower_main_box .line_dashed{z-index:3;height:2px;position:absolute;transform-origin:left center;width:100px}.physicspower_main_box .line_dashed .Aux_line{position:absolute;border-top:3px dashed #2383cc;left:0;right:0;top:50%;margin-top:-1px}.physicspower_main_box .force_tips_box{position:absolute;font-size:0;margin-top:-64px;margin-left:-50px;z-index:1100;display:block;left:-99999px;top:-99999px;white-space:nowrap}.physicspower_main_box .force_tips_box.box_show{display:block}.physicspower_main_box .force_tips_box .tips-ipt{width:160px;padding:0;border:1px solid #8a9ba5;-webkit-box-shadow:0 0 3px #8a9ba5 inset;box-shadow:0 0 3px #8a9ba5 inset;border-radius:6px;outline:0;font-family:'Times New Roman';font-style:italic;font-size:85px;text-align:center;left:50%;top:72px;margin-left:-80px;position:absolute}.physicspower_main_box .force_tips_box .tips_delete{font-size:24px;color:#fff;text-align:center;display:inline-block;height:52px;line-height:52px;padding:0 18px;background:#eb6877;position:relative;border-radius:6px 0 0 6px;text-decoration:none}.physicspower_main_box .force_tips_box .tips_delete:after{content:"";position:absolute;width:0;height:0;bottom:-9.33333px;right:0;border-left:18px solid transparent;border-top:16px solid #eb6877}.physicspower_main_box .force_tips_box .tips_delete:active{background:#be3f40}.physicspower_main_box .force_tips_box .tips_delete:active:after{border-top-color:#be3f40}.physicspower_main_box .force_tips_box .tips_ok{font-size:24px;text-align:center;color:#fff;display:inline-block;height:52px;line-height:52px;padding:0 18px;background:#11b1b7;position:relative;border-radius:0 6px 6px 0;text-decoration:none}.physicspower_main_box .force_tips_box .tips_ok:after{content:"";position:absolute;width:0;height:0;bottom:-9.33333px;left:0;border-right:18px solid transparent;border-top:16px solid #11b1b7}.physicspower_main_box .force_tips_box .tips_ok:active{background:#0ea2a8}.physicspower_main_box .force_tips_box .tips_ok:active:after{border-top-color:#0ea2a8}.physicspower_main_box .force_thin .force_line{border-top:2px solid #2383cc;margin-top:-1px}.physicspower_main_box .force_thin .iconfont .icon_jt{font-size:12px;transform:scale(.8);margin-top:-7.7px}.physicspower_main_box .force_thin.ph_force_on:before{height:4px;margin-top:-2px;right:10px}.physicspower_main_box .force_thin.ph_force_on .iconfont:after{right:1px;top:50%;margin-top:-6px;transform:scale(.8)}.physicspower_main_box .bg_translucent{opacity:.5}.physicspower_main_box .hand_type{cursor:pointer}.physicspower_main_box .force_circle.circle_vir{border:3px dotted #000;background:0 0!important}.physicspower_main_box .moving_state{display:none;content:"";position:absolute;left:50%;top:50%;margin:-55px 0 0 -55px;width:110px;height:110px}.physicspower_main_box .moving_state .circle_small{position:absolute;left:50%;top:50%;margin:-13px 0 0 -13px;width:24px;height:24px;border:1px solid #dc581f;opacity:.5;background:rgba(255,255,255,.1);border-radius:50%;-webkit-animation:zoomOff 1.8s linear infinite;animation:zoomOff 1.8s linear infinite}.physicspower_main_box .moving_state .circle_big{box-sizing:border-box;position:absolute;left:0;top:0;width:100%;height:100%;border:2px dotted #dc581f;opacity:.5;background:rgba(255,255,255,.3);border-radius:50%;-webkit-animation:startRotate 35s linear infinite;animation:startRotate 35s linear infinite}.physicspower_main_box .moving_state .arrows_box{display:block;height:100%;-webkit-animation:loopMove 2s linear infinite;animation:loopMove 2s linear infinite}.physicspower_main_box .moving_state .icon_x_pos,.physicspower_main_box .moving_state .icon_x_rev,.physicspower_main_box .moving_state .icon_y_pos,.physicspower_main_box .moving_state .icon_y_rev{position:absolute;width:10px;height:24px;background:url(resources/images/icon_drag_p.png) center center no-repeat;transform-origin:center bottom;background-size:auto 100%}.physicspower_main_box .moving_state .icon_x_pos{-webkit-transform:rotate(90deg) scale(.6);transform:rotate(90deg) scale(.6);right:0;top:50%;margin-top:-24px}.physicspower_main_box .moving_state .icon_x_rev{-webkit-transform:rotate(270deg) scale(.6);transform:rotate(270deg) scale(.6);left:0;top:50%;margin-top:-24px}.physicspower_main_box .moving_state .icon_y_pos{-webkit-transform:scale(.6);transform:scale(.6);left:49.5px;top:0;margin:-19px 0 0 0}.physicspower_main_box .moving_state .icon_y_rev{-webkit-transform:rotate(180deg) scale(.6);transform:rotate(180deg) scale(.6);left:50%;bottom:4.5px;margin-left:-5.5px}.physicspower_main_box .whole_drag .moving_state{display:block;-webkit-animation:showIn .7s ease 0s forwards;animation:showIn .7s ease 0s forwards}.physicspower_main_box .color_force_red .force_line{border-top-color:#cb1f1f;border-top-width:6px;margin-top:-3px;right:8px}.physicspower_main_box .color_force_red .iconfont .icon_jt{color:#cb1f1f;font-size:16px;height:16px;line-height:16px;right:-3px}.physicspower_main_box .color_force_red .force_arrow{right:-2px;height:16px;line-height:16px;margin-top:-8px;font-size:0}.physicspower_main_box .force_arrow{position:absolute;right:-3px;top:50%;height:22px;margin-top:-11px}.physicspower_main_box .color_force_green .force_line{border-top-color:#098918;border-top-width:6px;margin-top:-3px}.physicspower_main_box .color_force_green .iconfont .icon_jt{color:#098918;font-size:16px;height:16px;line-height:16px;right:-3px}.physicspower_main_box .color_force_green .force_arrow{right:0;height:16px;line-height:16px;margin-top:-8px;font-size:0}.physicspower_main_box .color_force_yellow .force_line{border-top-color:#ffe013;border-top-width:6px;margin-top:-3px;right:8px}.physicspower_main_box .color_force_yellow .iconfont .icon_jt{color:#ffe013;font-size:16px;height:16px;line-height:16px;right:-3px}.physicspower_main_box .color_force_yellow .force_arrow{right:-2px;height:16px;line-height:16px;margin-top:-8px;font-size:0}.physicspower_main_box .color_force_purple .force_line{border-top-color:#bc29fe;border-top-width:6px;margin-top:-3px;right:8px}.physicspower_main_box .color_force_purple .iconfont .icon_jt{color:#bc29fe;font-size:16px;height:16px;line-height:16px;right:-3px}.physicspower_main_box .color_force_purple .force_arrow{right:-2px;height:16px;line-height:16px;margin-top:-8px;font-size:0}.physicspower_main_box .color_force_red .Aux_line{border-top-color:#cb1f1f}.physicspower_main_box .color_force_green .Aux_line{border-top-color:#098918}.physicspower_main_box .color_force_yellow .Aux_line{border-top-color:#ffe013}.physicspower_main_box .color_force_purple .Aux_line{border-top-color:#bc29fe}.physicspower_main_box .z_index_top{z-index:1000!important}.physicspower_main_box .point_z_index_top{z-index:1002!important}.physicspower_main_box .panel *{box-sizing:content-box}.physicspower_main_box .quadrant_1_force_name{right:-136px;top:30px;text-align:left}.physicspower_main_box .quadrant_2_force_name{right:-117px;top:48px;text-align:left}.physicspower_main_box .quadrant_3_force_name{right:-102px;top:59px;text-align:left}.physicspower_main_box .quadrant_4_force_name{right:-96px;top:67px;text-align:left}.physicspower_main_box .quadrant_5_force_name{right:-97px;top:71px;text-align:left}.physicspower_main_box .quadrant_6_force_name{right:-95px;top:77px;text-align:left}.physicspower_main_box .quadrant_1_force_name_stu{right:-141px;top:18px;text-align:left}.physicspower_main_box .quadrant_2_force_name_stu{right:-129px;top:31px;text-align:left}.physicspower_main_box .quadrant_3_force_name_stu{right:-113px;top:49px;text-align:left}.physicspower_main_box .quadrant_4_force_name_stu{right:-107px;top:56px;text-align:left}.physicspower_main_box .quadrant_5_force_name_stu{right:-105px;top:68px;text-align:left}.physicspower_main_box .quadrant_6_force_name_stu{right:-95px;top:77px;text-align:left}.physicspower_main_box .quadrant_7_force_name{right:-134px;top:-35px;text-align:right}.physicspower_main_box .quadrant_8_force_name{right:-141px;top:-19px;text-align:right}.physicspower_main_box .quadrant_9_force_name{right:-134px;top:-1px;text-align:right}.physicspower_main_box .quadrant_10_force_name{right:-129px;top:-3px;text-align:right}.physicspower_main_box .quadrant_11_force_name{right:-113px;top:20px;text-align:right}.physicspower_main_box .quadrant_12_force_name{right:-82px;top:-80px;text-align:right}.physicspower_main_box .quadrant_7_force_name_stu{right:-142px;top:-44px;text-align:right}.physicspower_main_box .quadrant_8_force_name_stu{right:-141px;top:-31px;text-align:right}.physicspower_main_box .quadrant_9_force_name_stu{right:-140px;top:-18px;text-align:right}.physicspower_main_box .quadrant_10_force_name_stu{right:-134px;top:-3px;text-align:right}.physicspower_main_box .quadrant_11_force_name_stu{right:-137px;top:3px;text-align:right}.physicspower_main_box .quadrant_12_force_name_stu{right:-99px;top:-55px;text-align:right}.physicspower_main_box .quadrant_13_force_name{right:-135px;top:27px;text-align:left}.physicspower_main_box .quadrant_14_force_name{right:-145px;top:14px;text-align:left}.physicspower_main_box .quadrant_15_force_name{right:-153px;top:-17px;text-align:left}.physicspower_main_box .quadrant_16_force_name{right:-159px;top:-34px;text-align:left}.physicspower_main_box .quadrant_17_force_name{right:-150px;top:-59px;text-align:left}.physicspower_main_box .quadrant_18_force_name{right:-141px;top:-38px;text-align:left}.physicspower_main_box .quadrant_13_force_name_stu{right:-135px;top:-2px;text-align:left}.physicspower_main_box .quadrant_14_force_name_stu{right:-126px;top:-16px;text-align:left}.physicspower_main_box .quadrant_15_force_name_stu{right:-123px;top:-26px;text-align:left}.physicspower_main_box .quadrant_16_force_name_stu{right:-119px;top:-39px;text-align:left}.physicspower_main_box .quadrant_17_force_name_stu{right:-124px;top:-46px;text-align:left}.physicspower_main_box .quadrant_18_force_name_stu{right:-110px;top:-52px;text-align:left}.physicspower_main_box .quadrant_19_force_name{right:-131px;top:-9px;text-align:right}.physicspower_main_box .quadrant_20_force_name{right:-137px;top:-20px;text-align:right}.physicspower_main_box .quadrant_21_force_name{right:-137px;top:-28px;text-align:right}.physicspower_main_box .quadrant_22_force_name{right:-134px;top:-48px;text-align:right}.physicspower_main_box .quadrant_23_force_name{right:-124px;top:-59px;text-align:right}.physicspower_main_box .quadrant_24_force_name{right:-115px;top:-71px;text-align:right}.physicspower_main_box .quadrant_19_force_name_stu{right:-115px;top:-9px;text-align:right}.physicspower_main_box .quadrant_20_force_name_stu{right:-114px;top:-12px;text-align:right}.physicspower_main_box .quadrant_21_force_name_stu{right:-115px;top:-27px;text-align:right}.physicspower_main_box .quadrant_22_force_name_stu{right:-116px;top:-31px;text-align:right}.physicspower_main_box .quadrant_23_force_name_stu{right:-118px;top:-41px;text-align:right}.physicspower_main_box .quadrant_24_force_name_stu{right:-115px;top:-52px;text-align:right}.physicspower_main_box .quadrant_25_force_name{right:-81px;top:-130px;text-align:left}.physicspower_main_box .quadrant_26_force_name{right:-82px;top:79px;text-align:left}.physicspower_main_box .quadrant_27_force_name{right:-56px;top:24px;text-align:right}.physicspower_main_box .quadrant_28_force_name{right:-104px;top:-71px;text-align:right}.physicspower_main_box .quadrant_25_force_name_stu{right:-82px;top:-128px;text-align:left}.physicspower_main_box .quadrant_26_force_name_stu{right:-84px;top:75px;text-align:left}.physicspower_main_box .quadrant_27_force_name_stu{right:-50px;top:5px;text-align:right}.physicspower_main_box .quadrant_28_force_name_stu{right:-106px;top:-60px;text-align:right}.physicspower_main_box .reverse_circle_name_box{margin-left:8px}.physicspower_main_box .reverse_circle_name_box .force_tips_box{margin-left:-78px}.physicspower_main_box .reverse_circle_name_box input.circle_name{margin-left:-26px}.physicspower_main_box .circle_move_arrow{width:40px;height:40px;margin-left:-20px;margin-top:-20px;left:0;top:0;display:block;position:absolute;overflow:hidden;z-index:1002;background:url(resources/images/tool_zyd_normal.png) no-repeat center center;background-size:100% 100%}.physicspower_main_box .circle_move_arrow.active,.physicspower_main_box .circle_move_arrow:active,.physicspower_main_box .circle_move_arrow:hover{background:url(resources/images/tool_zyd_active.png) no-repeat center center;background-size:100% 100%}.physicspower_box{overflow:hidden}.physicspower_main_box{overflow:visible}.physicspower_main_box ._panel{z-index:1}.physicspower_main_box:before{content:"";position:absolute;left:-100%;top:100%;background:#bfd3e2;height:100%;width:300%;z-index:3}.physicspower_main_box:after{content:"";position:absolute;left:100%;top:-20%;background:#bfd3e2;height:140%;width:100%;z-index:3}.physicspower_main_mask:before{content:"";position:absolute;left:-50%;top:-100%;background:#bfd3e2;height:100%;width:200%;z-index:3}.physicspower_main_mask:after{content:"";position:absolute;left:-100%;top:-50%;background:#bfd3e2;height:200%;width:100%;z-index:3}.physicspower_main_box .force_drag{transform:scale(0) translateZ(0)}.physicspower_main_box .drag_show{transform:scale(1) translateZ(0)}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools{text-align:left;padding:0 4em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li{margin:0 .5em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_affectpoint.tool_operate_bar,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_compose.tool_operate_bar,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_decompose.tool_operate_bar,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_drawingforce.tool_operate_bar{min-width:6em;max-width:9.26667em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_affectpoint.tool_operate_bar .tool_operate_imgcnt,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_compose.tool_operate_bar .tool_operate_imgcnt,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_decompose.tool_operate_bar .tool_operate_imgcnt,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_drawingforce.tool_operate_bar .tool_operate_imgcnt{height:2.21667em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_affectpoint.tool_operate_bar .tool_operate_imgcnt .tool_operate_icon,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_compose.tool_operate_bar .tool_operate_imgcnt .tool_operate_icon,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_decompose.tool_operate_bar .tool_operate_imgcnt .tool_operate_icon,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_drawingforce.tool_operate_bar .tool_operate_imgcnt .tool_operate_icon{font-size:.7em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_affectpoint.tool_operate_bar .tool_operate_text,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_compose.tool_operate_bar .tool_operate_text,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_decompose.tool_operate_bar .tool_operate_text,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_drawingforce.tool_operate_bar .tool_operate_text{font-size:1.15em;margin-top:.51667em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_affectpoint.tool_operate_bar .tool_operate_text,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_drawingforce.tool_operate_bar .tool_operate_text{font-size:1em;margin-top:.11667em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_cancel.tool_operate_bar,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_empty.tool_operate_bar,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_recover.tool_operate_bar{width:5em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_cancel.tool_operate_bar .tool_operate_imgcnt,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_empty.tool_operate_bar .tool_operate_imgcnt,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_recover.tool_operate_bar .tool_operate_imgcnt{height:3.33333em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_cancel.tool_operate_bar .tool_operate_text,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_empty.tool_operate_bar .tool_operate_text,.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li .tool_recover.tool_operate_bar .tool_operate_text{display:none}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li.vertical_line{margin:0 1.50833em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li.handle_bg_btn{right:0;margin-top:1.2em;max-width:12em;margin-left:1em;max-width:12em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li.handle_bg_btn .com_radio_ui{padding-left:2.5em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li.handle_bg_btn .com_radio_ui_pic{position:absolute;top:50%;left:0;margin-top:-.70833em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li.handle_bg_btn b{position:absolute;top:50%;left:0;margin-top:-.70833em}.typefaces_ru_RU .exam_skin_wood .physicspower_handle_tools li.handle_bg_btn span{line-height:1}.typefaces_ru_RU .exam_skin_wood .physicspower_compose_prompt .con_detail,.typefaces_ru_RU .exam_skin_wood .physicspower_decompose_prompt .con_detail{padding:1em 1.5em 0}.typefaces_ru_RU .exam_skin_wood .physicspower_compose_prompt .con_detail .tip_choose,.typefaces_ru_RU .exam_skin_wood .physicspower_decompose_prompt .con_detail .tip_choose{line-height:1.66667em}.typefaces_ru_RU .exam_skin_wood .physicspower_compose_prompt .foot_group,.typefaces_ru_RU .exam_skin_wood .physicspower_decompose_prompt .foot_group{bottom:1.5em}.typefaces_ru_RU .exam_skin_wood .physicspower_compose_prompt{width:32em;margin-left:-16em}]]></css><view><![CDATA[<div class="exam_skin_wood" id="layout"><div class="physicspower_box _traverseParent"><div class="physicspower_main_box"><div class="_panel"><span class="circle_move_arrow _point_bodily_dragging_Btn"></span><div class="force_tips_box _del_confirm_btn"><a class="tips_delete _delete_btn" href="javascript:;"></a> <a class="tips_ok _confirm_btn" href="javascript:;"></a> <input class="force_name tips-ipt _name_input" name="" type="text"></div></div><div class="physicspower_main_mask"></div></div><ul class="physicspower_handle_tools"><li class="handle_bg_btn"><a href="javascript:;" class="com_radio_ui checked click_disabled _sliderRegion"><i class="com_radio_ui_pic _sliderCheckBox"></i> <span class="com_radio_ui_txt _physics_show_point"></span></a></li><li><a href="javascript:;" class="tool_operate_bar tool_affectpoint _drawFPBtn"><span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_zuolidian"></i></span><p class="tool_operate_text _physics_point"></p></a></li><li><a href="javascript:;" class="tool_operate_bar tool_drawingforce _drawFBtn"><span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_huali"></i></span><p class="tool_operate_text _physics_draw_force"></p></a></li><li><a href="javascript:;" class="tool_operate_bar tool_compose disabled _compoundBtn"><i></i> <span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_hecheng"></i></span><p class="tool_operate_text _physics_compound"></p></a><div class="physicspower_compose_prompt _compoundPopupWindow"><div class="foot_group"><a href="#" class="dia_btn disabled _compoundConfirmBtn"></a> <a href="#" class="dia_btn _compoundCancelBtn"></a></div><div class="con_detail"><div class="tip_txt_wrap"><p class="tip_txt _physics_choose_compound"></p></div><div class="tip_choose_wrap"><p class="tip_choose"><span class="_physics_choosed_first_half"></span> <b class="error _fCompoundNum"></b> <span class="_physics_compound_lower_half"></span></p></div></div></div></li><li><a href="javascript:;" class="tool_operate_bar tool_decompose _decomposeBtn"><span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_fenjie"></i></span><p class="tool_operate_text _physics_decompose"></p></a><div class="physicspower_decompose_prompt _decomposePopupWindow"><div class="foot_group"><a href="#" class="dia_btn click_disabled _decomposeConfirmBtn"></a> <a href="#" class="dia_btn _decomposeCancelBtn"></a></div><div class="con_detail"><div class="tip_txt_wrap"><p class="tip_txt _physics_choose_decompose"></p></div><div class="tip_choose_wrap"><p class="tip_choose"><span class="_physics_choosed_first_half"></span> <b class="error _fDecomposeNum"></b> <span class="_physics_decompose_lower_half"></span></p></div></div></div></li><li class="vertical_line"></li><li><a href="javascript:;" class="tool_operate_bar tool_cancel _undoBtn"><span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_cexiao"></i></span><p class="tool_operate_text _physics_undo"></p></a></li><li><a href="javascript:;" class="tool_operate_bar tool_recover _redoBtn"><span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_restore"></i></span><p class="tool_operate_text _physics_redo"></p></a></li><li><a href="javascript:;" class="tool_operate_bar tool_empty _clearUpBtn"><span class="tool_operate_imgcnt"><i class="tool_operate_icon tool_empty"></i></span><p class="tool_operate_text _physics_clean"></p></a></li></ul><div class="physicspower_dialog_confirm_mask _mask_layer"></div><div class="physicspower_dialog_wrapper _cleanUpPopupWindow"><div class="com_dialog_inner"><div class="com_dialog_box physicspower_dialog_confirm"><div class="tip_txt _physics_clean_confirm"></div><div class="com_dialog_foot"><a href="#" class="dia_btn _cleanUpConfirmBtn"></a> <a href="#" class="dia_btn _cleanUpCancelBtn"></a></div></div></div></div></div></div>]]></view><presenter><![CDATA["use strict";

(function () {
    // 缓存不同分辨率下的缩放比，默认是1920*1200下的不缩放，所以默认缩放比为1
    var scaleRatio = 1;

    // 标识是否是学生端，true：学生端，false：101ppt or 白板端
    var isStudent = false;

    // 学生端记录老师端的面板状态
    var panelState;

    // 国际化处理
    var i18nHelper = {
        isRendered: false,
        lanKeySet: null,
        ERROR: "ERROR",
        getLocalTxt: function getLocalTxt(key) {
            if (this.lanKeySet) {
                if (this.lanKeySet[key] === undefined) return 'ERROR';
                return this.lanKeySet[key];
            }
            return "null";
        },
        renderDelConfirmBtn: function renderDelConfirmBtn() {
            if (!this.isRendered) {
                this.isRendered = true;
                $delConfirmBtn.show();
                var maxWidth = $deleteBtn.outerWidth() > $confirmBtn.outerWidth() ? $deleteBtn.outerWidth() : $confirmBtn.outerWidth();
                $delConfirmBtn.css({
                    "width": maxWidth * 2,
                    "margin-left": -parseFloat(maxWidth)
                });
                $deleteBtn.css({
                    "width": maxWidth
                });
                $confirmBtn.css({
                    "width": maxWidth
                });
                $delConfirmBtn.hide();
            }
        }
    };

    // 边界控制参数常量
    var PANEL_BORDER = {};
    var BODILY_DRAG_SIZE = {
        OFFSET_X: 20 + 7 + 7
    };

    var TAG = {
        'CREATE_CONCURRENT_F': 0,
        'CREATE_F_OR_FP': 1,
        'DRAG_F_OR_FP': 2
    };

    // 样式类名
    var STYLE_CLASS = {
        UI_ACTIVE: "ui_btn_active",
        CHECKED: 'checked',
        UI_DISABLED: "click_disabled",
        UI_CORRECT: "correct",
        UI_ERROR: "error"
    };

    /**
     * 记录老师端工具栏的状态
     * 不包括撤销、恢复、清空按钮的状态（这三个按钮学生端不同步推送）
     * 对象名字对应按钮，
     * true：表示被选中，
     * false：默认值，没有被选中
     * @type {{}}
     */
    var toolBarState = {};

    // 校验创建的 力 or 作用点 or 共点力 单例
    var CreationOperationVerification = {
        /**
         * 校验是否成功创建 力 || 作用点
         * @param args
         */
        verifyFOrFPCreation: function verifyFOrFPCreation(args) {
            // 当前面板处于可绘制作用点的状态
            if (currentPanelState == STATE.CAN_DRAW_FP) {
                if (Utils.calDistance(args.downPos.x, args.downPos.y, args.upPos.x, args.upPos.y) > 10) {
                    // 创建作用点失败,销毁作用点
                    args.actionPoint.structurallyDestroy();
                } else {
                    // 创建作用点成功
                    nameIndexManager.add(args.actionPoint.getNameChar(), args.actionPoint.getIdx());
                    args.actionPoint.setVirtual(false);
                    handler.sendMessage({
                        identify: MESSAGE.ADD_POINT,
                        target: args.actionPoint
                    });
                }
            }

            // 当前面板处于可绘制力的状态
            if (currentPanelState == STATE.CAN_DRAW_F) {
                var dis = Utils.calDistance(args.downPos.x, args.downPos.y, args.upPos.x, args.upPos.y);
                if (dis > 26) {
                    // 创建力成功
                    nameIndexManager.add(args.tmpF.getNameChar(), args.tmpF.getIdx());
                    if (args.tmpF) {
                        args.tmpF.setVirtual(false); // 设置为真实的力
                        args.tmpF.possessActionPoint(possessActionPoint); // 设置力是否有作用点
                    }
                    if (!possessActionPoint) {
                        // 无作用点，保持虚拟状态
                        args.actionPoint.setName({
                            name: " ",
                            idx: " "
                        });
                    }
                    // 在FPoint.hideSelf中执行了nameIndexManager.add(args.actionPoint.getNameChar(), args.actionPoint.getIdx());
                    //else {
                    //    nameIndexManager.add(args.actionPoint.getNameChar(), args.actionPoint.getIdx());
                    //}
                    handler.sendMessage({
                        identify: MESSAGE.ADD_FORCE_WITH_POINT,
                        target: args.tmpF
                    });
                } else {
                    // 销毁作用点和力
                    args.actionPoint.structurallyDestroy(); // 点 与 力 已经绑定在一起了，删除点连带删除力，删除力也会连带删除虚拟作用点
                }
            }
        },
        /**
         * 校验是否成功创建 共点力
         * @param args
         */
        verifyConcurrentForcesCreation: function verifyConcurrentForcesCreation(args) {
            if (args.concurrentForce) {
                // 已经创建了临时的共点力对象了
                if (Utils.calDistance(args.fPRef.x, args.fPRef.y, args.pos.x, args.pos.y) > 26) {
                    // 创建共点力成功
                    nameIndexManager.add(args.concurrentForce.getNameChar(), args.concurrentForce.getIdx());
                    args.concurrentForce.setVirtual(false);
                    Consult.askMeetFCFDCondition();
                    // 记录用户的一次创建操作
                    handler.sendMessage({
                        identify: MESSAGE.ADD_CONCURRENT_FORCE,
                        target: args.concurrentForce
                    });
                } else {
                    // 创建共点力失败，解除作用点的关联
                    args.fPRef.unbindConcurrentForce(args.concurrentForce);
                    // 结构式销毁力视图
                    args.concurrentForce.structurallyDestroy();
                }
            }
        }
    };

    /**
     * 工具类方法
     */
    var Utils = {
        getEvent: function getEvent(event) {
            // 获取event对象
            return event ? event : window.event;
        },
        preventDefault: function preventDefault(event) {
            //阻止浏览器默认行为
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        },
        stopPropagation: function stopPropagation(event) {
            //阻止事件冒泡
            if (event.stopPropagation) {
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        },
        conversionCursorPos: function conversionCursorPos(event, $container) {
            // 换算鼠标位置
            var pageX, pageY;
            if (event.clientX) {
                // pc端
                pageX = event.clientX;
                pageY = event.clientY;
            } else {
                // 移动端
                if (!event.originalEvent.targetTouches[0]) {
                    // touchend事件
                    pageX = event.originalEvent.changedTouches[0].pageX;
                    pageY = event.originalEvent.changedTouches[0].pageY;
                } else {
                    // touchmove事件
                    pageX = event.originalEvent.targetTouches[0].pageX;
                    pageY = event.originalEvent.targetTouches[0].pageY;
                }
            }
            return {
                x: (pageX - $container.offset().left) / scaleRatio,
                y: (pageY - $container.offset().top) / scaleRatio
            };
        },
        calDegree: function calDegree(x1, y1, x2, y2) {
            // 计算线段与水平线的夹角
            var dis = Utils.calDistance(x1, y1, x2, y2);
            var cos = Math.abs(x2 - x1) / dis;
            var degree = Math.acos(cos) * 180 / Math.PI;
            if (x1 < x2) {
                if (y1 > y2) {
                    //逆时针旋转
                    degree = -degree;
                }
            } else {
                degree = y1 < y2 ? 180 - degree : -(180 - degree);
            }
            return degree;
        },
        calDistance: function calDistance(x1, y1, x2, y2) {
            // 计算两点之间的距离
            var disX = Math.abs(x1 - x2);
            var disY = Math.abs(y1 - y2);
            return Math.pow(disX * disX + disY * disY, 0.5);
        },
        generateGeneralUUID: function (uuidRegEx, uuidReplacer) {
            return function () {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
            };
        }(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0,
                v = c == "x" ? r : r & 3 | 8;
            return v.toString(16);
        }),
        set2GreyState: function set2GreyState($node, state) {
            if (state) {
                if ($node.hasClass(STYLE_CLASS.UI_DISABLED)) return;
                $node.addClass(STYLE_CLASS.UI_DISABLED);
            } else {
                if ($node.hasClass(STYLE_CLASS.UI_DISABLED)) $node.removeClass(STYLE_CLASS.UI_DISABLED);
            }
        },
        set2CorrectState: function set2CorrectState($node, state) {
            if (state) {
                if ($node.hasClass(STYLE_CLASS.UI_CORRECT)) return;
                if ($node.hasClass(STYLE_CLASS.UI_ERROR)) $node.removeClass(STYLE_CLASS.UI_ERROR);
                $node.addClass(STYLE_CLASS.UI_CORRECT);
            } else {
                if ($node.hasClass(STYLE_CLASS.UI_ERROR)) return;
                if ($node.hasClass(STYLE_CLASS.UI_CORRECT)) $node.removeClass(STYLE_CLASS.UI_CORRECT);
                $node.addClass(STYLE_CLASS.UI_ERROR);
            }
        },
        set2ActiveState: function set2ActiveState($node, state) {
            if (state) {
                if ($node.hasClass(STYLE_CLASS.UI_ACTIVE)) return;
                $node.addClass(STYLE_CLASS.UI_ACTIVE);
            } else {
                if ($node.hasClass(STYLE_CLASS.UI_ACTIVE)) $node.removeClass(STYLE_CLASS.UI_ACTIVE);
            }
            // 针对绘制作用点按钮、绘制力按钮、合成按钮、分解按钮，这四个按钮设置同步的状态
            if ($.hasData($node)) {
                var tag = $.data($node, 'tag');
                if (tag) {
                    toolBarState[tag] = state;
                }
            }
        },
        set2PenetrateState: function set2PenetrateState(nodes, state) {
            // 设置节点状态为事件穿透
            if (state) {
                for (var i = 0; i < nodes.length; ++i) {
                    nodes[i].css({
                        "pointer-events": "none"
                    });
                }
            } else {
                for (var j = 0; j < nodes.length; ++j) {
                    nodes[j].css({
                        "pointer-events": "auto"
                    });
                }
            }
        },
        setText: function setText($node, txt) {
            $node.text("" + txt);
        },
        turnOffBodilyDraggingState: function turnOffBodilyDraggingState() {
            if (currentHandledPoint) {
                if (currentHandledPoint.isUnderBodilyDragging) {
                    currentHandledPoint.set2BodilyDraggingState(false);
                }
            }
        },
        applyBorderCtrl: function applyBorderCtrl(args) {
            if (args.movePos && (args.movePos.x >= PANEL_BORDER.RIGHT || args.movePos.x <= PANEL_BORDER.LEFT || args.movePos.y >= PANEL_BORDER.BOTTOM || args.movePos.y <= PANEL_BORDER.TOP)) {
                $panel.off("mousemove touchmove");
                $panel.off("touchend mouseup");

                switch (args.tag) {
                    case TAG.CREATE_F_OR_FP:
                        CreationOperationVerification.verifyFOrFPCreation({
                            'actionPoint': args.fPRef,
                            'tmpF': args.fRef,
                            'upPos': args.movePos,
                            'downPos': args.downPos,
                            'alreadyNewF': args.alreadyNewF
                        });
                        break;
                    case TAG.CREATE_CONCURRENT_F:
                        CreationOperationVerification.verifyConcurrentForcesCreation({
                            'fPRef': args.fPRef,
                            'pos': args.movePos,
                            'concurrentForce': args.concurrentForce,
                            'hasCreateConcurrentForceView': args.hasCreateConcurrentForceView
                        });
                        break;
                    case TAG.DRAG_F_OR_FP:
                        if (args.fRef) {
                            args.fRef.resetView2Normal();
                        }
                        if (args.fPRef) {
                            if (args.fPRef.view.$force_circle.hasClass("whole_drag")) {
                                args.fPRef.view.$force_circle.removeClass("whole_drag");
                            }
                        }
                        break;
                }

                Utils.set2PenetrateState([$compoundPopupWindow, $decomposePopupWindow], false);

                if (currentHandledPoint) {
                    if (currentHandledPoint.x < PANEL_BORDER.CENTER) {
                        $pointBodilyDraggingBtn.css({
                            left: currentHandledPoint.x + BODILY_DRAG_SIZE.OFFSET_X,
                            top: currentHandledPoint.y
                        });
                    } else {
                        $pointBodilyDraggingBtn.css({
                            left: currentHandledPoint.x - BODILY_DRAG_SIZE.OFFSET_X,
                            top: currentHandledPoint.y
                        });
                    }
                }

                return true;
            }
            return false;
        }
    };

    /**
     * 视图控件声明
     */
    var $traverseParent, $panel, // 展示力的面板
    $btnUndo, // 撤销 && 恢复 按钮
    $btnRedo, $btnDrawFP, // 画作用点
    $btnDrawF, // 画作用力
    $btnFCompound, // 力的合成
    $compoundPopupWindow, // 合成按钮对应的底部弹出框
    $compoundPWCancel, $compoundFMarkedSpan, // 已经选择的需要合成的力的数量
    $compoundPWConfirm, $decomposeFMarkedSpan, // 已经选择的需要分解的力的数量
    $btnFDecompose, // 力的分解
    $decomposePopupWindow, // 分解按钮对应的底部弹出框
    $decomposePWConfirm, $decomposePWCancel, $btnCleanUp, // 清空按钮
    $maskLayer, $cleanUpPopupWindow, // 清除按钮对应的居中弹出框
    $cleanUpPWConfirm, // 弹窗的“确定”按钮
    $cleanUpPWCancel, // 弹窗的“取消”按钮
    $sliderRegion, $pointBodilyDraggingBtn, // 作用点移动拖动按钮单例视图
    $delConfirmBtn, //作用点和力的编辑删除确认按钮
    $deleteBtn, $confirmBtn, $nameInput;

    var preHandledObj = null,
        // 记录之前被操作的对象
    currentHandledPoint = undefined,
        // 缓存上一次操作的作用点
    possessActionPoint = true; // 标识力是否有作用点 true：有作用点，false：无作用点

    // 国际化处理
    var i18nRender = function i18nRender() {
        $btnDrawFP.find("p._physics_point").html(i18nHelper.getLocalTxt("physics_point"));
        $btnDrawF.find("p._physics_draw_force").html(i18nHelper.getLocalTxt("physics_draw_force"));
        $btnFCompound.find("p._physics_compound").html(i18nHelper.getLocalTxt("physics_compound"));
        $btnFDecompose.find("p._physics_decompose").html(i18nHelper.getLocalTxt("physics_decompose"));
        $btnUndo.find("p._physics_undo").html(i18nHelper.getLocalTxt("physics_undo"));
        $btnRedo.find("p._physics_redo").html(i18nHelper.getLocalTxt("physics_redo"));
        $btnCleanUp.find("p._physics_clean").html(i18nHelper.getLocalTxt("physics_clean"));
        $sliderRegion.find("span._physics_show_point").html(i18nHelper.getLocalTxt("physics_show_point"));

        $compoundPopupWindow.find("p._physics_choose_compound").html(i18nHelper.getLocalTxt("physics_choose_compound"));
        $compoundPopupWindow.find("span._physics_choosed_first_half").html(i18nHelper.getLocalTxt("physics_choosed_first_half"));
        $compoundPopupWindow.find("span._physics_compound_lower_half").html(i18nHelper.getLocalTxt("physics_compound_lower_half"));
        $compoundPWConfirm.text(i18nHelper.getLocalTxt("physics_confirm"));
        $compoundPWCancel.text(i18nHelper.getLocalTxt("physics_cancel"));

        $decomposePopupWindow.find("p._physics_choose_decompose").html(i18nHelper.getLocalTxt("physics_choose_decompose"));
        $decomposePopupWindow.find("span._physics_choosed_first_half").html(i18nHelper.getLocalTxt("physics_choosed_first_half"));
        $decomposePopupWindow.find("span._physics_decompose_lower_half").html(i18nHelper.getLocalTxt("physics_decompose_lower_half"));
        $decomposePWCancel.text(i18nHelper.getLocalTxt("physics_cancel"));
        $decomposePWConfirm.text(i18nHelper.getLocalTxt("physics_confirm"));

        $cleanUpPopupWindow.find("div._physics_clean_confirm").html(i18nHelper.getLocalTxt("physics_clean_confirm"));
        $cleanUpPWConfirm.text(i18nHelper.getLocalTxt("physics_confirm"));
        $cleanUpPWCancel.text(i18nHelper.getLocalTxt("physics_cancel"));

        $deleteBtn.html(i18nHelper.getLocalTxt("physics_delete"));
        $confirmBtn.html(i18nHelper.getLocalTxt("physics_confirm"));
    };

    /**
     * 视图控件初始化
     */
    var findView = function findView() {
        $traverseParent = $("div._traverseParent");
        // 老师端测试学生端字体后门
        //isStudent ? $traverseParent.addClass('font_small') : "";
        $panel = $traverseParent.find("div._panel");
        $pointBodilyDraggingBtn = $panel.find("span._point_bodily_dragging_Btn");
        $pointBodilyDraggingBtn.hide();

        $delConfirmBtn = $panel.find("div._del_confirm_btn");
        $deleteBtn = $delConfirmBtn.find("a._delete_btn");
        $confirmBtn = $delConfirmBtn.find("a._confirm_btn");
        $nameInput = $delConfirmBtn.find("input._name_input");

        $btnDrawFP = $traverseParent.find("a._drawFPBtn");
        $btnDrawF = $traverseParent.find("a._drawFBtn");
        $btnFCompound = $traverseParent.find("a._compoundBtn");
        $btnFDecompose = $traverseParent.find("a._decomposeBtn");
        Utils.set2GreyState($btnFCompound, true);
        Utils.set2GreyState($btnFDecompose, true);

        $.data($btnDrawFP, 'tag', 'btnDrawFP');
        $.data($btnDrawF, 'tag', 'btnDrawF');
        $.data($btnFCompound, 'tag', 'btnFCompound');
        $.data($btnFDecompose, 'tag', 'btnFDecompose');

        $btnUndo = $traverseParent.find("a._undoBtn"); // 撤销
        $btnRedo = $traverseParent.find("a._redoBtn"); // 还原
        $btnCleanUp = $traverseParent.find("a._clearUpBtn");
        Utils.set2GreyState($btnUndo, true);
        Utils.set2GreyState($btnRedo, true);
        Utils.set2GreyState($btnCleanUp, true);

        $sliderRegion = $traverseParent.find("a._sliderRegion");
        Utils.set2GreyState($sliderRegion, true);
        $sliderRegion.addClass(STYLE_CLASS.CHECKED);

        // 清空弹窗
        $maskLayer = $traverseParent.find("div._mask_layer");
        $cleanUpPopupWindow = $traverseParent.find("div._cleanUpPopupWindow");
        $cleanUpPWConfirm = $traverseParent.find("a._cleanUpConfirmBtn");
        $cleanUpPWCancel = $traverseParent.find("a._cleanUpCancelBtn");
        $cleanUpPopupWindow.hide();

        // 合成弹窗
        $compoundPopupWindow = $traverseParent.find("div._compoundPopupWindow");
        $compoundPWConfirm = $traverseParent.find("a._compoundConfirmBtn");
        $compoundPWCancel = $traverseParent.find("a._compoundCancelBtn");
        $compoundFMarkedSpan = $traverseParent.find("b._fCompoundNum");
        $compoundPopupWindow.hide();

        // 分解弹窗
        $decomposePopupWindow = $traverseParent.find("div._decomposePopupWindow");
        $decomposeFMarkedSpan = $traverseParent.find("b._fDecomposeNum");
        $decomposePWCancel = $traverseParent.find("a._decomposeCancelBtn");
        $decomposePWConfirm = $traverseParent.find("a._decomposeConfirmBtn");
        $decomposePopupWindow.hide();

        $panel.css({
            "cursor": "pointer" //设置鼠标进入面板样式
        });

        i18nRender();

        // 老师测试推送后门
        //var $syncDataBtn = $('._syncData');
        //var $drawSyncDataBtn = $('._drawSyncData');
        //var dataNeedSync;
        //$syncDataBtn.on('mousedown', function () {
        //    dataNeedSync = PhysicsSynthesis.updateSyncData();
        //});
        //$drawSyncDataBtn.on('mousedown', function () {
        //    PhysicsSynthesis.renderSyncData(dataNeedSync);
        //});

        // 根据当前设备的分辨率计算缩放比（目前都是以1920*1200基础上计算缩放比，即：1920*1200的缩放比为1）
        scaleRatio = ($('#PhysicsPower').width() / 1920).toFixed(2);

        // 根据缩放比进行缩放
        $panel[0].style.webkitTransform = "scale(" + scaleRatio + ")";

        i18nHelper.isRendered = false;
    };

    /**
     * 状态机,标识当前面板处于的状态 以及状态的切换
     */
    var STATE = {
        CAN_DRAW_FP: 0, //可绘制作用点
        CAN_DRAW_F: 1, //可绘制力
        CAN_DO_FC: 2, //可合成力
        CAN_DO_FD: 3, //可分解力
        IDLE: -1 //面板闲置
    },
        currentPanelState = STATE.IDLE; // 标识面板当前的状态

    /**
     * 场景类型
     */
    var SCENE_TYPE = {
        FC: 1, // 合成场景
        FD: -1 //分解场景
    };

    var COLOR = ["color_force_red", "color_force_green", "color_force_yellow", "color_force_purple"];

    /**
     * 业务类方法集合
     */
    var PhysicsSynthesis = {
        cleanUpPanel: function cleanUpPanel() {
            // 清空面板
            // 控制是否重置撤销恢复栈
            var isEmptyUndoRedoStack = true;
            if (arguments.length === 1 && typeof arguments[0] === 'boolean') {
                isEmptyUndoRedoStack = arguments[0];
            }

            if ($cleanUpPopupWindow) {
                $cleanUpPopupWindow.hide();
            }
            if ($maskLayer.hasClass("show")) {
                $maskLayer.removeClass("show");
            }
            // 可以清空
            if (panelContainer && panelContainer.size()) {
                if (nameIndexManager) {
                    nameIndexManager.empty();
                }
                var point;
                while (panelContainer.size()) {
                    point = panelContainer._array.shift();
                    if (point) {
                        point.structurallyDestroy();
                    }
                }
            }

            // 重置容器对象
            if (cdQ && cdQ._array.length) {
                cdQ.empty();
            }

            // 是否强制清空撤销回退栈
            if (isEmptyUndoRedoStack) {
                if (undoStack && undoStack._array.length) {
                    undoStack.empty();
                }
                if (redoStack && redoStack._array.length) {
                    redoStack.empty();
                }
            }

            // 重置名字下标管理器
            if (nameIndexManager) {
                nameIndexManager.empty();
            }

            preHandledObj = null;
            $delConfirmBtn.hide();
            Consult.askMeetCleanUPCondition();
            Consult.askMeetFCFDCondition();
        },
        doFCompound: function doFCompound(concurrentForces) {
            if (concurrentForces && concurrentForces.length > 1) {
                // 至少有两个合力
                var f1,
                    f2,
                    fCompound,
                    fCompoundData,
                    fc_x,
                    fc_y,
                    dashLine1,
                    dashLine2,
                    attrDashLine1,
                    attrDashLine2,
                    scene,
                    // 场景对象
                compoundScene = {}; // 记录用户的一次合成操作

                // 先判断作用点是否已经有场景了
                if (concurrentForces[0].actionPoint) {
                    if (concurrentForces[0].actionPoint.scene) {
                        compoundScene.destroyedScene = concurrentForces[0].actionPoint.scene;
                        concurrentForces[0].actionPoint.scene.logicallyDestroy();
                    }
                }

                // 退出编辑态
                if (concurrentForces[0].actionPoint) {
                    if (concurrentForces[0].actionPoint.isShowForceTipsBox) {
                        concurrentForces[0].actionPoint._toggleForceTipsBox();
                    }
                }

                // 作用点绑定场景信息
                scene = new Scene({
                    associatedPoint: concurrentForces[0].actionPoint,
                    type: SCENE_TYPE.FC
                });
                scene.associatedPoint.bindScene(scene);

                compoundScene.scene = scene;

                while (concurrentForces.length > 1) {
                    f1 = concurrentForces.shift();
                    f2 = concurrentForces.shift();

                    // 退出编辑态
                    if (f1.isShowForceTipsBox) {
                        f1._toggleForceTipsBox();
                    }
                    if (f2.isShowForceTipsBox) {
                        f2._toggleForceTipsBox();
                    }

                    // 非选中状态
                    if (f1.isSelected) {
                        f1._toggleFSelectState();
                    }
                    if (f2.isSelected) {
                        f2._toggleFSelectState();
                    }

                    // 生成一个合成场景

                    //生成合力
                    fc_x = f1.x2 + f2.x2 - f2.x1;
                    fc_y = f1.y2 + f2.y2 - f2.y1;
                    fCompoundData = {
                        x1: f2.x1,
                        y1: f2.y1,
                        x2: fc_x,
                        y2: fc_y,
                        color: "color_force_red",
                        nameChar: "F",
                        panel: $panel,
                        isCompound: true, //标志为合力
                        isAssistant: true // 标志为辅助力
                    };
                    if (concurrentForces.length == 0) {
                        // 为最终合力
                        fCompoundData.isDotted = false;
                        fCompoundData.idx = "";
                    } else {
                        // 为临时的合力
                        fCompoundData.isDotted = true;
                        fCompoundData.idx = nameIndexManager.generateIdx('F');
                        nameIndexManager.add('F', fCompoundData.idx);
                    }
                    fCompound = new F(fCompoundData);
                    concurrentForces.unshift(fCompound);

                    // 生成辅助线
                    attrDashLine1 = {
                        x1: f1.x2,
                        y1: f1.y2,
                        x2: fc_x,
                        y2: fc_y
                    };
                    attrDashLine2 = {
                        x1: f2.x2,
                        y1: f2.y2,
                        x2: fc_x,
                        y2: fc_y
                    };
                    if (concurrentForces.length == 1) {
                        // 为合力
                        attrDashLine1.isTranslucent = false;
                        attrDashLine2.isTranslucent = false;
                    }
                    dashLine1 = new DashLine(attrDashLine1);
                    dashLine2 = new DashLine(attrDashLine2);

                    // 记录合力信息
                    scene.recordJoinForce(fCompound);
                    // 记录辅助线
                    scene.recordAuxiliaryLine(dashLine1);
                    scene.recordAuxiliaryLine(dashLine2);
                }
                return compoundScene;
            } else {
                // 切换回未选中状态
                if (concurrentForces[0].isSelected) concurrentForces[0]._toggleFSelectState();
                // 退出编辑态
                if (concurrentForces[0].isShowForceTipsBox) {
                    concurrentForces[0]._toggleForceTipsBox();
                }
                if (concurrentForces[0].actionPoint) {
                    if (concurrentForces[0].actionPoint.isShowForceTipsBox) {
                        concurrentForces[0].actionPoint._toggleForceTipsBox();
                    }
                }
                return null;
            }
        },
        doFDecompose: function doFDecompose(concurrentForces) {
            if (concurrentForces && concurrentForces.length) {
                var fCompound,
                    // 待分解的合力
                attrCoordinates,
                    // 坐标轴
                coordinates,
                    f1,
                    //两个分力
                f1Data,
                    f2,
                    f2Data,
                    dashLine1,
                    // 两条辅助线
                attrDashLine1,
                    dashLine2,
                    attrDashLine2,
                    scene,
                    // 场景对象
                clrIdx = -1,
                    // 颜色下标
                xPositiveLenMax = 90,
                    //设置坐标轴的长度
                xNegativeLenMax = 90,
                    yPositiveLenMax = 90,
                    yNegativeLenMax = 90,
                    currentXPositiveLen,
                    currentYPositiveLen,
                    currentXReverseLen,
                    currentYReverseLen,
                    decomposeScene = {}; // 记录用户的一次合成操作

                // 先判断作用点是否已经有场景了
                if (concurrentForces[0].actionPoint) {
                    if (concurrentForces[0].actionPoint.scene) {
                        decomposeScene.destroyedScene = concurrentForces[0].actionPoint.scene;
                        concurrentForces[0].actionPoint.scene.logicallyDestroy();
                    }
                }

                // 作用点退出编辑态
                if (concurrentForces[0].actionPoint) {
                    if (concurrentForces[0].actionPoint.isShowForceTipsBox) {
                        concurrentForces[0].actionPoint._toggleForceTipsBox();
                    }
                }

                // 绑定场景信息
                scene = new Scene({
                    associatedPoint: concurrentForces[0].actionPoint,
                    type: SCENE_TYPE.FD
                });
                concurrentForces[0].actionPoint.bindScene(scene);

                decomposeScene.scene = scene;
                var isVertical, isHorizontal;
                while (concurrentForces.length) {
                    isVertical = false;
                    isHorizontal = false;

                    // 取出一种颜色
                    if (++clrIdx > COLOR.length - 1) {
                        clrIdx = 0;
                    }

                    // 取出合力
                    fCompound = concurrentForces.shift();

                    // 合力切换为非选中状态
                    if (fCompound.isSelected) {
                        fCompound._toggleFSelectState();
                    }
                    if (fCompound.isShowForceTipsBox) {
                        fCompound._toggleForceTipsBox();
                    }

                    // 过滤特殊情况
                    if (fCompound.x1 == fCompound.x2) {
                        // 垂直情况
                        isVertical = true;
                    }
                    if (fCompound.y1 == fCompound.y2) {
                        // 水平情况
                        isHorizontal = true;
                    }
                    if (!isVertical && !isHorizontal) {
                        //生成分力
                        f1Data = {
                            x1: fCompound.x1,
                            y1: fCompound.y1,
                            x2: fCompound.x2,
                            y2: fCompound.y1,
                            nameChar: fCompound.nameChar,
                            idx: fCompound.idx,
                            quotationMark: "\'",
                            color: COLOR[clrIdx],
                            panel: $panel,
                            isComponentForce: true, // 标志为分力
                            isAssistant: true // 标志为辅助力
                        };
                        f2Data = {
                            x1: fCompound.x1,
                            y1: fCompound.y1,
                            x2: fCompound.x1,
                            y2: fCompound.y2,
                            nameChar: fCompound.nameChar,
                            idx: fCompound.idx,
                            quotationMark: "\"",
                            color: COLOR[clrIdx],
                            panel: $panel,
                            isComponentForce: true, // 标志为分力
                            isAssistant: true // 标志为辅助力
                        };
                        f1 = new F(f1Data);
                        f2 = new F(f2Data);
                    }

                    // 生成坐标轴
                    if (!coordinates) {
                        attrCoordinates = {
                            x: fCompound.x1,
                            y: fCompound.y1,
                            xPositiveLen: xPositiveLenMax,
                            xNegativeLen: xNegativeLenMax,
                            yPositiveLen: yPositiveLenMax,
                            yNegativeLen: yNegativeLenMax
                        };
                        coordinates = new Coordinates(attrCoordinates);
                    }

                    // 设置坐标轴的四个方向值
                    if (fCompound.x1 < fCompound.x2 && fCompound.y1 > fCompound.y2) {
                        currentXPositiveLen = Utils.calDistance(f1.x1, f1.y1, f1.x2, f1.y2) + 90;
                        currentYPositiveLen = Utils.calDistance(f2.x1, f2.y1, f2.x2, f2.y2) + 90;
                        if (xPositiveLenMax < currentXPositiveLen) {
                            xPositiveLenMax = currentXPositiveLen;
                        }
                        if (yPositiveLenMax < currentYPositiveLen) {
                            yPositiveLenMax = currentYPositiveLen;
                        }
                        coordinates.setXPositiveLen(xPositiveLenMax);
                        coordinates.setYPositiveLen(yPositiveLenMax);
                    }
                    if (fCompound.x1 > fCompound.x2 && fCompound.y1 < fCompound.y2) {
                        currentXReverseLen = Utils.calDistance(f1.x1, f1.y1, f1.x2, f1.y2) + 90;
                        currentYReverseLen = Utils.calDistance(f2.x1, f2.y1, f2.x2, f2.y2) + 90;
                        if (xNegativeLenMax < currentXReverseLen) {
                            xNegativeLenMax = currentXReverseLen;
                        }
                        if (yNegativeLenMax < currentYReverseLen) {
                            yNegativeLenMax = currentYReverseLen;
                        }
                        coordinates.setXReverseLen(xNegativeLenMax);
                        coordinates.setYReverseLen(yNegativeLenMax);
                    }
                    if (fCompound.x1 < fCompound.x2 && fCompound.y1 < fCompound.y2) {
                        currentXPositiveLen = Utils.calDistance(f1.x1, f1.y1, f1.x2, f1.y2) + 90;
                        currentYReverseLen = Utils.calDistance(f2.x1, f2.y1, f2.x2, f2.y2) + 90;
                        if (xPositiveLenMax < currentXPositiveLen) {
                            xPositiveLenMax = currentXPositiveLen;
                        }
                        if (yNegativeLenMax < currentYReverseLen) {
                            yNegativeLenMax = currentYReverseLen;
                        }
                        coordinates.setXPositiveLen(xPositiveLenMax);
                        coordinates.setYReverseLen(yNegativeLenMax);
                    }
                    if (fCompound.x1 > fCompound.x2 && fCompound.y1 > fCompound.y2) {
                        currentXReverseLen = Utils.calDistance(f1.x1, f1.y1, f1.x2, f1.y2) + 90;
                        currentYPositiveLen = Utils.calDistance(f2.x1, f2.y1, f2.x2, f2.y2) + 90;
                        if (xNegativeLenMax < currentXReverseLen) {
                            xNegativeLenMax = currentXReverseLen;
                        }
                        if (yPositiveLenMax < currentYPositiveLen) {
                            yPositiveLenMax = currentYPositiveLen;
                        }
                        coordinates.setXReverseLen(xNegativeLenMax);
                        coordinates.setYPositiveLen(yPositiveLenMax);
                    }

                    // 水平特殊情况
                    if (isHorizontal) {
                        if (fCompound.x1 < fCompound.x2) {
                            // 水平向右
                            currentXPositiveLen = Utils.calDistance(fCompound.x1, fCompound.y1, fCompound.x2, fCompound.y2) + 90;
                            if (xPositiveLenMax < currentXPositiveLen) {
                                xPositiveLenMax = currentXPositiveLen;
                            }
                            coordinates.setXPositiveLen(xPositiveLenMax);
                        } else {
                            // 水平向左
                            currentXReverseLen = Utils.calDistance(fCompound.x1, fCompound.y1, fCompound.x2, fCompound.y2) + 90;
                            if (xNegativeLenMax < currentXReverseLen) {
                                xNegativeLenMax = currentXReverseLen;
                            }
                            coordinates.setXReverseLen(xNegativeLenMax);
                        }
                    }

                    // 垂直特殊情况
                    if (isVertical) {
                        if (fCompound.y1 > fCompound.y2) {
                            // 垂直向上
                            currentYPositiveLen = Utils.calDistance(fCompound.x1, fCompound.y1, fCompound.x2, fCompound.y2) + 90;
                            if (yPositiveLenMax < currentYPositiveLen) {
                                yPositiveLenMax = currentYPositiveLen;
                            }
                            coordinates.setYPositiveLen(yPositiveLenMax);
                        } else {
                            // 垂直向下
                            currentYReverseLen = Utils.calDistance(fCompound.x1, fCompound.y1, fCompound.x2, fCompound.y2) + 90;
                            if (yNegativeLenMax < currentYReverseLen) {
                                yNegativeLenMax = currentYReverseLen;
                            }
                            coordinates.setYReverseLen(yNegativeLenMax);
                        }
                    }

                    if (!isVertical && !isHorizontal) {
                        // 生成辅助线
                        attrDashLine1 = {
                            x1: fCompound.x1,
                            y1: fCompound.y2,
                            x2: fCompound.x2,
                            y2: fCompound.y2,
                            color: COLOR[clrIdx]
                        };
                        attrDashLine2 = {
                            x1: fCompound.x2,
                            y1: fCompound.y1,
                            x2: fCompound.x2,
                            y2: fCompound.y2,
                            color: COLOR[clrIdx]
                        };
                        dashLine1 = new DashLine(attrDashLine1);
                        dashLine2 = new DashLine(attrDashLine2);
                        // 记录分力
                        scene.recordComponentForce(f1);
                        scene.recordComponentForce(f2);
                        // 记录辅助线
                        scene.recordAuxiliaryLine(dashLine1);
                        scene.recordAuxiliaryLine(dashLine2);
                    }
                    // 记录坐标轴
                    scene.recordCoordinates(coordinates);
                }
                return decomposeScene;
            }
            return null;
        },
        /**
         * 老师端更新需要同步的数据
         */
        updateSyncData: function updateSyncData() {
            var dataNeedSync = []; // 接收老师端需要同步的数据
            var dataNeedSyncStr;
            if (panelContainer._array.length > 0) {
                panelContainer._array.forEach(function (item) {
                    if (item instanceof FPoint) {
                        dataNeedSync.push(item.getMetaData());
                    }
                });
            }
            // 字符串化数据以网络传输
            if (dataNeedSync.length > 0) {
                dataNeedSyncStr = JSON.stringify(dataNeedSync);
            }
            return dataNeedSyncStr; // 老师端需要同步数据的字符串形式
        },
        /**
         * 渲染同步的数据
         */
        renderSyncData: function renderSyncData() {
            var data;
            if (arguments.length === 1) {
                data = arguments[0];
            }
            if (typeof data === 'undefined' || data === '') {
                return;
            }

            // 绘制同步的数据
            var dataNeedSync = JSON.parse(data);
            if (dataNeedSync.length > 0) {
                dataNeedSync.forEach(function (point) {
                    // 绘制作用点
                    var actionPoint = new FPoint({
                        x: point.x,
                        y: point.y,
                        isVirtual: point.isVirtual,
                        idx: point.isVirtual ? " " : point.idx,
                        nameChar: point.isVirtual ? " " : point.nameChar,
                        isUnderBodilyDragging: point.isUnderBodilyDragging,
                        panel: $panel
                    });
                    // 绘制共点力
                    if (point.concurrentForces.length > 0) {
                        point.concurrentForces.forEach(function (fData) {
                            var concurrentForce = new F({
                                x1: fData.x1,
                                y1: fData.y1,
                                x2: fData.x2,
                                y2: fData.y2,
                                idx: fData.idx,
                                nameChar: fData.nameChar,
                                quotationMark: fData.quotationMark,
                                isThin: fData.isThin,
                                isDotted: fData.isDotted,
                                color: fData.color,
                                isPossessActionPoint: fData.isPossessActionPoint,
                                isAssistant: fData.isAssistant,
                                isCompound: fData.isCompound,
                                isSelected: fData.isSelected
                            });
                            // 共点力与作用点相互关联
                            concurrentForce.bindActionPoint(actionPoint);
                            actionPoint.bindConcurrentForce(concurrentForce);
                            concurrentForce.possessActionPoint(fData.isPossessActionPoint); // 设置力是否有作用点
                            // 处理由于学生端同步老师端导致的力的拖拽点偏移问题
                            concurrentForce.drag(concurrentForce.x2, concurrentForce.y2);
                            // 同步选中态
                            if (fData.isSelected) {
                                concurrentForce._toggleFSelectState();
                            }
                        });
                    }
                    // 同步场景信息
                    if (point.scene) {
                        var scene = new Scene({
                            associatedPoint: actionPoint,
                            type: point.scene.type
                        });
                        scene.associatedPoint.bindScene(scene);

                        // 生成合力
                        var joinForces = point.scene.joinForces;
                        if (joinForces && joinForces.length > 0) {
                            joinForces.forEach(function (item) {
                                scene.recordJoinForce(new F({
                                    x1: item.x1,
                                    y1: item.y1,
                                    x2: item.x2,
                                    y2: item.y2,
                                    color: item.color,
                                    isDotted: item.isDotted,
                                    nameChar: item.nameChar,
                                    fIdx: item.fIdx,
                                    isCompound: item.isCompound, //标志为合力
                                    isAssistant: item.isAssistant // 标志为辅助力
                                }));
                            });
                        }

                        // 生成分力
                        var componentForces = point.scene.componentForces;
                        if (componentForces && componentForces.length > 0) {
                            componentForces.forEach(function (item) {
                                scene.recordComponentForce(new F({
                                    x1: item.x1,
                                    y1: item.y1,
                                    x2: item.x2,
                                    y2: item.y2,
                                    nameChar: item.nameChar,
                                    idx: item.idx,
                                    quotationMark: item.quotationMark,
                                    color: item.color,
                                    isAssistant: item.isAssistant // 标志为辅助力
                                }));
                            });
                        }

                        // 坐标轴
                        var coordinates = point.scene.coordinates;
                        if (coordinates) {
                            scene.recordCoordinates(new Coordinates({
                                x: coordinates.x,
                                y: coordinates.y,
                                xPositiveLen: coordinates.xPositiveLen,
                                xNegativeLen: coordinates.xNegativeLen,
                                yPositiveLen: coordinates.yPositiveLen,
                                yNegativeLen: coordinates.yNegativeLen
                            }));
                        }

                        // 辅助线
                        var auxiliaryLines = point.scene.auxiliaryLines;
                        if (auxiliaryLines && auxiliaryLines.length > 0) {
                            auxiliaryLines.forEach(function (item) {
                                scene.recordAuxiliaryLine(new DashLine({
                                    x1: item.x1,
                                    y1: item.y1,
                                    x2: item.x2,
                                    y2: item.y2
                                }));
                            });
                        }
                    }

                    // 初始化学生端面板容器
                    panelContainer.add(actionPoint);
                });
            }
        }
    };

    /**
     * 咨询性质方法集合
     */
    var Consult = {
        askMeetFCFDCondition: function askMeetFCFDCondition() {
            // 咨询是否达到 合成 || 分解 力的条件
            var fCNum = 0,
                canDoFC = false,
                canDoFD = false,
                size;
            if (panelContainer && (size = panelContainer.size())) {
                for (var i = 0; i < size; i++) {
                    var point = panelContainer._array[i];
                    if (point) {
                        if (point.isVirtual) {
                            // 找到一个无作用点的力
                            canDoFD = true;
                        } else {
                            // 非虚拟作用点
                            var len;
                            if (point._concurrentForces && (len = point._concurrentForces.length)) {
                                var concurrentForce;
                                fCNum = 0;
                                for (var j = 0; j < len; j++) {
                                    concurrentForce = point._concurrentForces[j];
                                    if (!concurrentForce._beenLogicallyDestroyed) {
                                        fCNum++;
                                    }
                                    if (!canDoFD && fCNum >= 1) {
                                        canDoFD = true;
                                    }
                                    if (!canDoFC && fCNum >= 2) {
                                        canDoFC = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (canDoFC) {
                        break;
                    }
                }
            }
            if (canDoFC) {
                Utils.set2GreyState($btnFCompound, false);
            } else {
                Utils.set2GreyState($btnFCompound, true);
                $compoundPopupWindow.hide();
            }
            if (canDoFD) {
                Utils.set2GreyState($btnFDecompose, false);
            } else {
                Utils.set2GreyState($btnFDecompose, true);
                $decomposePopupWindow.hide();
            }
        },
        askMeetCleanUPCondition: function askMeetCleanUPCondition() {
            // 咨询是否满足　清空面板内容　条件
            panelContainer && panelContainer.size() ? Utils.set2GreyState($btnCleanUp, false) : Utils.set2GreyState($btnCleanUp, true);
        },
        askMeetReUnDoCondition: function askMeetReUnDoCondition() {
            // 咨询是否满足 撤销 || 恢复 的条件
            undoStack && undoStack._array.length ? Utils.set2GreyState($btnUndo, false) : Utils.set2GreyState($btnUndo, true);
            redoStack && redoStack._array.length ? Utils.set2GreyState($btnRedo, false) : Utils.set2GreyState($btnRedo, true);
        },
        updateFCFDPopupWindow: function updateFCFDPopupWindow() {
            // update 合成 || 分解 弹出框面板
            // 统计弹框面板数据
            var canDoFC = false;
            var canDoFD = false;
            var fNum = 0; // 统计cdQ容器力的数量
            var concurrentForceNum = 0; // 统计共点力数量

            // 判断是否达到合成、分解条件 and 统计力、共点力数量
            var size = cdQ.size();
            if (cdQ && size) {
                canDoFD = true;
                for (var i = 0; i < size; i++) {
                    if (!canDoFC) {
                        if (cdQ._array[i].length >= 2) {
                            canDoFC = true;
                        }
                    }
                    fNum += cdQ._array[i].length;
                    // 共点力统计排除无作用点情况
                    if (cdQ._array[i].length == 1 && !cdQ._array[i][0].isPossessActionPoint) {
                        concurrentForceNum++;
                    }
                }
                concurrentForceNum = fNum - concurrentForceNum;
            }

            //更新合成弹出框面板
            Utils.setText($compoundFMarkedSpan, concurrentForceNum);

            if (i18nHelper.getLocalTxt("physics_compound_lower_half_plural") !== i18nHelper.ERROR || i18nHelper.getLocalTxt("physics_compound_lower_half_singular") !== i18nHelper.ERROR) {
                if (concurrentForceNum > 1) {
                    $compoundPopupWindow.find("span._physics_compound_lower_half").html(i18nHelper.getLocalTxt("physics_compound_lower_half_plural"));
                } else {
                    $compoundPopupWindow.find("span._physics_compound_lower_half").html(i18nHelper.getLocalTxt("physics_compound_lower_half_singular"));
                }
            }

            if (canDoFC) {
                Utils.set2CorrectState($compoundFMarkedSpan, true);
                Utils.set2GreyState($compoundPWConfirm, false);
            } else {
                Utils.set2CorrectState($compoundFMarkedSpan, false);
                Utils.set2GreyState($compoundPWConfirm, true);
            }

            //更新分解弹出框面板
            Utils.setText($decomposeFMarkedSpan, fNum);

            if (i18nHelper.getLocalTxt("physics_decompose_lower_half_plural") !== i18nHelper.ERROR || i18nHelper.getLocalTxt("physics_decompose_lower_half_singular") !== i18nHelper.ERROR) {
                if (fNum > 1) {
                    $decomposePopupWindow.find("span._physics_decompose_lower_half").html(i18nHelper.getLocalTxt("physics_decompose_lower_half_plural"));
                } else {
                    $decomposePopupWindow.find("span._physics_decompose_lower_half").html(i18nHelper.getLocalTxt("physics_decompose_lower_half_singular"));
                }
            }

            if (canDoFD) {
                Utils.set2CorrectState($decomposeFMarkedSpan, true);
                Utils.set2GreyState($decomposePWConfirm, false);
            } else {
                Utils.set2CorrectState($decomposeFMarkedSpan, false);
                Utils.set2GreyState($decomposePWConfirm, true);
            }
        }
    };

    /**
     * 清除之前的面板状态
     * @param preState 上一个面板状态
     */
    var cleanPrePanelState = function cleanPrePanelState(preState) {
        //清除之前的面板状态
        switch (preState) {
            case STATE.CAN_DRAW_FP:
                Utils.set2ActiveState($btnDrawFP, false);
                break;
            case STATE.CAN_DRAW_F:
                Utils.set2ActiveState($btnDrawF, false);
                break;
            case STATE.CAN_DO_FC:
                Utils.set2ActiveState($btnFCompound, false);
                $compoundPopupWindow.hide();
                break;
            case STATE.CAN_DO_FD:
                Utils.set2ActiveState($btnFDecompose, false);
                $decomposePopupWindow.hide();
                break;
        }
    };

    /**
     * 面板状态切换逻辑
     * @param state 要切换的面板状态
     */
    var switchState = function switchState(state) {
        if (preHandledObj) {
            preHandledObj._toggleForceTipsBox();
        }
        Utils.turnOffBodilyDraggingState();
        cleanPrePanelState(currentPanelState); //清除前一次的面板状态
        if (state == currentPanelState) {
            //连续两次点击同一个按钮，则关闭该状态
            currentPanelState = STATE.IDLE;
            currentPanelState == STATE.CAN_DRAW_F ? Utils.set2GreyState($sliderRegion, false) : Utils.set2GreyState($sliderRegion, true);
            return;
        }
        switch (state) {//切换状态
            case STATE.CAN_DRAW_FP:
                Utils.set2ActiveState($btnDrawFP, true);
                break;
            case STATE.CAN_DRAW_F:
                Utils.set2ActiveState($btnDrawF, true);
                break;
            case STATE.CAN_DO_FC:
                Utils.set2ActiveState($btnFCompound, true);
                $compoundPopupWindow.show();
                break;
            case STATE.CAN_DO_FD:
                Utils.set2ActiveState($btnFDecompose, true);
                $decomposePopupWindow.show();
                break;
        }
        currentPanelState = state;
        currentPanelState == STATE.CAN_DRAW_F ? Utils.set2GreyState($sliderRegion, false) : Utils.set2GreyState($sliderRegion, true);
    };

    /**
     * 面板容器
     */
    // 容器的声明
    var panelContainer, // 面板容器对象
    redoStack, undoStack, nameIndexManager, cdQ; // 力的合成分解队列
    var init = function init() {
        Array.prototype.deletePhysicsSynthesisObj = function (obj) {
            // 根据删除对象
            var size = this.length;
            if (size) {
                for (var j = 0; j < size; j++) {
                    if (this[j].getId() == obj.getId()) {
                        // 在面板容器中找到该对象的记录
                        return this.splice(j, 1);
                    }
                }
            }
            // 没有找到该对象的记录
            return -1;
        };

        possessActionPoint = true;

        PhysicsSynthesis.cleanUpPanel();
        switchState(currentPanelState);

        // 初始化名字下标管理器
        nameIndexManager = {
            O: [],
            F: []
        };
        nameIndexManager.__proto__ = {
            /**
             * 检测当前名字是否已经存在于管理器缓存中
             * @param nameChar
             * @param idx
             * @returns {boolean} false：不存在与缓存中，true：存在与缓存中
             */
            checkExist: function checkExist(nameChar, idx) {
                var idxInteger = parseInt(idx);
                if (isNaN(idxInteger)) {
                    return false;
                }
                if (typeof this[nameChar] !== 'undefined' && this[nameChar].length > 0) {
                    var i;
                    for (i = 0; i < this[nameChar].length; ++i) {
                        if (this[nameChar][i] === idxInteger) {
                            break;
                        }
                    }
                    return !(i === this[nameChar].length);
                }
                return false;
            },
            /**
             * 往缓存中添加名字和下标
             * @param nameChar
             * @param idx
             * @returns {Number}
             */
            add: function add(nameChar, idx) {
                if (nameChar.trim() === "" || ('' + idx).trim() === "") {
                    return -1;
                }
                if (this.checkExist(nameChar, idx)) {
                    return -1;
                }
                if (typeof this[nameChar] === 'undefined') {
                    this[nameChar] = [];
                }
                var idxInteger = parseInt(idx);
                if (isNaN(idxInteger)) {
                    return -1;
                }
                this[nameChar].push(idxInteger);
                this[nameChar].sort(function (a, b) {
                    return a - b;
                });
                return idxInteger;
            },
            /**
             * 从缓存中删除名字和下标
             * @param nameChar
             * @param idx
             */
            remove: function remove(nameChar, idx) {
                if (nameChar.trim() === "" || ('' + idx).trim() === '') {
                    return -1;
                }
                if (typeof this[nameChar] !== 'undefined') {
                    var existIdx = -1;
                    var idxInteger = parseInt(idx);
                    if (isNaN(idxInteger)) {
                        return -1;
                    }
                    for (var k = 0; k < this[nameChar].length; ++k) {
                        if (this[nameChar][k] == idxInteger) {
                            existIdx = k;
                            break;
                        }
                    }
                    if (existIdx != -1) {
                        return this[nameChar].splice(k, 1);
                    }
                    return -1;
                }
                return -1;
            },
            /**
             * 根据当前面板的情况生成一个合适的作用点或力名字下标值
             * @returns {*}
             */
            generateIdx: function generateIdx(nameChar) {
                if (typeof this[nameChar] === 'undefined') {
                    this[nameChar] = [];
                }

                var arrLen = this[nameChar].length;
                if (arrLen > 0 && this[nameChar][0] !== 1) {
                    return 1;
                }
                if (arrLen === 0) {
                    return 1;
                }
                if (arrLen === 1) {
                    if (this[nameChar][0] !== 1) {
                        return 1;
                    } else {
                        return 2;
                    }
                }

                var i,
                    lastIdx = this[nameChar][0];
                for (i = 1; i < arrLen; ++i) {
                    if (this[nameChar][i] - lastIdx !== 1) {
                        break;
                    }
                    lastIdx = this[nameChar][i];
                }
                return lastIdx + 1;
            },
            /**
             * 清空名字下标管理器缓存的数据
             */
            empty: function empty() {
                for (var p in this) {
                    if (this.hasOwnProperty(p) && this[p] instanceof Array) {
                        this[p].length = 0;
                    }
                }
            },
            /**
             * 提供学生端同步老师端名字下标管理器缓存的数据API
             * @param data
             */
            setData: function setData(data) {
                this.empty();
                for (var p in data) {
                    if (data.hasOwnProperty(p)) {
                        this[p] = data[p];
                    }
                }
            }
        };

        // 初始化恢复栈
        redoStack = {
            _array: [],
            pushStack: function pushStack(obj) {
                // 入栈
                if (this._array.length == 10) {
                    // 控制只能撤销10步
                    this._array.splice(-1, 1);
                }
                this._array.unshift(obj);
                Consult.askMeetReUnDoCondition();
            },
            popStack: function popStack() {
                // 抛栈
                var returnObj = this._array.shift();
                Consult.askMeetReUnDoCondition();
                return returnObj;
            },
            empty: function empty() {
                this._array.length = 0;
                Consult.askMeetReUnDoCondition();
            }
        };
        undoStack = {
            _array: [],
            pushStack: function pushStack(obj) {
                // 入栈
                if (this._array.length == 10) {
                    // 控制只能撤销10步
                    this._array.splice(-1, 1);
                }
                this._array.unshift(obj);
                Consult.askMeetReUnDoCondition();
            },
            popStack: function popStack() {
                // 抛栈
                var returnObj = this._array.shift();
                Consult.askMeetReUnDoCondition();
                return returnObj;
            },
            empty: function empty() {
                this._array.length = 0;
                Consult.askMeetReUnDoCondition();
            }
        };
        panelContainer = { // 面板容器单例 ——> 只是添加共点力作用点对象(包括虚拟作用点)
            _array: [],
            size: function size() {
                return this._array.length;
            },
            remove: function remove(obj) {
                if (obj instanceof FPoint) {
                    var result = this._array.deletePhysicsSynthesisObj(obj);
                    // 咨询是否达到 合成 || 分解 条件
                    Consult.askMeetFCFDCondition();
                    Consult.askMeetCleanUPCondition();
                    return result != -1; // true：对象删除成功 false：面板容器没有该对象记录
                }
                throw new Error("Error Info：类型不对，待删除的对象不是作用点");
            },
            add: function add(obj) {
                if (obj instanceof FPoint) {
                    this._array.push(obj);
                    // 咨询是否达到 合成 || 分解 条件
                    Consult.askMeetFCFDCondition();
                    Consult.askMeetCleanUPCondition();
                    return true;
                }
                throw new Error("Error Info：类型不对，待添加的对象不是作用点");
            }
        };

        cdQ = { // 力的合成分解队列，点击力就会被加入到队列中
            _array: [],
            size: function size() {
                return this._array.length;
            },
            empty: function empty() {
                this._array.length = 0;
                Consult.updateFCFDPopupWindow();
            },
            enQueue: function enQueue(obj) {
                // 入队列
                var enQueueSuccess = false;
                if (this._array.length) {
                    for (var i = 0; i < this._array.length; i++) {
                        if (this._array[i][0].actionPoint.getId() == obj.actionPoint.getId()) {
                            this._array[i].push(obj);
                            enQueueSuccess = true;
                            break;
                        }
                    }
                    if (!enQueueSuccess) {
                        var nextNode = [];
                        nextNode.push(obj);
                        this._array.push(nextNode);
                    }
                }
                if (this._array.length == 0) {
                    var headNode = [];
                    headNode.push(obj);
                    this._array.push(headNode);
                }
                Consult.updateFCFDPopupWindow();
            },
            deQueue: function deQueue() {
                // 出队列
                return this._array.shift();
            },
            remove: function remove(obj) {
                for (var i = 0; i < this._array.length; i++) {
                    for (var j = 0; j < this._array[i].length; j++) {
                        if (this._array[i][j].getId() == obj.getId()) {
                            this._array[i].deletePhysicsSynthesisObj(obj);
                            if (this._array[i].length == 0) {
                                this._array.splice(i, 1);
                            }
                            break;
                        }
                    }
                }
                Consult.updateFCFDPopupWindow();
            }
        };
    };

    // 消息处理中心，每一次消息都代表用户的一次新操作
    var MESSAGE = {
        NO_NEED_POST: false, // 不需要发送消息
        NEED_POST: true, // 需要发送消息
        ADD_POINT: 1, // 只是添加了一个作用点
        ADD_FORCE_WITH_POINT: 2, // 添加了一个有作用点的力
        ADD_CONCURRENT_FORCE: 3, // 添加一个共点力
        DROP_CONCURRENT_FORCE: 4, // 删除一个共点力
        DROP_NON_CONCURRENT_FORCE: 5, // 删除一个非共点力
        DROP_POINT: 6, // 删除了一个作用点
        TRANSLATE_POINT: 7, // 平移作用点
        DRAG_FORCE: 8, // 拖拽力
        RENAME_OBJ: 9, // 重命名
        COMPOUND_FORCES: 10, // 合成
        DECOMPOSE_FORCES: 11 // 分解
    };

    var handler = {
        sendMessage: function sendMessage(msg) {
            this._dispatchMessage(msg);
        },
        _dispatchMessage: function _dispatchMessage(msg) {
            switch (msg.identify) {
                case MESSAGE.ADD_POINT:
                    // 只是添加了一个作用点
                    panelContainer.add(msg.target);
                    undoStack.pushStack({
                        description: "创建了一个作用点",
                        doWhat: MESSAGE.ADD_POINT,
                        actionObj: msg.target
                    });
                    break;
                case MESSAGE.ADD_FORCE_WITH_POINT:
                    // 添加了一个有作用点的力
                    panelContainer.add(msg.target.actionPoint);
                    undoStack.pushStack({
                        doWhat: MESSAGE.ADD_FORCE_WITH_POINT,
                        actionObj: msg.target,
                        description: possessActionPoint ? "创建了一个带作用点的力" : "创建了一个不！！！带作用点的力"
                    });
                    break;
                case MESSAGE.ADD_CONCURRENT_FORCE:
                    // 创建了一个共点力
                    undoStack.pushStack({
                        description: "创建了一个共点力",
                        doWhat: MESSAGE.ADD_CONCURRENT_FORCE,
                        actionObj: msg.target
                    });
                    break;
                case MESSAGE.DROP_CONCURRENT_FORCE:
                    // 删除一个共点力
                    undoStack.pushStack({
                        description: "删除了一个共点力",
                        doWhat: MESSAGE.DROP_CONCURRENT_FORCE,
                        actionObj: msg.target,
                        destroyedScene: msg.destroyedScene
                    });
                    break;
                case MESSAGE.DROP_NON_CONCURRENT_FORCE:
                    // 删除一个非共点力(没有作用点的力)
                    panelContainer.remove(msg.target);
                    undoStack.pushStack({
                        description: "删除了一个无作用点的力",
                        doWhat: MESSAGE.DROP_NON_CONCURRENT_FORCE,
                        actionObj: msg.target,
                        destroyedScene: msg.target.scene
                    });
                    break;
                case MESSAGE.DROP_POINT:
                    // 删除一个作用点
                    panelContainer.remove(msg.target);
                    undoStack.pushStack({
                        description: "删除了一个作用点",
                        doWhat: MESSAGE.DROP_POINT,
                        actionObj: msg.target,
                        destroyedScene: msg.destroyedScene
                    });
                    break;
                case MESSAGE.RENAME_OBJ:
                    // 重命名
                    undoStack.pushStack({
                        description: "修改了名字",
                        doWhat: MESSAGE.RENAME_OBJ,
                        actionObj: msg.target,
                        preState: msg.preState
                    });
                    break;
                case MESSAGE.DRAG_FORCE:
                    undoStack.pushStack({
                        description: "拖拽了一个力",
                        doWhat: MESSAGE.DRAG_FORCE,
                        actionObj: msg.target,
                        preState: msg.preState,
                        destroyedScene: msg.destroyedScene
                    });
                    break;
                case MESSAGE.TRANSLATE_POINT:
                    undoStack.pushStack({
                        description: "平移了作用点",
                        doWhat: MESSAGE.TRANSLATE_POINT,
                        actionObj: msg.target,
                        preState: msg.preState
                    });
                    break;
                case MESSAGE.COMPOUND_FORCES:
                    undoStack.pushStack({ // 合成同时是否销毁了场景
                        description: "执行一次合成",
                        doWhat: MESSAGE.COMPOUND_FORCES,
                        scenes: msg.scenes
                    });
                    break;
                case MESSAGE.DECOMPOSE_FORCES:
                    // 记录用户的一次合成操作
                    undoStack.pushStack({ // 分解的同时是否销毁了场景
                        description: "执行一次分解",
                        doWhat: MESSAGE.DECOMPOSE_FORCES,
                        scenes: msg.scenes
                    });
                    break;
            }

            // 清空redoStack
            redoStack.empty();
            Consult.askMeetFCFDCondition();
        }
    };

    /**
     * 模型的定义
     */

    // 1、力模型
    function F(attrData) {
        // 标识力对象的唯一ID
        this.id = Utils.generateGeneralUUID();

        // 头尾坐标
        this.x1 = attrData.x1 || 300;
        this.y1 = attrData.y1 || 300;
        this.x2 = attrData.x2 || 600;
        this.y2 = attrData.y2 || 600;

        this.idx = attrData.idx || "";
        this.nameChar = attrData.nameChar || "F";
        this.quotationMark = attrData.quotationMark || "";

        // 记录该力所被添加的面板
        this.$panel = attrData.panel || $panel;

        // 力关联的作用点句柄
        this.actionPoint = null;

        // 样式控制标志位
        this.isThin = attrData.isThin || false; // 标识是否是细力
        this.isDotted = attrData.isDotted || false; // 标识是否是虚线力
        this.color = attrData.color || null; // 标识力的颜色

        // 逻辑控制标志位
        this.isPossessActionPoint = attrData.isPossessActionPoint || true; // 标识有无作用点，true：有作用点，false：无作用点
        this.isSelected = false; // 表示是否被选中
        this.isShowForceTipsBox = false; // 标识是否显示力的确定删除框
        this.isAssistant = attrData.isAssistant || false; // false(default)：为用户画的力 true：辅助力(没有编辑态)
        this.isCompound = attrData.isCompound || false;
        this.isComponentForce = attrData.isComponentForce || false; // 是否是分力：false(default)：为用户画的力 true：业务生成的分力
        this._beenLogicallyDestroyed = false; // 是否被逻辑上删除

        this.scene = null;

        // 视图
        this.view = {};

        // 绘制力的视图
        this._draw();
    }

    F.prototype = {
        constructor: F,
        getMetaData: function getMetaData() {
            return {
                x1: this.x1,
                y1: this.y1,
                x2: this.x2,
                y2: this.y2,
                idx: this.idx,
                nameChar: this.nameChar,
                quotationMark: this.quotationMark,
                isThin: this.isThin,
                isDotted: this.isDotted,
                color: this.color,
                isPossessActionPoint: this.isPossessActionPoint,
                isAssistant: this.isAssistant,
                isCompound: this.isCompound,
                isSelected: this.isSelected
            };
        },
        getId: function getId() {
            return this.id;
        },
        getIdx: function getIdx() {
            return this.idx;
        },
        setIdx: function setIdx(idx) {
            this.idx = idx;
        },
        getNameChar: function getNameChar() {
            return this.nameChar;
        },
        setNameChar: function setNameChar(nameChar) {
            this.nameChar = nameChar;
        },
        _initView: function _initView() {
            // 初始化View，只会执行一次
            // 创建力的各个部件
            this.view.$ph_force = $('<div class="ph_force" style="z-index:20;width:300px;transform: rotate(0deg);left:297px; top:298px;"></div>'); // ph_force_on || dotted_line || force_thin
            this.view.$force_line = $('<div class="force_line hand_type"></div>');
            this.view.$force_arrow = $('<div class="force_arrow iconfont"><span class="icon_jt">&#xe613;</span></div>');
            this.view.$force_name_box = $('<div class="force_name_box" style="transform: rotate(0deg)"></div>');
            this.view.$force_name_span = $('<div class="force_name_span_wrapper">' + '<span class="force_name_f">F</span>' + '<span class="force_name_num">2</span>' + '<span class="force_name_quotation_mark"></span>' + '</div>');
            this.view.$force_name_f = this.view.$force_name_span.find(".force_name_f");
            this.view.$force_name_num = this.view.$force_name_span.find(".force_name_num");
            this.view.$force_name_quotation_mark = this.view.$force_name_span.find(".force_name_quotation_mark");
            this.view.$force_drag = $('<div class="force_drag"></div>'); // drag_on

            // 组装控件
            this.view.$force_name_box.append(this.view.$force_name_span);
            this.view.$ph_force.append(this.view.$force_line); // 组装力控件
            this.view.$ph_force.append(this.view.$force_arrow);
            this.view.$ph_force.append(this.view.$force_name_box);

            // 把力的视图添加到面板中
            this.$panel.append(this.view.$ph_force);
            this.$panel.append(this.view.$force_drag);

            // 设置是否是细力
            if (this.isThin) {
                this.view.$ph_force.addClass("force_thin");
            }

            // 设置是否是虚线力
            if (this.isDotted) {
                this.view.$ph_force.addClass("dotted_line");
            }

            // 设置为合力
            if (this.isCompound) {
                this.view.$ph_force.addClass("ph_force_merge");
            }

            // 有传递color值
            if (this.color) {
                this.view.$ph_force.addClass(this.color);
            }

            // 设置名字 和 角标
            this.view.$force_name_f.html(this.nameChar);
            this.view.$force_name_num.html(this.idx);
            this.view.$force_name_quotation_mark.html(this.quotationMark);

            var degree = Utils.calDegree(this.x1, this.y1, this.x2, this.y2);
            this.view.$ph_force.css({
                "left": this.x1, // 设置偏移位置
                "top": this.y1 - this.view.$ph_force.height() / 2,
                "width": Utils.calDistance(this.x1, this.y1, this.x2, this.y2), // 计算长度
                "transform": "rotate(" + degree + "deg)" // 计算旋转角度
            });
            this.view.$force_name_box.css("transform", "rotate(" + -degree + "deg)");

            // 定位force_drag
            // 设置偏移位置
            this.view.$force_drag.css({
                "left": this.x2,
                "top": this.y2 - this.view.$ph_force.height() / 2
            });

            this.setForceNameBoxClassByDegree(degree);
        },
        _toggleFSelectState: function _toggleFSelectState() {
            Utils.turnOffBodilyDraggingState();
            // 标志位的切换
            this.isSelected = !this.isSelected;
            // 选中状态的切换
            if (this.isSelected) {
                this.view.$ph_force.addClass("ph_force_on");
                this.view.$force_drag.addClass("drag_show");
                if (!this.isPossessActionPoint) {
                    // 需要显示虚拟作用点
                    this.actionPoint.hideSelf(false);
                }
                cdQ.enQueue(this);
            } else {
                if (this.view.$ph_force.hasClass("ph_force_on")) {
                    this.view.$ph_force.removeClass("ph_force_on");
                    this.view.$force_drag.removeClass("drag_show");
                }
                // 需要隐藏虚拟作用点
                if (!this.isPossessActionPoint) {
                    this.actionPoint.hideSelf(true);
                }
                cdQ.remove(this);
            }
        },
        _toggleForceTipsBox: function _toggleForceTipsBox() {
            this.isShowForceTipsBox = !this.isShowForceTipsBox;
            if (this.isShowForceTipsBox) {
                this.view.$force_name_span.hide();
                this.view.$force_name_box.addClass("name_edit");
                preHandledObj = this;
                $nameInput.val(this.nameChar + this.idx);
                i18nHelper.renderDelConfirmBtn();
                $delConfirmBtn.css({
                    left: this.x2,
                    top: this.y2
                }).show();
                $nameInput.focus();
            } else {
                this.view.$force_name_span.show();
                if (this.view.$force_name_box.hasClass("name_edit")) {
                    this.view.$force_name_box.removeClass("name_edit");
                }
                preHandledObj = null;
                $nameInput.blur();
                $delConfirmBtn.hide();
            }
        },
        _bindEvent: function _bindEvent() {
            var __self = this;

            // 点击力部件,阻止向panel冒泡
            this.view.$ph_force.on("touchstart mousedown", function (evt) {
                var downEvent = Utils.getEvent(evt);
                Utils.preventDefault(downEvent);
                Utils.stopPropagation(downEvent);
                if (__self.isAssistant) {
                    return;
                }
                if (preHandledObj) {
                    return;
                }
                var targetName = $(downEvent.target).attr('class').split(" ")[0];
                if (targetName == "force_line" || targetName == "ph_force" || targetName == "force_drag" || targetName == "icon_jt" || targetName == "force_arrow") {
                    __self._toggleFSelectState();
                }
            });

            // 点击力名字span事件
            this.view.$force_name_span.on("mousedown touchstart", function () {
                if (__self.isAssistant) {
                    return;
                }
                Utils.turnOffBodilyDraggingState();
                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                }
                __self._toggleForceTipsBox();
            });

            // 拖拽事件
            this.view.$force_drag.on("touchstart mousedown", function (dragUpEvt) {
                //$force_name_box
                var dragUpEvent = Utils.getEvent(dragUpEvt);
                Utils.stopPropagation(dragUpEvent);
                if (preHandledObj) {
                    return;
                }

                Utils.set2PenetrateState([$compoundPopupWindow, $decomposePopupWindow], true);

                var upPos = Utils.conversionCursorPos(dragUpEvent, $panel);

                var canJudgeAsDrag = false; // 拖拽 or 点击 标志位
                var alreadyPushUserInputToStack = false; // 控制只记录一次用户行为

                var msg = {
                    identify: MESSAGE.DRAG_FORCE,
                    target: __self,
                    preState: {
                        x2: __self.x2,
                        y2: __self.y2
                    },
                    destroyedScene: __self.actionPoint.scene
                };

                $panel.on("touchmove mousemove", function (evt2) {
                    //绘制力的预览视图
                    var e = Utils.getEvent(evt2);
                    var movePos = Utils.conversionCursorPos(e, $panel);

                    if (!canJudgeAsDrag && Utils.calDistance(upPos.x, upPos.y, movePos.x, movePos.y) > 10) {
                        canJudgeAsDrag = true;
                    }

                    if (canJudgeAsDrag) {
                        // 用户拖拽了力
                        if (!alreadyPushUserInputToStack) {
                            alreadyPushUserInputToStack = true;
                            handler.sendMessage(msg);
                        }
                        // 执行拖拽力业务
                        if (Utils.applyBorderCtrl({ 'movePos': movePos, 'fRef': __self, 'tag': TAG.DRAG_F_OR_FP })) {
                            return;
                        }
                        __self.drag(movePos.x, movePos.y);
                    }

                    // 销毁场景
                    if (__self.actionPoint) {
                        if (__self.actionPoint.scene) {
                            __self.actionPoint.scene.logicallyDestroy(); // 场景会先解绑作用点对象
                        }
                    }
                });
                $panel.on("touchend mouseup", function (event) {
                    var evt = event || window.event;
                    var upPos = Utils.conversionCursorPos(evt, $panel);

                    Utils.set2PenetrateState([$compoundPopupWindow, $decomposePopupWindow], false);

                    if (__self.view.$force_drag.hasClass("drag_show")) {
                        __self.view.$force_drag.removeClass("drag_show");
                    }

                    // 更新坐标信息
                    __self.x2 = upPos.x;
                    __self.y2 = upPos.y;

                    // 判断力的长度是否过短，是，则重置为最小长度
                    if (Utils.calDistance(__self.x1, __self.y1, __self.x2, __self.y2) <= 40) {
                        __self.drag(__self.x1 + 40, __self.y1);
                    }

                    $panel.off("mousemove touchmove");
                    $panel.off("mouseup touchend");

                    msg = null;
                    __self._toggleFSelectState();
                });
            });
        },
        _init: function _init() {
            // 初始化，只会执行一次
            this._initView();
            this._bindEvent();
        },
        _draw: function _draw() {
            // 力的绘制，只会执行一次
            this._init();
        },
        translate: function translate(moveX, moveY) {
            // 力的平移
            var deltaX = moveX - this.x1; // 更新起始坐标
            var deltaY = moveY - this.y1;
            this.x2 += deltaX;
            this.y2 += deltaY;
            this.x1 = moveX;
            this.y1 = moveY;
            this.view.$ph_force.css({ // 设置偏移位置
                "left": this.x1,
                "top": this.y1 - this.view.$ph_force.height() / 2
            });
            this.view.$force_drag.css({
                "left": this.x2,
                "top": this.y2
            });
        },
        setName: function setName(data) {
            this.nameChar = data.name;
            this.idx = parseInt(data.idx);
            nameIndexManager.add(this.nameChar, this.idx);
            this.view.$force_name_f.html(this.nameChar);
            this.view.$force_name_num.html(this.idx);
        },
        setForceNameBoxClassByDegree: function setForceNameBoxClassByDegree(degree) {
            if (typeof this.lastQuadrant === 'undefined') {
                this.lastQuadrant = 0;
            }
            var currentQuadrant = 0;

            // 第一象限
            if (degree < 0 && degree > -15) {
                currentQuadrant = 1;
            }
            if (degree < -15 && degree > -30) {
                currentQuadrant = 2;
            }
            if (degree < -30 && degree > -45) {
                currentQuadrant = 3;
            }
            if (degree < -45 && degree > -60) {
                currentQuadrant = 4;
            }
            if (degree < -60 && degree > -75) {
                currentQuadrant = 5;
            }
            if (degree < -75 && degree > -90) {
                currentQuadrant = 6;
            }
            // 第二象限
            if (degree < -90 && degree > -105) {
                currentQuadrant = 7;
            }
            if (degree < -105 && degree > -120) {
                currentQuadrant = 8;
            }
            if (degree < -120 && degree > -135) {
                currentQuadrant = 9;
            }
            if (degree < -135 && degree > -150) {
                currentQuadrant = 10;
            }
            if (degree < -150 && degree > -165) {
                currentQuadrant = 11;
            }
            if (degree < -165 && degree > -180) {
                currentQuadrant = 12;
            }
            // 第四象限
            if (degree > 0 && degree < 15) {
                currentQuadrant = 13;
            }
            if (degree > 15 && degree < 30) {
                currentQuadrant = 14;
            }
            if (degree > 30 && degree < 45) {
                currentQuadrant = 15;
            }
            if (degree > 45 && degree < 60) {
                currentQuadrant = 16;
            }
            if (degree > 60 && degree < 75) {
                currentQuadrant = 17;
            }
            if (degree > 75 && degree < 90) {
                currentQuadrant = 18;
            }
            // 第三象限
            if (degree > 90 && degree < 105) {
                currentQuadrant = 19;
            }
            if (degree > 105 && degree < 120) {
                currentQuadrant = 20;
            }
            if (degree > 120 && degree < 135) {
                currentQuadrant = 21;
            }
            if (degree > 135 && degree < 150) {
                currentQuadrant = 22;
            }
            if (degree > 150 && degree < 165) {
                currentQuadrant = 23;
            }
            if (degree > 165 && degree < 180) {
                currentQuadrant = 24;
            }

            // 处理四种特殊情况
            if (degree === 90) {
                currentQuadrant = 25;
            }
            if (degree === -90) {
                currentQuadrant = 26;
            }
            if (degree === 0) {
                currentQuadrant = 27;
            }
            if (degree === -180) {
                currentQuadrant = 28;
            }

            if (this.lastQuadrant !== currentQuadrant) {
                this.view.$force_name_box.addClass("quadrant_" + currentQuadrant + "_force_name" + (isStudent ? "_stu" : ""));
                var i;
                for (i = 1; i <= 28; ++i) {
                    if (i !== currentQuadrant) {
                        this.view.$force_name_box.removeClass("quadrant_" + i + "_force_name" + (isStudent ? "_stu" : ""));
                    }
                }
            }
            this.lastQuadrant = currentQuadrant;
        },
        drag: function drag(x2, y2) {
            // 力的拖拽
            // 更新坐标
            this.x2 = x2;
            this.y2 = y2;
            var degree = Utils.calDegree(this.x1, this.y1, this.x2, this.y2);

            this.view.$ph_force.css({
                "width": Utils.calDistance(this.x1, this.y1, this.x2, this.y2), // 重新计算长度
                //"transform": "rotate(" + degree + "deg) translateZ(5px)"// 重新计算旋转角度
                "transform": "rotate(" + degree + "deg)" // 重新计算旋转角度,IOS适配，去掉translateZ
            });
            this.view.$force_name_box.css("transform", "rotate(" + -degree + "deg)");
            this.view.$force_drag.css({
                "left": this.x2,
                "top": this.y2
            });

            if (this.x1 > this.x2) {
                this.actionPoint.view.$circle_name_box.addClass("reverse_circle_name_box");
            } else {
                this.actionPoint.view.$circle_name_box.removeClass("reverse_circle_name_box");
            }

            this.setForceNameBoxClassByDegree(degree);
        },
        bindActionPoint: function bindActionPoint(actionPoint) {
            // 力关联作用点
            this.actionPoint = actionPoint;
        },
        setVirtual: function setVirtual(isVirtual) {
            // 设置是否为虚线力
            this.isDotted = isVirtual;
            if (isVirtual) {
                this.view.$ph_force.addClass("dotted_line");
            } else {
                this.view.$ph_force.removeClass("dotted_line");
            }
        },
        possessActionPoint: function possessActionPoint(isPossess) {
            this.isPossessActionPoint = isPossess;
            if (isPossess) {
                this.actionPoint.setVirtual(false); // 作用点设置为真实的
                this.actionPoint.hideSelf(false); // 显示作用点
            } else {
                this.actionPoint.setVirtual(true); // 作用点设置为虚拟的
                this.actionPoint.hideSelf(true); // 隐藏作用点
            }
        },
        structurallyDestroy: function structurallyDestroy() {
            // 结构式销毁力对象
            // 结构式销毁力的视图
            this.view.$ph_force.remove();
            this.view.$force_drag.remove();

            // 处理作用点中的共点力记录
            if (this.actionPoint) {
                if (!this.actionPoint.isVirtual) {
                    var structurallyDestroyedObj;
                    for (var i = 0; i < this.actionPoint._concurrentForces.length; i++) {
                        if (this.actionPoint._concurrentForces[i].getId() == this.getId()) {
                            structurallyDestroyedObj = this.actionPoint._concurrentForces.splice(i, 1);
                            break;
                        }
                    }
                    structurallyDestroyedObj = null;
                } else {
                    //虚拟作用点，则连带结构式销毁
                    this.actionPoint.view.$force_circle.remove();
                    this.actionPoint.view.$circle_name_box.remove();
                }
            }
        },
        resetView2Normal: function resetView2Normal() {
            if (this.isAssistant) return;
            // 隐藏确认删除框
            if (this.isShowForceTipsBox) this._toggleForceTipsBox();
            // 力视图恢复为未选中状态
            if (this.isSelected) this._toggleFSelectState();
        },
        hideSelf: function hideSelf(flag) {
            if (flag) {
                this.resetView2Normal();
                this.view.$ph_force.hide();
                if (!this.isComponentForce) {
                    // 不是分力的情况
                    if (this.getIdx() !== undefined) {
                        nameIndexManager.remove(this.getNameChar(), this.getIdx());
                    }
                }
            }
        },
        logicallyDestroy: function logicallyDestroy(isNeedPost) {
            // 逻辑式销毁力对象
            // 力视图恢复为未选中状态 并 隐藏力视图
            this.hideSelf(true);

            if (this.isAssistant) return;

            if (arguments.length === 1 || arguments.length === 2 && typeof arguments[1] === 'boolean' && arguments[1]) {
                // 不销毁作用点场景对象
                var scene;
                if (this.actionPoint) {
                    // 场景被破坏，销毁场景
                    if (this.actionPoint.scene) {
                        scene = this.actionPoint.scene;
                        this.actionPoint.scene.logicallyDestroy();
                    }

                    if (this.actionPoint.isVirtual) {
                        this.actionPoint.hideSelf(true);
                    }
                }
            }

            // 标志力被逻辑删除
            this._beenLogicallyDestroyed = true;

            if (isNeedPost) {
                // 发送消息
                var msg;
                if (this.actionPoint.isVirtual) {
                    msg = {
                        identify: MESSAGE.DROP_NON_CONCURRENT_FORCE,
                        target: this.actionPoint,
                        destroyedScene: scene
                    };
                } else {
                    msg = {
                        identify: MESSAGE.DROP_CONCURRENT_FORCE,
                        target: this,
                        destroyedScene: scene
                    };
                }
                handler.sendMessage(msg);
            }
        },
        restoreFromLogicallyDestroy: function restoreFromLogicallyDestroy() {
            if (this.actionPoint) {
                if (this.actionPoint.isVirtual) {
                    this.actionPoint.hideSelf(true);
                    // 同时把虚拟作用点加入到面板容器
                    panelContainer.add(this.actionPoint);
                }
            }
            this._beenLogicallyDestroyed = false;
            this.view.$ph_force.show();
            if (this.view.$force_drag.hasClass("drag_show")) {
                this.view.$force_drag.removeClass("drag_show");
            }
            if (!this.isComponentForce) {
                nameIndexManager.add(this.getNameChar(), this.getIdx());
            }
        }
    };

    // 2、作用点
    function FPoint(attrData) {
        this.id = Utils.generateGeneralUUID();

        this.x = attrData.x || null; // 作用点的起始点坐标
        this.y = attrData.y || null;

        this.idx = attrData.idx || "";
        this.nameChar = attrData.nameChar || "O";

        this.$panel = attrData.panel || $panel; // 记录该作用点所被添加的面板

        // 作用点记录与自己绑定的共点力——>方便做整体平移
        this._concurrentForces = [];
        this.scene = null; // 记录该共点力的一次 合成 || 分解 场景

        // 样式控制标志位
        this.isVirtual = attrData.isVirtual || false; // 控制是否是虚拟作用点
        this.isHideSelf = attrData.isHideSelf || false; // 控制是否隐藏或显示虚拟作用点

        // 逻辑控制标志位
        this.isShowForceTipsBox = false; // 控制是否显示作用点的确定删除框

        this.isUnderBodilyDragging = attrData.isUnderBodilyDragging || false; // 作用点是否处于可以整体拖动状态

        this._beenLogicallyDestroyed = false;

        // 视图
        this.view = {};

        this.draw();
    }

    FPoint.prototype = {
        constructor: FPoint,
        getMetaData: function getMetaData() {
            var concurrentForces = [];
            var scene;
            if (this._concurrentForces && this._concurrentForces.length > 0) {
                this._concurrentForces.forEach(function (item) {
                    // 过滤掉被逻辑上删除的力视图
                    if (!item._beenLogicallyDestroyed) {
                        concurrentForces.push(item.getMetaData());
                    }
                });
            }
            if (this.scene) {
                scene = this.scene.getMetaData();
            }
            return {
                x: this.x,
                y: this.y,
                isVirtual: this.isVirtual,
                isUnderBodilyDragging: this.isUnderBodilyDragging,
                idx: this.idx,
                nameChar: this.nameChar,
                concurrentForces: concurrentForces,
                scene: scene
            };
        },
        getId: function getId() {
            return this.id;
        },
        getIdx: function getIdx() {
            return this.idx;
        },
        setIdx: function setIdx(idx) {
            this.idx = idx;
        },
        getNameChar: function getNameChar() {
            return this.nameChar;
        },
        setNameChar: function setNameChar(nameChar) {
            this.nameChar = nameChar;
        },
        _initView: function _initView() {
            // 创建作用点的各个部件
            this.view.$force_circle = $('<div class="force_circle" style="left:300px;top:200px;">'); // circle_on || bg_solid || circle_vir || whole_drag
            this.view.$circle_name_box = $('<div class="' + (isStudent ? "circle_name_box_stu" : "circle_name_box") + '" style="transform: rotate(0deg)"></div>');
            this.view.$circle_name_span = $('<div class="circle_name_span_wrapper">' + '<span class="circle_name_f"></span>' + '<span class="circle_name_num"></span>' + '</div>');
            this.view.$circle_name_f = this.view.$circle_name_span.find(".circle_name_f");
            this.view.$circle_name_num = this.view.$circle_name_span.find(".circle_name_num");
            this.view.$moving_state = $('<div class="moving_state"> ' + '' + '<span class="arrows_box"> ' + '<span class="icon_x_pos"></span>' + ' <span class="icon_x_rev"></span> ' + '<span class="icon_y_pos"></span> ' + '<span class="icon_y_rev"></span> ' + '</span> <span class="circle_big"></span>' + '<span class="circle_small"></span> ' + '</div>');

            // 组装控件
            this.view.$circle_name_box.append(this.view.$circle_name_span);
            this.view.$force_circle.append(this.view.$moving_state);

            // 显示到面板上
            this.$panel.append(this.view.$force_circle);
            this.$panel.append(this.view.$circle_name_box);

            // 设置样式
            if (this.isVirtual) {
                this.view.$force_circle.addClass("circle_vir");
            }

            this.view.$circle_name_box.addClass("circle_name_box_" + ('' + this.idx).length + (isStudent ? "_stu" : ""));

            // 隐藏作用点
            if (this.isHideSelf) {
                this.view.$force_circle.hide();
                this.view.$circle_name_box.hide();
            }

            // 设置名字 和 角标
            this.view.$circle_name_f.html(this.nameChar);
            this.view.$circle_name_num.html(this.idx);

            // 设置偏移位置
            this.view.$force_circle.css({
                "left": this.x,
                "top": this.y
            });
            this.view.$circle_name_box.css({
                "left": this.x,
                "top": this.y
            });
        },
        _toggleForceTipsBox: function _toggleForceTipsBox() {
            var __self = this;
            __self.isShowForceTipsBox = !__self.isShowForceTipsBox;
            if (__self.isShowForceTipsBox) {
                __self.view.$circle_name_box.addClass("name_edit");
                preHandledObj = __self;
                $nameInput.val(__self.nameChar + __self.idx);
                i18nHelper.renderDelConfirmBtn();
                $delConfirmBtn.css({
                    left: __self.x,
                    top: __self.y
                }).show();
                $nameInput.focus();
                __self.view.$circle_name_span.hide();
            } else {
                if (__self.view.$circle_name_box.hasClass("name_edit")) {
                    __self.view.$circle_name_box.removeClass("name_edit");
                }
                $nameInput.blur();
                preHandledObj = null;
                $delConfirmBtn.hide();
                __self.view.$circle_name_span.show();
            }
        },
        set2BodilyDraggingState: function set2BodilyDraggingState(state) {
            var __self = this;
            var isShow = false;

            // 判断显示还是隐藏
            if (arguments.length === 0 || state) {
                this.isUnderBodilyDragging = true;
                $pointBodilyDraggingBtn.show();
                isShow = true;
            } else {
                this.isUnderBodilyDragging = false;
                $pointBodilyDraggingBtn.hide();
            }

            if (isShow) {
                // 设置方向 朝左 or 朝右
                if (__self.x <= PANEL_BORDER.CENTER) {
                    $pointBodilyDraggingBtn.css({
                        left: __self.x + BODILY_DRAG_SIZE.OFFSET_X,
                        top: __self.y
                    });
                } else {
                    $pointBodilyDraggingBtn.css({
                        left: __self.x - BODILY_DRAG_SIZE.OFFSET_X,
                        top: __self.y
                    });
                }
            }
        },
        _bindEvent: function _bindEvent() {
            var __self = this;

            /*************************************** Logic 绘制共点力 and 整体拖拽 ***************************************/

            this.view.$force_circle.on("touchstart mousedown", function (circleDownEvt) {
                // 创建共点力逻辑

                var isClickEvt = true;

                var concurrentForce;
                var hasCreateConcurrentForceView = false;

                var circleDownEvent = Utils.getEvent(circleDownEvt);
                Utils.preventDefault(circleDownEvt);
                Utils.stopPropagation(circleDownEvent);

                // 获取点击的坐标
                var downPos = Utils.conversionCursorPos(circleDownEvent, $panel);

                // 编辑态的切换业务
                if (preHandledObj) {
                    if (preHandledObj.getId() == __self.getId()) {
                        return;
                    } else {
                        preHandledObj._toggleForceTipsBox();
                    }
                }

                $panel.on("touchmove mousemove", function (panelMoveEvt) {
                    var panelMoveEvent = Utils.getEvent(panelMoveEvt);
                    // 获取移动的坐标
                    var movePos = Utils.conversionCursorPos(panelMoveEvent, $panel);

                    // 设置判断为点击的抖动范围
                    if (Utils.calDistance(downPos.x, downPos.y, movePos.x, movePos.y) < 10) {
                        isClickEvt = true;
                        return;
                    } else {
                        isClickEvt = false;
                    }

                    // 创建共点力
                    if (currentPanelState == STATE.CAN_DRAW_F && !__self.isVirtual) {
                        if (!preHandledObj) {
                            if (!hasCreateConcurrentForceView && Utils.calDistance(__self.x, __self.y, movePos.x, movePos.y) > 26) {
                                // 创建共点力
                                var concurrentForceAttrData = {
                                    x1: __self.x,
                                    y1: __self.y,
                                    x2: movePos.x,
                                    y2: movePos.y,
                                    nameChar: 'F',
                                    idx: nameIndexManager.generateIdx('F'),
                                    isDotted: true
                                };
                                concurrentForce = new F(concurrentForceAttrData);

                                // 共点力与作用点相互关联
                                concurrentForce.bindActionPoint(__self);
                                __self.bindConcurrentForce(concurrentForce);

                                hasCreateConcurrentForceView = true;
                            } else if (hasCreateConcurrentForceView) {
                                // 拖拽共点力视图
                                if (Utils.applyBorderCtrl({
                                    'tag': TAG.CREATE_CONCURRENT_F,
                                    'movePos': movePos,
                                    'hasCreateConcurrentForceView': hasCreateConcurrentForceView,
                                    'concurrentForce': concurrentForce,
                                    'fPRef': __self
                                })) {
                                    return;
                                }
                                concurrentForce.drag(movePos.x, movePos.y);
                            }
                        }
                    }
                });
                $panel.on("touchend mouseup", function (panelUpEvt) {
                    var panelUpEvent = Utils.getEvent(panelUpEvt);
                    var upPos = Utils.conversionCursorPos(panelUpEvent, $panel);
                    if (isClickEvt) {
                        if (!currentHandledPoint) {
                            currentHandledPoint = __self;
                        }
                        if (currentHandledPoint !== __self) {
                            // 点击了另一个作用点
                            currentHandledPoint.set2BodilyDraggingState(false); // 把之前作用点取消拖动按钮状态
                            __self.set2BodilyDraggingState(true);
                            currentHandledPoint = __self;
                        } else {
                            // 再次点击了同一个作用点则是切换状态
                            __self.isUnderBodilyDragging ? __self.set2BodilyDraggingState(false) : __self.set2BodilyDraggingState(true);
                        }
                    } else {
                        // 校验是否成功创建共点力
                        CreationOperationVerification.verifyConcurrentForcesCreation({
                            'fPRef': __self,
                            'pos': upPos,
                            'concurrentForce': concurrentForce,
                            'hasCreateConcurrentForceView': hasCreateConcurrentForceView
                        });
                    }

                    $panel.off("mousemove touchmove");
                    $panel.off("mouseup touchend");
                });
            });
            this.view.$force_circle.on("mouseover touchstart", function () {
                __self.view.$force_circle.addClass("circle_on");
            });
            this.view.$force_circle.on("mouseout touchend", function () {
                if (__self.view.$force_circle.hasClass("circle_on")) {
                    __self.view.$force_circle.removeClass("circle_on");
                }
            });

            /*************************************** Logic 绘制共点力 ***************************************/

            this.view.$circle_name_box.on("touchstart mousedown", function (evt) {
                // 阻止冒泡
                Utils.stopPropagation(Utils.getEvent(evt));
                Utils.preventDefault(Utils.getEvent(evt));
                $(evt.target).trigger("mousedown touchstart");
            });
            this.view.$circle_name_span.on("mousedown touchstart", function () {
                if (__self.isVirtual) {
                    return;
                }
                Utils.turnOffBodilyDraggingState();
                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                }
                __self._toggleForceTipsBox();
            });
        },
        _init: function _init() {
            this._initView();
            this._bindEvent();
        },
        draw: function draw() {
            // 作用点的绘制
            this._init();
        },
        setVirtual: function setVirtual(isVirtual) {
            // 设置是否为虚拟作用点
            this.isVirtual = isVirtual;
            if (isVirtual) {
                this.view.$force_circle.addClass("circle_vir");
            } else {
                this.view.$force_circle.removeClass("circle_vir");
            }
        },
        bindScene: function bindScene(obj) {
            this.scene = obj;
        },
        bindConcurrentForce: function bindConcurrentForce(concurrentForce) {
            // 作用点关联共点力
            if (concurrentForce instanceof F) {
                this._concurrentForces.push(concurrentForce);
            }
        },
        unbindConcurrentForce: function unbindConcurrentForce(obj) {
            if (obj instanceof F) {
                this._concurrentForces.deletePhysicsSynthesisObj(obj);
            }
        },
        setName: function setName(data) {
            this.nameChar = data.name;
            this.idx = parseInt(data.idx);
            nameIndexManager.add(this.nameChar, this.idx);
            this.view.$circle_name_f.html(this.nameChar);
            this.view.$circle_name_num.html(this.idx);
            var i;
            var len = ('' + data.idx).length;
            this.view.$circle_name_box.addClass("circle_name_box_" + len + (isStudent ? "_stu" : ""));
            for (i = 1; i <= 3; ++i) {
                if (i !== len) {
                    this.view.$circle_name_box.removeClass("circle_name_box_" + i + (isStudent ? "_stu" : ""));
                }
            }
        },
        hideSelf: function hideSelf(isHide) {
            // 隐藏或显示作用点
            this.isHideSelf = isHide;
            if (isHide) {
                if (this.isShowForceTipsBox) {
                    this._toggleForceTipsBox();
                }
                this.view.$force_circle.hide();
                this.view.$circle_name_box.hide();
                if (!this.isVirtual && this.getIdx() !== undefined) {
                    nameIndexManager.remove(this.getNameChar(), this.getIdx());
                }
            } else {
                this.view.$force_circle.show();
                this.view.$circle_name_box.show();
                if (!this.isVirtual && this.getIdx() !== undefined) {
                    nameIndexManager.add(this.getNameChar(), this.getIdx());
                }
            }
        },
        translate: function translate(moveX, moveY) {
            // 作用点的平移
            this.view.$force_circle.css({
                "left": moveX,
                "top": moveY
            });
            this.view.$circle_name_box.css({
                "left": moveX,
                "top": moveY
            });

            // 更新作用点坐标
            this.x = moveX;
            this.y = moveY;

            // 平移绑定的场景信息
            if (this.scene) {
                this.scene.translate(moveX, moveY);
            }

            // 平移绑定的共点力
            this.translateConcurrentForces(moveX, moveY);
        },
        translateConcurrentForces: function translateConcurrentForces(moveX, moveY) {
            var i = 0;
            var size;
            if (size = this._concurrentForces.length) {
                for (i = 0; i < size; ++i) {
                    this._concurrentForces[i].translate(moveX, moveY);
                }
            }
        },
        _removeThisFromConcurrentForces: function _removeThisFromConcurrentForces(obj) {
            this._concurrentForces.deletePhysicsSynthesisObj(obj);
        },
        structurallyDestroy: function structurallyDestroy() {
            // 结构式销毁作用点对象
            // 结构式销毁作用点视图
            this.view.$force_circle.remove();
            this.view.$circle_name_box.remove();

            // 结构式销毁绑定的共点力视图
            var structurallyDestroyedObj;
            while (this._concurrentForces.length > 0) {
                structurallyDestroyedObj = this._concurrentForces.shift();
                structurallyDestroyedObj.structurallyDestroy();
            }

            // 销毁场景
            if (this.scene) {
                this.scene.logicallyDestroy();
            }
        },
        logicallyDestroy: function logicallyDestroy(isNeedPost) {
            // 逻辑式删除作用点对象
            // 隐藏作用点自己
            this.hideSelf(true);

            // 只是隐藏所有共点力，不设置共点力的"_beenLogicallyDestroyed"标志位
            var size;
            if (size = this._concurrentForces.length) {
                var currentF;
                for (var i = size - 1; i >= 0; --i) {
                    currentF = this._concurrentForces[i];
                    currentF.hideSelf(true);
                }
            }

            // 标志作用点被逻辑删除
            this._beenLogicallyDestroyed = true;

            if (isNeedPost) {
                // 发送消息
                handler.sendMessage({
                    identify: MESSAGE.DROP_POINT,
                    target: this,
                    destroyedScene: this.scene
                });
            }

            // 销毁绑定的场景
            if (this.scene) {
                this.scene.logicallyDestroy();
            }
        },
        restoreFromLogicallyDestroy: function restoreFromLogicallyDestroy() {
            // 恢复显示作用点
            this.hideSelf(false);

            // 恢复逻辑式销毁绑定的共点力
            var size;
            if (size = this._concurrentForces.length) {
                for (var i = 0; i < size; i++) {
                    if (!this._concurrentForces[i]._beenLogicallyDestroyed) {
                        // 不是被手动删除，删除作用点的时候一并隐藏共点力情况
                        this._concurrentForces[i].restoreFromLogicallyDestroy();
                    }
                }
            }
        }
    };

    // 3、场景
    function Scene(attrData) {
        this.associatedPoint = attrData.associatedPoint || null;
        this.type = attrData.type || SCENE_TYPE.FD; // 场景类型：SCENE_TYPE.FD：分解场景 SCENE_TYPE.FC：合成场景
        this.joinForces = []; // 记录合力
        this.componentForces = []; // 记录分力
        this.auxiliaryLines = []; // 记录辅助线
        this.coordinates = null; // 记录坐标轴
    }

    Scene.prototype = {
        constructor: Scene,
        getMetaData: function getMetaData() {
            var _self = this;
            var auxiliaryLines = [];
            var componentForces = [];
            var joinForces = [];
            var coordinates;
            if (_self.auxiliaryLines.length > 0) {
                _self.auxiliaryLines.forEach(function (item) {
                    auxiliaryLines.push(item.getMetaData());
                });
            }
            if (_self.componentForces.length > 0) {
                _self.componentForces.forEach(function (item) {
                    componentForces.push(item.getMetaData());
                });
            }
            if (_self.joinForces.length > 0) {
                _self.joinForces.forEach(function (item) {
                    joinForces.push(item.getMetaData());
                });
            }
            if (_self.coordinates) {
                coordinates = _self.coordinates.getMetaData();
            }
            return {
                type: _self.type,
                componentForces: componentForces,
                joinForces: joinForces,
                auxiliaryLines: auxiliaryLines,
                coordinates: coordinates
            };
        },
        _bindActionPoint: function _bindActionPoint() {
            this.associatedPoint.scene = this;
        },
        _unbindActionPoint: function _unbindActionPoint() {
            this.associatedPoint.scene = null;
        },
        recordJoinForce: function recordJoinForce(obj) {
            // 记录合力
            this.joinForces.push(obj);
        },
        recordComponentForce: function recordComponentForce(obj) {
            // 记录分力
            this.componentForces.push(obj);
        },
        recordAuxiliaryLine: function recordAuxiliaryLine(obj) {
            // 记录辅助线
            this.auxiliaryLines.push(obj);
        },
        recordCoordinates: function recordCoordinates(obj) {
            // 记录坐标轴
            this.coordinates = obj;
        },
        translate: function translate(moveX, moveY) {
            // 场景的平移
            var deltaX = 0;
            var deltaY = 0;

            // 平移坐标轴
            if (this.coordinates) {
                this.coordinates.translate(moveX, moveY);
            }

            // 平移分力
            var size;
            if (this.componentForces && (size = this.componentForces.length)) {
                deltaX = moveX - this.componentForces[0].x1;
                deltaY = moveY - this.componentForces[0].y1;
                for (var i = 0; i < size; ++i) {
                    this.componentForces[i].translate(moveX, moveY);
                }
            }

            // 平移合力
            if (this.joinForces && (size = this.joinForces.length)) {
                deltaX = moveX - this.joinForces[0].x1;
                deltaY = moveY - this.joinForces[0].y1;
                for (i = 0; i < size; ++i) {
                    this.joinForces[i].translate(moveX, moveY);
                }
            }

            // 平移辅助线
            if (this.auxiliaryLines && (size = this.auxiliaryLines.length)) {
                for (i = 0; i < size; ++i) {
                    this.auxiliaryLines[i].translate(deltaX, deltaY);
                }
            }
        },
        logicallyDestroy: function logicallyDestroy() {
            this._unbindActionPoint();
            if (this.coordinates) {
                this.coordinates.logicallyDestroy();
            }
            var size;
            if (this.auxiliaryLines && (size = this.auxiliaryLines.length)) {
                for (var i = 0; i < size; ++i) {
                    this.auxiliaryLines[i].logicallyDestroy();
                }
            }
            if (this.type == SCENE_TYPE.FD) {
                if (this.componentForces && (size = this.componentForces.length)) {
                    for (i = 0; i < size; ++i) {
                        this.componentForces[i].logicallyDestroy();
                    }
                }
            }
            if (this.type == SCENE_TYPE.FC) {
                if (this.joinForces && (size = this.joinForces.length)) {
                    for (i = 0; i < size; ++i) {
                        this.joinForces[i].logicallyDestroy(MESSAGE.NO_NEED_POST);
                    }
                }
            }
        },
        restoreFromLogicallyDestroy: function restoreFromLogicallyDestroy() {
            this._bindActionPoint();
            if (this.coordinates) {
                this.coordinates.restoreFromLogicallyDestroy();
            }
            var size;
            if (this.auxiliaryLines && (size = this.auxiliaryLines.length)) {
                for (var i = 0; i < size; ++i) {
                    this.auxiliaryLines[i].restoreFromLogicallyDestroy();
                }
            }
            if (this.type == SCENE_TYPE.FD) {
                if (this.componentForces && (size = this.componentForces.length)) {
                    for (i = 0; i < size; ++i) {
                        this.componentForces[i].restoreFromLogicallyDestroy();
                    }
                }
            }
            if (this.type == SCENE_TYPE.FC) {
                if (this.joinForces && (size = this.joinForces.length)) {
                    for (i = 0; i < size; i++) {
                        this.joinForces[i].restoreFromLogicallyDestroy();
                    }
                }
            }
        }
    };

    // 4、坐标轴
    function Coordinates(attrData) {
        this.x = attrData.x || 300;
        this.y = attrData.y || 300;
        this.xPositiveLen = attrData.xPositiveLen || 300;
        this.xNegativeLen = attrData.xNegativeLen || 300;
        this.yPositiveLen = attrData.yPositiveLen || 300;
        this.yNegativeLen = attrData.yNegativeLen || 300;

        this.$co_origin = null;
        this.$x_positive_span = null;
        this.$x_reverse_span = null;
        this.$y_positive_span = null;
        this.$y_reverse_span = null;

        this.draw();
    }

    Coordinates.prototype = {
        constructor: Coordinates,
        // 获取元数据
        getMetaData: function getMetaData() {
            return {
                x: this.x,
                y: this.y,
                xPositiveLen: this.xPositiveLen,
                xNegativeLen: this.xNegativeLen,
                yPositiveLen: this.yPositiveLen,
                yNegativeLen: this.yNegativeLen
            };
        },
        initView: function initView() {
            this.$co_origin = $('<div class="co_origin"></div>');
            this.$x_positive_span = $('<span class="x_positive iconfont"><span class="icon_jt">&#xe613;</span></span>');
            this.$x_reverse_span = $('<span class="x_reverse"></span>');
            this.$y_positive_span = $('<span class="y_positive iconfont"><span class="icon_jt">&#xe613;</span></span>');
            this.$y_reverse_span = $('<span class="y_reverse"></span>');

            this.$co_origin.append(this.$x_positive_span);
            this.$co_origin.append(this.$x_reverse_span);
            this.$co_origin.append(this.$y_positive_span);
            this.$co_origin.append(this.$y_reverse_span);
            $panel.append(this.$co_origin);

            // 设置偏移位置
            this.$co_origin.css({
                "left": this.x,
                "top": this.y
            });

            // 设置四个方向的长度
            this.$x_positive_span.css("width", this.xPositiveLen);
            this.$x_reverse_span.css("width", this.xNegativeLen);
            this.$y_positive_span.css("width", this.yPositiveLen);
            this.$y_reverse_span.css("width", this.yNegativeLen);
        },
        translate: function translate(moveX, moveY) {
            // 更新元数据
            this.x = moveX;
            this.y = moveY;

            // 视图的平移
            this.$co_origin.css({
                "left": moveX,
                "top": moveY
            });
        },
        setXPositiveLen: function setXPositiveLen(len) {
            this.xPositiveLen = len;
            this.$x_positive_span.css("width", len);
        },
        setXReverseLen: function setXReverseLen(len) {
            this.xNegativeLen = len;
            this.$x_reverse_span.css("width", len);
        },
        setYPositiveLen: function setYPositiveLen(len) {
            this.yPositiveLen = len;
            this.$y_positive_span.css("width", len);
        },
        setYReverseLen: function setYReverseLen(len) {
            this.yNegativeLen = len;
            this.$y_reverse_span.css("width", len);
        },
        draw: function draw() {
            this.initView();
        },
        logicallyDestroy: function logicallyDestroy() {
            this.$co_origin.hide();
        },
        restoreFromLogicallyDestroy: function restoreFromLogicallyDestroy() {
            this.$co_origin.show();
        },
        structurallyDestroy: function structurallyDestroy() {
            this.$co_origin.remove();
        }
    };

    // 4、虚线
    function DashLine(attrData) {
        this.x1 = attrData.x1 || 300;
        this.y1 = attrData.y1 || 300;
        this.x2 = attrData.x2 || 400;
        this.y2 = attrData.y2 || 400;

        this.isTranslucent = attrData.isTranslucent || false;

        this.$line_dashed = null;
        this.aux_line = null;

        this.color = attrData.color || null;

        this.draw();
    }

    DashLine.prototype = {
        constructor: DashLine,
        // 获取元数据
        getMetaData: function getMetaData() {
            return {
                x1: this.x1,
                y1: this.y1,
                x2: this.x2,
                y2: this.y2,
                isTranslucent: this.isTranslucent,
                color: this.color
            };
        },
        _initView: function _initView() {
            // bg_translucent 半透明
            this.$line_dashed = $('<div class="line_dashed" style="top:60px; left:276px; width:200px;transform: rotate(20deg);"></div>');
            this.aux_line = $('<div class="Aux_line"></div>');

            this.$line_dashed.append(this.aux_line);

            $panel.append(this.$line_dashed);

            // 设置半透明
            if (this.isTranslucent) {
                this.$line_dashed.addClass("bg_translucent");
            }

            // 设置颜色
            if (this.color) {
                this.$line_dashed.addClass(this.color);
            }

            this.$line_dashed.css({
                "left": this.x1, // 设置偏移位置
                "top": this.y1,
                "width": Utils.calDistance(this.x1, this.y1, this.x2, this.y2), // 计算长度
                "transform": "rotate(" + Utils.calDegree(this.x1, this.y1, this.x2, this.y2) + "deg)" // 计算旋转角度
            });
        },
        translate: function translate(deltaX, deltaY) {
            // 更新元数据
            this.x1 += deltaX;
            this.y1 += deltaY;
            this.x2 += deltaX;
            this.y2 += deltaY;

            // 视图的平移
            this.$line_dashed.css({
                "left": this.x1, // 设置偏移位置
                "top": this.y1
            });
        },
        draw: function draw() {
            this._initView();
        },
        logicallyDestroy: function logicallyDestroy() {
            this.$line_dashed.hide();
        },
        restoreFromLogicallyDestroy: function restoreFromLogicallyDestroy() {
            this.$line_dashed.show();
        },
        structurallyDestroy: function structurallyDestroy() {
            this.$line_dashed.remove();
        }
    };

    /********************************************************************************************************/

    var Presenter = BasicPresenter.extend({
        metaInfo: {
            name: 'PhysicsPower',
            type: PresenterType.PRESENTER_COMPONENT
        },
        /**
         * Presenter的初始化方法
         * @private
         */
        $init: function $init() {
            this._super();
        },
        /**
         * Presenter对外暴露的方法
         */
        _service_: {
            constructor: function constructor(parent) {
                this.parent = parent;
            },
            getQuestionInfo: function getQuestionInfo() {
                return {
                    'id': '',
                    'type_code': 'PhysicsPower',
                    'type_name': '物理合力',
                    'url': '',
                    'notExistStatistics': true,
                    'noNeedQuizProgress': true
                };
            },
            getExtendData: function getExtendData() {
                return {
                    width: '100%',
                    // 更新老师端需要同步的面板数据
                    panelState: {
                        syncData: PhysicsSynthesis.updateSyncData(),
                        nameIndexManager: nameIndexManager,
                        toolBarState: toolBarState,
                        possessActionPoint: possessActionPoint
                    }
                };
            },
            setLocationProperties: function setLocationProperties(properties) {
                i18nHelper.lanKeySet = properties;
            }
        },
        getService: function getService() {
            this._service_.constructor(this);
            return this._service_;
        },
        __interface: {
            resizeScreen: function resizeScreen(data) {
                PANEL_BORDER.BOTTOM *= data.ratio;
                PANEL_BORDER.RIGHT *= data.ratio;
                PANEL_BORDER.CENTER *= data.ratio;
            }
        },
        /****以下开始为icPlayer的生命周期方法*****/
        run: function run(view, model) {
            findView();
            init();
            if (model.__ExtendModel && !$.isEmptyObject(model.__ExtendModel)) {
                var deferred = $.Deferred();
                // 获取__ExtendModel中缓存的面板状态数据
                panelState = model.__ExtendModel.panelState;

                /**
                 * 学生端同步老师端
                 */
                if (this.currentRuntime === icCreatePlayer.RUNTIME.STUDENT_MOBILE) {
                    isStudent = true;

                    // 根据策划的要求：学生端缩小力和作用点的字体
                    $traverseParent.addClass('font_small');
                }

                // 由于101PPT视图异步渲染导致这里需要异步渲染
                window.setTimeout(function () {
                    // 初始化学生端的边界控制常量
                    if (PANEL_BORDER) {
                        if (!PANEL_BORDER.BOTTOM) {
                            PANEL_BORDER.BOTTOM = ($traverseParent.height() - 15) / scaleRatio;
                            PANEL_BORDER.RIGHT = ($traverseParent.width() - 15) / scaleRatio;
                            PANEL_BORDER.LEFT = 15 / scaleRatio;
                            PANEL_BORDER.TOP = 15 / scaleRatio;
                            PANEL_BORDER.CENTER = $traverseParent.width() / 2 / scaleRatio;
                        }
                    }

                    // 学生端同步老师端绘制内容
                    PhysicsSynthesis.renderSyncData(panelState.syncData);

                    // 初始化推送后学生端的下标管理器
                    nameIndexManager.setData(panelState.nameIndexManager);

                    // 学生端同步老师端工具栏状态
                    toolBarState = panelState.toolBarState;
                    if (toolBarState) {
                        for (var p in toolBarState) {
                            if (toolBarState.hasOwnProperty(p)) {
                                if (toolBarState[p]) {
                                    eval('$' + p + '.trigger(\'touchstart\')');
                                }
                            }
                        }
                    }

                    // 学生端同步老师端当前面板是否处于绘制无作用点力
                    possessActionPoint = panelState.possessActionPoint;
                    if (!panelState.possessActionPoint) {
                        $sliderRegion.removeClass(STYLE_CLASS.CHECKED);
                    }

                    // 学生端同步老师端当前处于可拖动状态的力或作用点
                    for (var i = 0; i < panelContainer.size(); ++i) {
                        if (panelContainer._array[i].isUnderBodilyDragging) {
                            currentHandledPoint = panelContainer._array[i];
                            currentHandledPoint.set2BodilyDraggingState(true);
                            break;
                        }
                    }
                    deferred.resolve();
                }, 1000);
                return deferred.promise();
            }
        },
        pageShow: function pageShow() {
            this._bindEvent();
        },
        pageLeave: function pageLeave() {
            this._unbindEvent();
        },
        destroy: function destroy() {},
        /**如果不需要处理icplayer的状态恢复事件, 请将以下两个方法删除掉**/
        getState: function getState() {},
        setState: function setState(state, options) {},
        /****以下开始为Presenter的私有方法*****/
        _bindEvent: function _bindEvent() {
            //画作用点
            $btnDrawFP.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                switchState(STATE.CAN_DRAW_FP);
            });
            //画作用力
            $btnDrawF.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                switchState(STATE.CAN_DRAW_F);
            });

            /********************************** $panel logic 力的合成 **********************************/

            $btnFCompound.on('mousedown touchstart', function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                if ($(this).hasClass('click_disabled')) return;
                switchState(STATE.CAN_DO_FC);
                Consult.updateFCFDPopupWindow();
            });
            $compoundPWConfirm.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                if ($(this).hasClass("click_disabled")) {
                    return;
                }
                var concurrentForces;
                var scenes = [];
                var scene;
                while (cdQ._array.length > 0) {
                    concurrentForces = cdQ.deQueue();
                    scene = PhysicsSynthesis.doFCompound(concurrentForces);
                    if (scene) {
                        scenes.push(scene);
                    }
                }
                if (scenes && scenes.length > 0) {
                    handler.sendMessage({
                        identify: MESSAGE.COMPOUND_FORCES,
                        scenes: scenes
                    });
                }
                switchState(STATE.CAN_DO_FC);
            });
            $compoundPWCancel.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                switchState(STATE.CAN_DO_FC);
            });

            /********************************** $panel logic 力的分解 **********************************/

            $btnFDecompose.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                if ($(this).hasClass('click_disabled')) return;
                switchState(STATE.CAN_DO_FD);
                Consult.updateFCFDPopupWindow();
            });
            $decomposePWConfirm.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                Utils.turnOffBodilyDraggingState();
                if ($decomposePWConfirm.hasClass("click_disabled")) {
                    return;
                }
                var concurrentForces;
                var scenes = [];
                var scene;
                while (cdQ._array.length > 0) {
                    concurrentForces = cdQ.deQueue();
                    scene = PhysicsSynthesis.doFDecompose(concurrentForces);
                    if (scene) {
                        scenes.push(scene);
                    }
                }
                if (scenes && scenes.length > 0) {
                    handler.sendMessage({
                        identify: MESSAGE.DECOMPOSE_FORCES,
                        scenes: scenes
                    });
                }
                switchState(STATE.CAN_DO_FD);
            });
            $decomposePWCancel.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                Utils.turnOffBodilyDraggingState();
                switchState(STATE.CAN_DO_FD);
            });

            // 作用点的整体拖动
            $pointBodilyDraggingBtn.on("mousedown touchstart", function (downEvt) {
                var downEvent = Utils.getEvent(downEvt);
                Utils.preventDefault(downEvent);
                Utils.stopPropagation(downEvent);
                var downPos = Utils.conversionCursorPos(downEvent, $panel);

                Utils.set2PenetrateState([$compoundPopupWindow, $decomposePopupWindow], true);

                var judgeAsMove = false;

                $pointBodilyDraggingBtn.addClass("active");
                $panel.on("mousemove touchmove", function (moveEvt) {
                    var moveEvent = Utils.getEvent(moveEvt);
                    var movePos = Utils.conversionCursorPos(moveEvent, $panel);

                    if (!judgeAsMove && Utils.calDistance(downPos.x, downPos.y, movePos.x, movePos.y) > 10) {
                        judgeAsMove = true;
                        handler.sendMessage({
                            identify: MESSAGE.TRANSLATE_POINT,
                            target: currentHandledPoint,
                            preState: {
                                x: currentHandledPoint.x,
                                y: currentHandledPoint.y
                            }
                        });
                    }

                    if (judgeAsMove) {
                        $pointBodilyDraggingBtn.css({
                            "left": movePos.x,
                            "top": movePos.y
                        });

                        if (Utils.applyBorderCtrl({
                            'tag': TAG.DRAG_F_OR_FP,
                            'movePos': movePos,
                            'fPRef': currentHandledPoint
                        })) {
                            $pointBodilyDraggingBtn.removeClass("active");
                            return;
                        }
                        currentHandledPoint.translate(movePos.x, movePos.y); // 作用点偏移
                    }
                });
                $panel.on("touchend mouseup", function () {
                    // 设置方向 朝左 or 朝右
                    if (currentHandledPoint.x <= PANEL_BORDER.CENTER) {
                        $pointBodilyDraggingBtn.css({
                            left: currentHandledPoint.x + BODILY_DRAG_SIZE.OFFSET_X,
                            top: currentHandledPoint.y
                        });
                    } else {
                        $pointBodilyDraggingBtn.css({
                            left: currentHandledPoint.x - BODILY_DRAG_SIZE.OFFSET_X,
                            top: currentHandledPoint.y
                        });
                    }
                    Utils.set2PenetrateState([$compoundPopupWindow, $decomposePopupWindow], false);
                    $pointBodilyDraggingBtn.removeClass("active");
                    $panel.off("mousemove touchmove");
                    $panel.off("touchend mouseup");
                });
            });

            $deleteBtn.on("mousedown touchstart", function (deleteBtnDownEvt) {
                var downEvent = Utils.getEvent(deleteBtnDownEvt);
                Utils.preventDefault(downEvent);
                Utils.stopPropagation(downEvent);
                if (preHandledObj) {
                    preHandledObj.logicallyDestroy(MESSAGE.NEED_POST); //会执行this.hideSelf(true);
                }
            });
            $confirmBtn.on("mousedown touchstart", function (confirmBtnDownEvt) {
                var downEvent = Utils.getEvent(confirmBtnDownEvt);
                Utils.preventDefault(downEvent);
                Utils.stopPropagation(downEvent);
                if (preHandledObj) {
                    var name, cornerMark;
                    var nameRegExp = /^[A-Z][1-9]+[0-9]*$/;
                    // 对用户的输入值进行验证
                    var val = $nameInput.val().replace(/\s/g, "");
                    if (nameRegExp.test(val)) {
                        name = val.charAt(0);
                        if (val.length > 4) {
                            cornerMark = val.substring(1, 4);
                        } else {
                            cornerMark = val.substring(1, val.length);
                        }
                    } else {
                        name = preHandledObj.nameChar;
                        cornerMark = preHandledObj.idx;
                    }

                    val = name + cornerMark;

                    // 撤销恢复逻辑
                    if (val !== preHandledObj.getNameChar() + preHandledObj.getIdx()) {
                        // 判断当前面板是否已经有该名字了
                        if (nameIndexManager.checkExist(name, cornerMark)) {
                            preHandledObj._toggleForceTipsBox();
                            return;
                        }

                        // 可执行修改名字逻辑
                        nameIndexManager.remove(preHandledObj.getNameChar(), preHandledObj.getIdx());

                        var lastIdxLen = ('' + preHandledObj.idx).length,
                            currentIdxLen = cornerMark.length;
                        if (preHandledObj instanceof FPoint && currentIdxLen !== lastIdxLen) {
                            preHandledObj.view.$circle_name_box.removeClass("circle_name_box_" + lastIdxLen + (isStudent ? "_stu" : ""));
                            preHandledObj.view.$circle_name_box.addClass("circle_name_box_" + currentIdxLen + (isStudent ? "_stu" : ""));
                        }

                        // 发送用户修改名字的消息
                        handler.sendMessage({
                            identify: MESSAGE.RENAME_OBJ,
                            target: preHandledObj,
                            preState: {
                                nameData: {
                                    name: preHandledObj.nameChar,
                                    idx: preHandledObj.idx
                                }
                            }
                        });
                        preHandledObj.setName({
                            name: name,
                            idx: cornerMark
                        });
                    }
                    preHandledObj._toggleForceTipsBox();
                }
            });
            $nameInput.on("mousedown touchstart", function (downEvent) {
                //Utils.preventDefault(downEvent);// 不可阻止输入框的默认行为
                Utils.stopPropagation(downEvent);
                $nameInput.focus();
            });
            /********************************** $panel logic 创建力 and 创建作用点 **********************************/

            $panel.on("mousedown touchstart", function (downEvt) {
                var downEvent = Utils.getEvent(downEvt);
                Utils.preventDefault(downEvent);
                Utils.stopPropagation(downEvent);

                // 由于播放器异步渲染的机制导致可能拿不到面板顶层容器的尺寸，所以该参数延迟到用户点击了绘制面板才初始化
                if (PANEL_BORDER) {
                    if (!PANEL_BORDER.BOTTOM) {
                        PANEL_BORDER.BOTTOM = ($traverseParent.height() - 15) / scaleRatio;
                        PANEL_BORDER.RIGHT = ($traverseParent.width() - 15) / scaleRatio;
                        PANEL_BORDER.LEFT = 15 / scaleRatio;
                        PANEL_BORDER.TOP = 15 / scaleRatio;
                        PANEL_BORDER.CENTER = $traverseParent.width() / 2 / scaleRatio;
                    }
                }

                if (currentHandledPoint) {
                    if (currentHandledPoint.isUnderBodilyDragging) {
                        currentHandledPoint.set2BodilyDraggingState(false);
                        return;
                    }
                }
                var downPos = Utils.conversionCursorPos(downEvent, $panel);

                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                    return;
                }

                if (currentPanelState == STATE.CAN_DRAW_FP || currentPanelState == STATE.CAN_DRAW_F) {
                    if (downPos.x < PANEL_BORDER.LEFT + 20 || downPos.x > PANEL_BORDER.RIGHT - 20 || downPos.y < PANEL_BORDER.TOP + 20 || downPos.y > PANEL_BORDER.BOTTOM - 20) {
                        return;
                    }

                    // 创建临时作用点
                    var actionPointAttrData = {
                        x: downPos.x,
                        y: downPos.y,
                        nameChar: 'O',
                        idx: nameIndexManager.generateIdx('O'),
                        isVirtual: true,
                        panel: $panel
                    };
                    var actionPoint = new FPoint(actionPointAttrData);

                    var tmpF; // 待创建的临时力句柄
                    var alreadyNewF = false; // 标志是否已经创建了力视图
                    $panel.on("touchmove mousemove", function (moveEvt) {
                        var moveEvent = Utils.getEvent(moveEvt);
                        var movePos = Utils.conversionCursorPos(moveEvent, $panel);

                        if (currentPanelState == STATE.CAN_DRAW_FP) {
                            if (movePos.x < PANEL_BORDER.LEFT || movePos.x > PANEL_BORDER.RIGHT || movePos.y > PANEL_BORDER.BOTTOM || movePos.y < PANEL_BORDER.TOP) {
                                actionPoint.structurallyDestroy();
                                // 解除所有命名空间下的事件绑定
                                $panel.off("mousemove touchmove");
                                $panel.off("mouseup touchend");
                                return;
                            }
                        }

                        if (currentPanelState == STATE.CAN_DRAW_F) {
                            if (!alreadyNewF && Utils.calDistance(downPos.x, downPos.y, movePos.x, movePos.y) > 26) {
                                // 创建临时作用力
                                var fAttrData = {
                                    x1: downPos.x,
                                    y1: downPos.y,
                                    x2: movePos.x,
                                    y2: movePos.y,
                                    idx: nameIndexManager.generateIdx('F'),
                                    nameChar: 'F',
                                    isDotted: true,
                                    panel: $panel
                                };
                                tmpF = new F(fAttrData);
                                alreadyNewF = true; // 标识已经创建过力了

                                // 立即执行关联操作
                                tmpF.bindActionPoint(actionPoint);
                                actionPoint.bindConcurrentForce(tmpF);
                            }
                            if (tmpF) {
                                // 已经创建力了 ——> 拖拽力
                                if (Utils.applyBorderCtrl({
                                    'movePos': movePos,
                                    'downPos': downPos,
                                    'fRef': tmpF,
                                    'alreadyNewF': alreadyNewF,
                                    'fPRef': actionPoint,
                                    'tag': TAG.CREATE_F_OR_FP
                                })) {
                                    return;
                                }
                                tmpF.drag(movePos.x, movePos.y);
                            }
                        }
                    });
                    $panel.on("touchend mouseup", function (upEvt) {
                        var upEvent = Utils.getEvent(upEvt);
                        var upPos = Utils.conversionCursorPos(upEvent, $panel);

                        // 校验是否成功创建作用点和力
                        CreationOperationVerification.verifyFOrFPCreation({
                            'actionPoint': actionPoint,
                            'tmpF': tmpF,
                            'upPos': upPos,
                            'downPos': downPos,
                            'alreadyNewF': alreadyNewF
                        });

                        // 解除所有命名空间下的事件绑定
                        $panel.off("mousemove touchmove");
                        $panel.off("mouseup touchend");
                    });
                }
            });

            /********************************** 清空按钮 **********************************/

            $btnCleanUp.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                Utils.turnOffBodilyDraggingState();
                if ($(this).hasClass("click_disabled")) return;
                if (currentPanelState === STATE.CAN_DO_FC || currentPanelState === STATE.CAN_DO_FD) {
                    switchState(currentPanelState);
                }
                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                }
                $cleanUpPopupWindow.show();
                if ($maskLayer.hasClass("show")) return;
                $maskLayer.addClass('show');
            });
            $cleanUpPWConfirm.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                PhysicsSynthesis.cleanUpPanel();
            });
            $cleanUpPWCancel.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                $cleanUpPopupWindow.hide();
                if ($maskLayer.hasClass("show")) $maskLayer.removeClass("show");
            });

            /********************************** 滑动按钮 **********************************/

            $sliderRegion.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                Utils.turnOffBodilyDraggingState();
                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                }
                if ($sliderRegion.hasClass(STYLE_CLASS.UI_DISABLED)) {
                    return;
                }
                $sliderRegion.toggleClass(STYLE_CLASS.CHECKED);
                possessActionPoint = $sliderRegion.hasClass(STYLE_CLASS.CHECKED) ? true : false;
            });

            /********************************** 撤销 与 恢复 按钮 **********************************/

            $btnUndo.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                }
                Utils.turnOffBodilyDraggingState();
                if ($(this).hasClass("click_disabled")) return;
                if (currentPanelState === STATE.CAN_DO_FC || currentPanelState === STATE.CAN_DO_FD) {
                    switchState(currentPanelState);
                }
                var userAction = undoStack.popStack();
                if (userAction) {
                    redoStack.pushStack(userAction);
                    switch (userAction.doWhat) {
                        case MESSAGE.ADD_POINT:
                            userAction.actionObj.logicallyDestroy(MESSAGE.NO_NEED_POST);
                            panelContainer.remove(userAction.actionObj);
                            break;
                        case MESSAGE.ADD_FORCE_WITH_POINT:
                            if (userAction.actionObj.isSelected) {
                                userAction.actionObj._toggleFSelectState();
                            }
                            userAction.actionObj.actionPoint.logicallyDestroy(MESSAGE.NO_NEED_POST);
                            panelContainer.remove(userAction.actionObj.actionPoint);
                            break;
                        case MESSAGE.ADD_CONCURRENT_FORCE:
                            if (userAction.actionObj.isSelected) {
                                userAction.actionObj._toggleFSelectState();
                            }
                            userAction.actionObj.logicallyDestroy(MESSAGE.NO_NEED_POST, false);
                            break;
                        case MESSAGE.DROP_CONCURRENT_FORCE:
                            userAction.actionObj.restoreFromLogicallyDestroy();
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.restoreFromLogicallyDestroy();
                            }
                            break;
                        case MESSAGE.DROP_NON_CONCURRENT_FORCE:
                            if (userAction.actionObj.isSelected) {
                                userAction.actionObj._toggleFSelectState();
                            }
                            userAction.actionObj._concurrentForces[0].restoreFromLogicallyDestroy();
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.restoreFromLogicallyDestroy();
                            }
                            break;
                        case MESSAGE.DROP_POINT:
                            userAction.actionObj.restoreFromLogicallyDestroy();
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.restoreFromLogicallyDestroy();
                            }
                            panelContainer.add(userAction.actionObj);
                            break;
                        case MESSAGE.RENAME_OBJ:
                            var preNameData = {
                                name: userAction.actionObj.nameChar,
                                idx: userAction.actionObj.idx
                            };
                            nameIndexManager.remove(preNameData.name, preNameData.idx);
                            userAction.actionObj.setName(userAction.preState.nameData);
                            userAction.preState.nameData = preNameData;
                            break;
                        case MESSAGE.DRAG_FORCE:
                            var preX2 = userAction.actionObj.x2;
                            var preY2 = userAction.actionObj.y2;
                            userAction.actionObj.drag(userAction.preState.x2, userAction.preState.y2);
                            userAction.preState.x2 = preX2;
                            userAction.preState.y2 = preY2;
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.restoreFromLogicallyDestroy();
                            }
                            break;
                        case MESSAGE.TRANSLATE_POINT:
                            var preX = userAction.actionObj.x;
                            var preY = userAction.actionObj.y;
                            userAction.actionObj.translate(userAction.preState.x, userAction.preState.y); // 平移作用点
                            userAction.preState.x = preX;
                            userAction.preState.y = preY;
                            break;
                        case MESSAGE.COMPOUND_FORCES:
                            var compoundScene;
                            if (userAction.scenes) {
                                for (var i = 0; i < userAction.scenes.length; ++i) {
                                    compoundScene = userAction.scenes[i];
                                    compoundScene.scene.logicallyDestroy();
                                    if (compoundScene.destroyedScene) {
                                        compoundScene.destroyedScene.restoreFromLogicallyDestroy();
                                    }
                                }
                            }
                            break;
                        case MESSAGE.DECOMPOSE_FORCES:
                            var decomposeScene;
                            if (userAction.scenes) {
                                for (var i = 0; i < userAction.scenes.length; ++i) {
                                    decomposeScene = userAction.scenes[i];
                                    decomposeScene.scene.logicallyDestroy();
                                    if (decomposeScene.destroyedScene) {
                                        decomposeScene.destroyedScene.restoreFromLogicallyDestroy();
                                    }
                                }
                            }
                            break;
                    }
                    Consult.askMeetFCFDCondition();
                    Consult.askMeetCleanUPCondition();
                }
            });

            $btnRedo.on("mousedown touchstart", function (evt) {
                Utils.preventDefault(evt);
                Utils.stopPropagation(evt);
                if (preHandledObj) {
                    preHandledObj._toggleForceTipsBox();
                }
                Utils.turnOffBodilyDraggingState();
                if ($(this).hasClass("click_disabled")) return;
                if (currentPanelState === STATE.CAN_DO_FC || currentPanelState === STATE.CAN_DO_FD) {
                    switchState(currentPanelState);
                }
                var userAction = redoStack.popStack();
                if (userAction) {
                    undoStack.pushStack(userAction);
                    switch (userAction.doWhat) {
                        case MESSAGE.ADD_POINT:
                            userAction.actionObj.restoreFromLogicallyDestroy();
                            panelContainer.add(userAction.actionObj);
                            break;
                        case MESSAGE.ADD_FORCE_WITH_POINT:
                            userAction.actionObj.actionPoint.restoreFromLogicallyDestroy();
                            if (!userAction.actionObj.actionPoint.isVirtual) {
                                panelContainer.add(userAction.actionObj.actionPoint);
                            }
                            break;
                        case MESSAGE.ADD_CONCURRENT_FORCE:
                            userAction.actionObj.restoreFromLogicallyDestroy();
                            break;
                        case MESSAGE.DROP_CONCURRENT_FORCE:
                            userAction.actionObj.logicallyDestroy(MESSAGE.NO_NEED_POST);
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.logicallyDestroy();
                            }
                            break;
                        case MESSAGE.DROP_NON_CONCURRENT_FORCE:
                            userAction.actionObj._concurrentForces[0].logicallyDestroy();
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.logicallyDestroy();
                            }
                            panelContainer.remove(userAction.actionObj);
                            break;
                        case MESSAGE.DROP_POINT:
                            userAction.actionObj.logicallyDestroy();
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.logicallyDestroy();
                            }
                            panelContainer.remove(userAction.actionObj);
                            break;
                        case MESSAGE.RENAME_OBJ:
                            var preNameData = {
                                name: userAction.actionObj.nameChar,
                                idx: userAction.actionObj.idx
                            };
                            nameIndexManager.remove(preNameData.name, preNameData.idx);
                            userAction.actionObj.setName(userAction.preState.nameData);
                            userAction.preState.nameData = preNameData;
                            break;
                        case MESSAGE.DRAG_FORCE:
                            if (userAction.destroyedScene) {
                                userAction.destroyedScene.logicallyDestroy();
                            }
                            var preX2 = userAction.actionObj.x2;
                            var preY2 = userAction.actionObj.y2;
                            userAction.actionObj.drag(userAction.preState.x2, userAction.preState.y2);
                            userAction.preState.x2 = preX2;
                            userAction.preState.y2 = preY2;
                            break;
                        case MESSAGE.TRANSLATE_POINT:
                            var preX = userAction.actionObj.x;
                            var preY = userAction.actionObj.y;
                            userAction.actionObj.translate(userAction.preState.x, userAction.preState.y); // 作用点偏移
                            userAction.preState.x = preX;
                            userAction.preState.y = preY;
                            break;
                        case MESSAGE.COMPOUND_FORCES:
                            var compoundScene;
                            if (userAction.scenes) {
                                for (var i = 0; i < userAction.scenes.length; i++) {
                                    compoundScene = userAction.scenes[i];
                                    if (compoundScene.destroyedScene) {
                                        compoundScene.destroyedScene.logicallyDestroy();
                                    }
                                    compoundScene.scene.restoreFromLogicallyDestroy();
                                }
                            }
                            break;
                        case MESSAGE.DECOMPOSE_FORCES:
                            var decomposeScene;
                            if (userAction.scenes) {
                                for (var i = 0; i < userAction.scenes.length; ++i) {
                                    decomposeScene = userAction.scenes[i];
                                    if (decomposeScene.destroyedScene) {
                                        decomposeScene.destroyedScene.logicallyDestroy();
                                    }
                                    decomposeScene.scene.restoreFromLogicallyDestroy();
                                }
                            }
                            break;
                    }
                    Consult.askMeetFCFDCondition();
                    Consult.askMeetCleanUPCondition();
                }
            });
        },
        _unbindEvent: function _unbindEvent() {
            switchState(currentPanelState);
            PhysicsSynthesis.cleanUpPanel();
            Consult.updateFCFDPopupWindow();

            Array.prototype.deletePhysicsSynthesisObj = null;
            panelContainer = null;
            redoStack = null;
            undoStack = null;
            cdQ = null;

            $btnDrawFP.off("mousedown touchstart");
            $btnDrawF.off("mousedown touchstart");
            $btnFCompound.off("mousedown touchstart");
            $compoundPWConfirm.off("mousedown touchstart");
            $compoundPWCancel.off("mousedown touchstart");
            $btnFDecompose.off("mousedown touchstart");
            $decomposePWConfirm.off("mousedown touchstart");
            $decomposePWCancel.off("mousedown touchstart");
            $pointBodilyDraggingBtn.off("mousedown touchstart");
            $deleteBtn.off("mousedown touchstart");
            $confirmBtn.off("mousedown touchstart");
            $nameInput.off("mousedown touchstart");
            $panel.off("mousedown touchstart");
            $btnCleanUp.off("mousedown touchstart");
            $cleanUpPWConfirm.off("mousedown touchstart");
            $cleanUpPWCancel.off("mousedown touchstart");
            $sliderRegion.off("mousedown touchstart");
            $btnUndo.off("mousedown touchstart");
            $btnRedo.off("mousedown touchstart");
        }
    });

    window.AddonPhysicsPower_create = function () {
        return new Presenter('PhysicsPower');
    };
})();]]></presenter><resources><file src="./resources/images/half_arrow_green_down.png"/><file src="./resources/images/half_arrow_red_down.png"/><file src="./resources/images/icon_drag_p.png"/><file src="./resources/images/iconfont.eot"/><file src="./resources/images/iconfont.svg"/><file src="./resources/images/iconfont.ttf"/><file src="./resources/images/iconfont.woff"/><file src="./resources/images/l_input_bg.png"/><file src="./resources/images/main_bg.png"/><file src="./resources/images/tool_cexiao_act.png"/><file src="./resources/images/tool_cexiao_nor.png"/><file src="./resources/images/tool_empty_act.png"/><file src="./resources/images/tool_empty_nor.png"/><file src="./resources/images/tool_fenjie_act.png"/><file src="./resources/images/tool_fenjie_nor.png"/><file src="./resources/images/tool_hecheng_act.png"/><file src="./resources/images/tool_hecheng_nor.png"/><file src="./resources/images/tool_huali_act.png"/><file src="./resources/images/tool_huali_nor.png"/><file src="./resources/images/tool_restore_act.png"/><file src="./resources/images/tool_restore_nor.png"/><file src="./resources/images/tool_zuolidian_act.png"/><file src="./resources/images/tool_zuolidian_nor.png"/><file src="./resources/images/tool_zyd_active.png"/><file src="./resources/images/tool_zyd_normal.png"/><file src="./resources/style.css"/><file src="./resources/style.css.map"/><file src="./resources/style.scss"/></resources></addon>