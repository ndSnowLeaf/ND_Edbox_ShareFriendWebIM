{"version":3,"file":"chinesewordtracing.js","sources":["webpack:///webpack/bootstrap f759e69cacdc1a655e4b","webpack:///src/constant/const-name.js","webpack:///src/config/default.config.js","webpack:///src/utils/point.js","webpack:///external \"jQuery\"","webpack:///src/trace/chinesewordtracing.js","webpack:///src/trace/instance-propety.js","webpack:///src/trace/public-method.js","webpack:///src/utils/line.js","webpack:///src/utils/math-util.js","webpack:///F:/work/module-dev/PresenterWorkspace/~/css-loader/lib/css-base.js","webpack:///./src/resource/css.css","webpack:///src/chinesewordtracing.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f759e69cacdc1a655e4b","/**\r\n * Created by Administrator on 2016/12/15.\r\n * 在描红中用到的一些const值\r\n */\r\n\r\nexport default {\r\n    MODE:{\r\n        DISPLAY:'display',\r\n        DRAW:'draw'\r\n    },\r\n    RESET:{\r\n        ALL:'all',\r\n        BACK:'back',\r\n        FORE:'fore'\r\n    },\r\n    REDAW_TYPE:{\r\n        NORMAL:'normal',\r\n        RADICAL:'radical',\r\n        STRUCTURE:'structure'\r\n    },\r\n    SPEED:{\r\n        FAST:10,\r\n        NORMAL:2.5,\r\n        SLOW:1.5\r\n    },\r\n    //auto:自动描红 step:分步描红\r\n    TRACE_TYPE: {\r\n        AUTO: \"auto\",\r\n        STEP: \"step\"\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/constant/const-name.js","/**\r\n * Created by Administrator on 2016/12/15.\r\n * 描红中用到的默认配置\r\n */\r\nexport default {\r\n    showGuide: true, //是否引导\r\n    wordColor: 'rgb(248,205,198)',//背景字颜色\r\n    dashLineColor: 'rgb(248,205,198)',//引导虚线的颜色\r\n    displayColor: 'rgb(136,136,136)',//展示态的背景字颜色\r\n    guideColor: 'rgb(33,166,233)',//引导颜色\r\n    strokeColor: 'rgb(222,73,30)',\r\n    animateColor: 'rgb(247,63,52)',\r\n    lineWidth: 10.9,\r\n    lineCap: 'round',\r\n    lineJoin: 'round',\r\n    isWrongStep: false,\r\n    fillRate: 0.8,\r\n    centerRate1: 0,\r\n    centerRate2: 0,\r\n    //校验值\r\n    validateRange: {\r\n        standardSize: 500,//标准的坐标系大小，生字资源坐标均为在500x500的坐标系下的位置\r\n        hLimit: 29,//允许的起始点范围\r\n        tLimit: 25,//允许的结束点范围\r\n        cLimit: 7,\r\n        minCount: 5//书写笔画中至少要有5个点\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/config/default.config.js","/**\r\n * Created by Administrator on 2016/12/15.\r\n * 描红中用到的点工具类\r\n */\r\n\r\n\r\nexport default class Point {\r\n    constructor(x, y) {\r\n        this.x = typeof x == 'string' ? parseInt(x) : x;\r\n        this.y = typeof y == 'string' ? parseInt(y) : y;\r\n    }\r\n\r\n    getDistance (p) {\r\n        return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/utils/point.js","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 3\n// module chunks = 0","import Line from \"../utils/line\";\r\nimport Point from \"../utils/point\";\r\nimport mathUtil from \"../utils/math-util\";\r\nimport CONST_NAME from \"../constant/const-name\";\r\nimport defaultConfig from \"../config/default.config\";\r\nimport instanceProperty from \"./instance-propety\";\r\nimport PublicMethod from \"./public-method\";\r\nimport $ from \"jQuery\";\r\nrequire(\"../resource/css.css\");\r\n\r\n\r\n\r\n/**\r\n * 汉字描写类\r\n */\r\n\r\nclass ChineseWordTracing {\r\n\r\n    constructor(param) {\r\n        //展示态\r\n        this.isDisplayMode = param.mode === CONST_NAME.MODE.DISPLAY;\r\n        //作答态\r\n        this.isDrawMode = !this.isDisplayMode;\r\n\r\n        this.param = {\r\n            mode: param.mode,\r\n            word: param.word,\r\n            renderTo: param.renderTo,\r\n            height: $(param.renderTo).height(),\r\n            width:$(param.renderTo).width(),\r\n            back_canvas: null,\r\n            fore_canvas: null,\r\n            config: typeof param.config === 'object' ? param.config : {}\r\n        };\r\n\r\n        //生成canvas\r\n        this.createCanvas();\r\n\r\n        //初始化\r\n        this.init();\r\n\r\n        //返回对外暴露的接口\r\n        return PublicMethod.call(this);\r\n    }\r\n\r\n    init() {\r\n        //当前实例所需要的一系列数据\r\n        this.currentWord = instanceProperty(this.param);\r\n\r\n        var currentWord = this.currentWord;\r\n\r\n        //转换坐标\r\n        currentWord.transformedWord = this.coordinateTransform(currentWord.word, currentWord.width, currentWord.height);\r\n        //转换笔画\r\n        this.convertWord();\r\n\r\n        //初始化画板\r\n        this.initCanvasBoards();\r\n    }\r\n\r\n    createCanvas() {\r\n        var param = this.param;\r\n\r\n        //创建canvas前先把需要渲染canvas的dom结构清空以及解绑canvas的click事件\r\n        $(param.renderTo).find('.canvas_back').off('click');\r\n        $(param.renderTo).empty();\r\n\r\n        param.back_canvas = document.createElement('canvas');\r\n        param.back_canvas.setAttribute('width', param.width);\r\n        param.back_canvas.setAttribute('height', param.height);\r\n        param.back_canvas.className = 'canvas_normal canvas_back';\r\n\r\n        param.renderTo.appendChild(param.back_canvas);\r\n        //如果是作答态\r\n        if (this.isDrawMode) {\r\n            param.fore_canvas = document.createElement('canvas');\r\n            param.fore_canvas.setAttribute('width', param.width);\r\n            param.fore_canvas.setAttribute('height', param.height);\r\n            param.fore_canvas.className = 'canvas_normal canvas_fore';\r\n\r\n            param.renderTo.appendChild(param.fore_canvas);\r\n        }\r\n\r\n    }\r\n\r\n    //初始化canvas画板\r\n    initCanvasBoards() {\r\n\r\n        //先做一次事件解绑\r\n        //初始化背景层\r\n        this.initBackBoard();\r\n\r\n        //如果是作答态\r\n        if (this.isDrawMode) {\r\n            //初始化前景层\r\n            this.initForeBoard();\r\n            //事件绑定\r\n            this.eventBind();\r\n        }\r\n    }\r\n\r\n    //重置画板\r\n    resetCanvasBoards() {\r\n        //初始化背景层\r\n        this.initBackBoard();\r\n\r\n        //如果是作答态\r\n        if (this.isDrawMode) {\r\n            this.currentWord.allowDraw = true;\r\n            this.currentWord.validateStep = 0;\r\n            //初始化前景层\r\n            this.initForeBoard();\r\n        }\r\n\r\n        this.currentWord.currentStep = 0;\r\n        this.currentWord.currentStroke = 0;\r\n    }\r\n\r\n    //初始化背景层\r\n    initBackBoard(type) {\r\n        console.debug('初始化背景字：', new Date());\r\n        var currentWord = this.currentWord,\r\n            steps = currentWord.convertedWord.steps,\r\n            context = currentWord.back_context,\r\n            radicalInfo = currentWord.radicalInfo,\r\n            structureInfo = currentWord.structureInfo,\r\n            i, j, k, iLen, jLen, kLen;\r\n\r\n        context.restore();\r\n        currentWord.back_imageData = null;\r\n        context.clearRect(0, 0, currentWord.width, currentWord.height);\r\n\r\n\r\n        context.lineWidth = 3;\r\n        for (i = 0, iLen = steps.length; i < iLen; i++) {\r\n            context.fillStyle = this.isDrawMode ?\r\n                currentWord.config.wordColor : currentWord.config.displayColor;\r\n            //根据type来显示特定笔画的颜色\r\n            //显示部首\r\n            if (type && type === CONST_NAME.REDAW_TYPE.RADICAL) {\r\n                if (radicalInfo.stepIndex && radicalInfo.stepIndex.indexOf(i) > -1) {\r\n                    context.fillStyle = radicalInfo.color;\r\n                }\r\n            }\r\n\r\n            //显示结构\r\n            if (type && type === CONST_NAME.REDAW_TYPE.STRUCTURE) {\r\n                for (k = 0, kLen = structureInfo.length; k < kLen; k++) {\r\n                    if (structureInfo[k].stepIndex.indexOf(i) > -1) {\r\n                        context.fillStyle = structureInfo[k].color;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var points = steps[i].points;\r\n            context.beginPath();\r\n            for (j = 0, jLen = points.length; j < jLen; j++) {\r\n                var point = points[j];\r\n                context.lineTo(point.x, point.y);\r\n            }\r\n            context.closePath();\r\n            context.fill();\r\n\r\n            //console.log('绘制背景字：', new Date());\r\n        }\r\n\r\n        //绘制中线\r\n        if (this.isDrawMode && this.currentWord.showCenterLine) {\r\n            this.drawCenterLine(context, currentWord.convertedWord.strokes);\r\n        }\r\n\r\n        currentWord.back_imageData = context.getImageData(0, 0, currentWord.width, currentWord.height);\r\n\r\n    }\r\n\r\n    /**\r\n     * 绘制中线 绘制所有笔画的中线（实线）\r\n     * @param context canvas绘图上下文对象\r\n     * @param centers 中线坐标点\r\n     */\r\n    drawCenterLine(context, strokes) {\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = 'rgb(0,0,0)';\r\n\r\n        strokes.forEach(function (stroke, strokeIndex, strokeArray) {\r\n            context.beginPath();\r\n\r\n            //绘制中线\r\n            stroke.centers.forEach(function (center, centerIndex, centerArray) {\r\n                if (centerIndex === 0) {\r\n                    context.moveTo(center.x, center.y);\r\n                }\r\n\r\n                context.lineTo(center.x, center.y);\r\n            });\r\n\r\n            context.stroke();\r\n        });\r\n\r\n    }\r\n\r\n    //绘制起点和终点\r\n    //绘制当前引导笔画的中线（虚线）\r\n    drawCurStepCenterLine(context, points) {\r\n        var c = context;\r\n\r\n        c.save();\r\n        c.beginPath();\r\n        c.strokeStyle = this.currentWord.config.dashLineColor;\r\n\r\n        //步长为4，outLen 为需要循环绘制的次数\r\n        var pointsLen = points.length;\r\n        var outerLen = Math.floor(pointsLen / 4);\r\n        //最后的几个点，即少于4个的点\r\n        var lastPoints = pointsLen % 4;\r\n\r\n        for (var i = 0; i < outerLen; i++) {\r\n            var startIndex = i * 4;\r\n\r\n            c.moveTo(points[startIndex].x, points[startIndex].y);\r\n            c.lineTo(points[startIndex + 1].x, points[startIndex + 1].y);\r\n            c.lineTo(points[startIndex + 2].x, points[startIndex + 2].y);\r\n        }\r\n\r\n        if (lastPoints) {\r\n            startIndex = outerLen * 4;\r\n            c.moveTo(points[startIndex].x, points[startIndex].y);\r\n            c.lineTo(points[pointsLen - 1].x, points[pointsLen - 1].y);\r\n        }\r\n\r\n        c.closePath();\r\n        c.stroke();\r\n\r\n        c.restore();\r\n\r\n    }\r\n\r\n    //开启或关闭\r\n    showCanvasGuide(show) {\r\n        if (this.isDisplayMode) return;\r\n\r\n        this.currentWord.showGuide = !!show;\r\n        this.nextStep();\r\n    }\r\n\r\n    //初始化前景层\r\n    initForeBoard() {\r\n        if (this.isDisplayMode) return;\r\n\r\n        var currentWord = this.currentWord,\r\n            context = currentWord.fore_context;\r\n\r\n        context.restore();\r\n        currentWord.fore_imageData = null;\r\n        context.clearRect(0, 0, currentWord.width, currentWord.height);\r\n        context.save();\r\n\r\n        this.nextStep();\r\n\r\n    }\r\n\r\n    //绘制一条线，board 画板，points 坐标点[{x:10,y:10},{..}]\r\n    drawLine(board, points) {\r\n        var len = points.length;\r\n\r\n        board.beginPath();\r\n        board.moveTo(points[0].x, points[0].y);\r\n        for (var i = 1; i < len; i++) {\r\n            board.lineTo(points[i].x, points[i].y);\r\n        }\r\n        board.stroke();\r\n    }\r\n\r\n    //事件绑定\r\n    eventBind() {\r\n        if (this.isDisplayMode) return;\r\n\r\n        var fore_canvas = this.currentWord.fore_canvas;\r\n\r\n        $(fore_canvas).on('mousedown touchstart', this.startEvent.bind(this));\r\n        $(fore_canvas).on('mousemove touchmove', this.moveEvent.bind(this));\r\n        $(fore_canvas).on('mouseup touchend mouseleave touchleave touchcancel', this.endEvent.bind(this));\r\n\r\n    }\r\n\r\n    //开始描绘\r\n    startEvent(e) {\r\n        if (!this.currentWord.allowDraw) return;\r\n\r\n        this.currentWord.hasDrawed = true;\r\n\r\n        var currentWord = this.currentWord,\r\n            context = currentWord.fore_context,\r\n            config = currentWord.config,\r\n            p, p1;\r\n\r\n        p1 = mathUtil.getPosition(e.originalEvent);\r\n\r\n        p = mathUtil.windowToCanvas(context.canvas, p1.x, p1.y);\r\n\r\n        currentWord.isMouseDown = true;\r\n\r\n        //设置画笔属性\r\n        context.lineWidth = config.lineWidth;\r\n        context.strokeStyle = config.strokeColor;\r\n        context.lineCap = config.lineCap;\r\n        context.lineJoin = config.lineJoin;\r\n\r\n        context.beginPath();\r\n        context.lineTo(p.x, p.y);\r\n\r\n        this.pushPoints(p.x, p.y);\r\n    }\r\n\r\n    //滑动过程\r\n    moveEvent(e) {\r\n\r\n        if (!this.currentWord.isMouseDown || !this.currentWord.allowDraw)\r\n            return;\r\n\r\n        var currentWord = this.currentWord,\r\n            context = currentWord.fore_context,\r\n            p, p1;\r\n\r\n        p1 = mathUtil.getPosition(e.originalEvent);\r\n\r\n        p = mathUtil.windowToCanvas(context.canvas, p1.x, p1.y);\r\n\r\n        context.lineTo(p.x, p.y);\r\n        context.stroke();\r\n        this.pushPoints(p.x, p.y);\r\n    }\r\n\r\n    //描绘结束\r\n    endEvent(e) {\r\n        if (!this.currentWord.isMouseDown) return;\r\n\r\n        this.currentWord.isMouseDown = false;\r\n\r\n        if (!this.currentWord.allowDraw)\r\n            return;\r\n\r\n        var currentWord = this.currentWord,\r\n            context = currentWord.fore_context;\r\n\r\n        context.closePath();\r\n\r\n        if (this.validate()) {\r\n            currentWord.isWrongStep = false;\r\n            currentWord.validateStep++;\r\n\r\n            this.initBackBoard();\r\n\r\n            if (currentWord.validateStep == 1) {\r\n                context.clearRect(0, 0, currentWord.width, currentWord.height);\r\n                //重绘当前笔画\r\n                this.drawLine(context, currentWord.points);\r\n            } else {\r\n                //清空画布\r\n                context.clearRect(0, 0, currentWord.width, currentWord.height);\r\n                context.putImageData(currentWord.fore_imageData, 0, 0);\r\n                //重绘当前笔画\r\n                this.drawLine(context, currentWord.points);\r\n            }\r\n\r\n            //重绘后的数据放入fore_imageData\r\n            currentWord.fore_imageData = context.getImageData(0, 0, currentWord.width, currentWord.height);\r\n            //checkImageData(currentWord.fore_imageData);\r\n\r\n            if (currentWord.validateStep >= currentWord.convertedWord.strokes.length) {\r\n                currentWord.allowDraw = false;\r\n                return;\r\n            }\r\n            this.nextStep();\r\n        }\r\n        else {\r\n            //c.fillRect(0, 0, currentWord.width, currentWord.height);\r\n            currentWord.isWrongStep = true;\r\n            //c.restore();\r\n            context.clearRect(0, 0, currentWord.width, currentWord.height);\r\n            if (currentWord.fore_imageData) {\r\n                context.putImageData(currentWord.fore_imageData, 0, 0);\r\n            }\r\n\r\n            //如果是关闭引导状态，笔画写错\r\n            if (!currentWord.showGuide) {\r\n                this.nextStep(currentWord.isWrongStep);\r\n            } else {\r\n                this.nextStep(!currentWord.isWrongStep);\r\n            }\r\n        }\r\n    }\r\n\r\n    nextStep(isWrong) {\r\n        var currentWord = this.currentWord;\r\n\r\n        //每次进入都要把闪烁动画的计时器清空\r\n        clearInterval(currentWord.flickerTimer);\r\n\r\n        if (currentWord.validateStep >= currentWord.convertedWord.strokes.length) {\r\n            return\r\n        }\r\n\r\n        var c = currentWord.back_context, points, point,\r\n            validateStep = currentWord.validateStep,\r\n            strokes = currentWord.convertedWord.strokes,\r\n            segments = strokes[validateStep].segments,\r\n            flickerTimes = 0;\r\n\r\n        currentWord.lastPoint = null;\r\n        currentWord.points = [];\r\n\r\n        c.restore();\r\n\r\n\r\n        if (currentWord.showGuide || isWrong) {\r\n            c.save();\r\n\r\n\r\n            c.fillStyle = currentWord.config.guideColor;\r\n            c.strokeStyle = currentWord.config.guideColor;\r\n            c.beginPath();\r\n\r\n            for (var i = 0, iLength = segments.length; i < iLength; i++) {\r\n                points = segments[i].points;\r\n                for (var j = 0; j < points.length; j++) {\r\n                    point = points[j];\r\n                    if (j == 0)\r\n                        c.moveTo(point.x, point.y);\r\n                    c.lineTo(point.x, point.y);\r\n                }\r\n            }\r\n\r\n            c.closePath();\r\n            c.fill();\r\n            c.clip();\r\n\r\n            //绘制引导线\r\n            this.drawCurStepCenterLine(c, strokes[validateStep].centers);\r\n            //如果是关闭引导状态下，书写错误，则闪烁显示正确笔画\r\n            if (!currentWord.showGuide && isWrong) {\r\n                currentWord.flickerTimer = setInterval(function () {\r\n\r\n                    if (flickerTimes++ % 2 === 0) {\r\n                        c.strokeStyle = currentWord.config.dashLineColor;\r\n                    } else {\r\n                        c.strokeStyle = currentWord.config.guideColor;\r\n                    }\r\n\r\n                    c.stroke();\r\n\r\n                    if (flickerTimes >= currentWord.flickerTimes) {\r\n                        flickerTimes = 0;\r\n                        clearInterval(currentWord.flickerTimer);\r\n                        c.clearRect(0, 0, currentWord.width, currentWord.height);\r\n                        c.putImageData(currentWord.back_imageData, 0, 0);\r\n                    }\r\n                }, currentWord.flickerInterval);\r\n            }\r\n\r\n        } else {\r\n            c.clearRect(0, 0, currentWord.width, currentWord.height);\r\n            c.putImageData(currentWord.back_imageData, 0, 0);\r\n        }\r\n    }\r\n\r\n    //校验\r\n    validate() {\r\n        //当前需要判断的笔划\r\n        var currentWord = this.currentWord,\r\n            config = currentWord.config,\r\n            validateRange = config.validateRange,\r\n            stroke = currentWord.convertedWord.strokes[currentWord.validateStep],\r\n        //笔划边框坐标\r\n            framePoints = stroke.segments,\r\n        //中心线\r\n            centers = stroke.centers,\r\n        //手写的坐标点\r\n            points = currentWord.points,\r\n            pointsLen = currentWord.points.length,\r\n            centersLen = centers.length,\r\n        //相似点的个数\r\n            similarCount1 = 0, similarCount2 = 0,\r\n        //在笔划区域内点的个数\r\n            insideCount = 0,\r\n        //点相似度\r\n            centerRate1 = 0, centerRate2 = 0,\r\n        //填充率\r\n            fillRate = 0,\r\n\r\n            first = 0, last = 0,//头坐标距离，尾坐标距离\r\n            p2pDis1 = 0, p2pDis2 = 0;\r\n\r\n        first = mathUtil.pointToPoint(centers[0], points[0]);\r\n        last = mathUtil.pointToPoint(centers[centersLen - 1], points[pointsLen - 1]);\r\n\r\n        //首尾点的比对\r\n        if (first > validateRange.hLimit || last > validateRange.tLimit) {\r\n            return false;\r\n        }\r\n\r\n        for (var i = 0; i < pointsLen; i++) {\r\n            //判断点是否在笔画内\r\n            if (mathUtil.isPointInPoly(points[i], framePoints)) {\r\n                insideCount++;\r\n            }\r\n\r\n        }\r\n\r\n        fillRate = insideCount / pointsLen;\r\n\r\n        if (fillRate < config.fillRate || pointsLen < validateRange.minCount) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    //将书写的坐标点存入points\r\n    pushPoints(x, y) {\r\n        var currentWord = this.currentWord,\r\n            lastPoint = currentWord.lastPoint,\r\n            points = currentWord.points;\r\n\r\n        if (!lastPoint || lastPoint.getDistance({\"x\": x, \"y\": y}) >= 2) {\r\n            lastPoint = new Point(x, y);\r\n            points.push(lastPoint);\r\n        }\r\n    }\r\n\r\n    //笔画转换，转换为可用的笔画\r\n    convertWord() {\r\n        var currentWord = this.currentWord,\r\n            transformedWord = $.extend({}, currentWord.transformedWord),\r\n            strokes = transformedWord.strokes,\r\n            strokeInfo = transformedWord.strokeInfo,\r\n            radicalStepindex = [],\r\n            structureStepIndex = [],\r\n            color, structureInfo, info, temp,\r\n            i, j, k, m, len, iLen, jLen, kLen, mLen;\r\n\r\n        //部首信息\r\n        currentWord.radicalInfo = {\r\n            stepIndex: [],\r\n            color: ''\r\n        };\r\n        //结构信息\r\n        currentWord.structureInfo = [];\r\n\r\n        //转换部首信息\r\n        if (strokeInfo && strokeInfo.radicalInfo && strokeInfo.radicalInfo.oriColor && strokeInfo.radicalInfo.oriColor.length == 3) {\r\n\r\n            color = strokeInfo.radicalInfo.oriColor;\r\n\r\n            currentWord.radicalInfo.color = \"rgb(\" + color[0] + \",\" + color[1] + \",\" + color[2] + \")\";\r\n            radicalStepindex = strokeInfo.radicalInfo.strokeIndex.split(',').map(function (value) {\r\n                return parseInt(value)\r\n            });\r\n        }\r\n\r\n        if (strokeInfo && strokeInfo.structureInfos && strokeInfo.structureInfos.length > 0) {\r\n            temp = [];\r\n            for (i = 0, len = strokeInfo.structureInfos.length; i < len; i++) {\r\n\r\n                structureInfo = strokeInfo.structureInfos[i];\r\n                info = {\r\n                    color: '',\r\n                    stepIndex: []\r\n                };\r\n\r\n                color = structureInfo.oriColor;\r\n\r\n                info.color = \"rgb(\" + color[0] + \",\" + color[1] + \",\" + color[2] + \")\";\r\n\r\n                temp = structureInfo.strokeIndex.split(',').map(function (value) {\r\n                    return parseInt(value);\r\n                });\r\n\r\n                structureStepIndex[i] = temp;\r\n\r\n                currentWord.structureInfo.push(info);\r\n            }\r\n        }\r\n\r\n        //笔画转换\r\n        transformedWord.steps = [];\r\n\r\n        for (i = 0, iLen = strokes.length; i < iLen; i++) {\r\n            var centers = strokes[i].centers, segments = strokes[i].segments;\r\n\r\n            currentWord.strokesMap[i] = [];\r\n\r\n            for (j = 0, jLen = centers.length; j < jLen; j++) {\r\n                centers[j] = new Point(centers[j].x, centers[j].y);\r\n            }\r\n            for (j = 0, jLen = segments.length; j < jLen; j++) {\r\n                segments[j].start = new Point(segments[j].start.x, segments[j].start.y);\r\n                segments[j].end = new Point(segments[j].end.x, segments[j].end.y);\r\n                var points = segments[j].points;\r\n                for (k = 0, kLen = points.length; k < kLen; k++) {\r\n                    points[k] = new Point(points[k].x, points[k].y);\r\n                }\r\n\r\n                //因为转换的笔画与元数据中笔画要多，故这样操作一次保证，部首和结构中有一只的笔画数字\r\n                if (radicalStepindex.indexOf(i) > -1) {\r\n                    currentWord.radicalInfo.stepIndex.push(transformedWord.steps.length);\r\n                }\r\n\r\n                for (m = 0, mLen = structureStepIndex.length; m < mLen; m++) {\r\n                    if (structureStepIndex[m].indexOf(i) > -1) {\r\n                        currentWord.structureInfo[m].stepIndex.push(transformedWord.steps.length);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                currentWord.strokesMap[i].push(transformedWord.steps.length);\r\n\r\n                transformedWord.steps.push({\r\n                    \"line\": new Line(segments[j].start, segments[j].end),\r\n                    \"points\": points\r\n                });\r\n\r\n\r\n            }\r\n        }\r\n\r\n        currentWord.convertedWord = transformedWord;\r\n        currentWord.strokesLength = transformedWord.strokes.length;\r\n        currentWord.autoTraceSteps = transformedWord.steps.length;\r\n\r\n    }\r\n\r\n    //动画相关,开始动画\r\n    startAnimation(type) {\r\n        var currentWord = this.currentWord;\r\n\r\n        currentWord.$autoAnimateDeferred = $.Deferred();\r\n\r\n        currentWord.traceType = type;\r\n        this.initBackBoard();\r\n        currentWord.currentStep = 0;//每次开始描红需要将currentStep置为0\r\n\r\n\r\n        if( type == CONST_NAME.TRACE_TYPE.AUTO ) {\r\n            //开始自动描红\r\n            this.draw();\r\n        } else {\r\n            //分步描红设置速度为normal\r\n            this.setSpeed();\r\n        }\r\n\r\n        return currentWord.$autoAnimateDeferred.promise();\r\n\r\n    }\r\n\r\n    //停止描红\r\n    stopAnimation() {\r\n        cancelAnimationFrame(this.currentWord.loop);\r\n        this.currentWord.loop = 0;\r\n        this.currentWord.$animateDeferred = null;\r\n        //this.currentWord.back_context.restore();\r\n        this.initBackBoard();\r\n    }\r\n\r\n    //是否在自动描红\r\n    isInAnimation() {\r\n        return this.currentWord.loop === 0 ? false : true;\r\n    }\r\n\r\n    //设置速度\r\n    setSpeed(speed) {\r\n        var animateSpeed;\r\n\r\n        switch (speed) {\r\n            case 'fast':\r\n                animateSpeed = CONST_NAME.SPEED.FAST;\r\n                break;\r\n            case 'slow':\r\n                animateSpeed = CONST_NAME.SPEED.SLOW;\r\n                break;\r\n            default:\r\n                animateSpeed = CONST_NAME.SPEED.NORMAL;\r\n        }\r\n\r\n        this.currentWord.speed = animateSpeed;\r\n    }\r\n\r\n    //开始动画\r\n    draw() {\r\n\r\n        var currentWord = this.currentWord,\r\n            currentStroke = currentWord.currentStroke,\r\n            context = currentWord.back_context,\r\n            config = currentWord.config;\r\n\r\n        //分步描红的时候，用延迟对象通知描红结束\r\n        this.currentWord.$stepAnimateDeferred = $.Deferred();\r\n\r\n        var $deferred = this.currentWord.$stepAnimateDeferred;\r\n\r\n        var returnInfo = {\r\n            currentStep: currentStroke,\r\n            totalStep: currentWord.strokesLength\r\n        };\r\n\r\n        if( currentStroke >= currentWord.strokesLength ) {\r\n            currentWord.loop = 0;\r\n\r\n            $deferred.resolve(returnInfo);\r\n            currentWord.$autoAnimateDeferred.resolve(returnInfo);\r\n\r\n            return $deferred.promise();\r\n        }\r\n\r\n        //设置动画填充颜色\r\n        context.fillStyle = currentWord.config.animateColor;\r\n        context.lineCap = config.lineCap;\r\n        context.lineJoin = config.lineJoin;\r\n\r\n        this.animateByStroke();\r\n\r\n        return $deferred.promise();\r\n    }\r\n\r\n    //按笔画来描红，steps是stroke的子集\r\n    animateByStroke() {\r\n        var currentStroke = this.currentWord.currentStroke;\r\n        var steps = this.currentWord.strokesMap[currentStroke];\r\n\r\n        if(!Array.isArray(steps)) {\r\n            throw new Error(\"stroke does not exist.\");\r\n        }\r\n\r\n        this.animateBySteps();\r\n\r\n    }\r\n\r\n    //单个笔画拆分为几个step\r\n    animateBySteps() {\r\n        var currentWord = this.currentWord;\r\n        var steps = currentWord.strokesMap[currentWord.currentStroke];\r\n        var currentStep = steps[currentWord.currentStep];\r\n        var len = steps.length;\r\n\r\n\r\n        if (currentWord.currentStep >= len) {\r\n            //如果当前stroke已经绘制完成\r\n            currentWord.currentStep = 0;\r\n            currentWord.currentStroke++;\r\n\r\n            //描绘下一笔\r\n            if(currentWord.traceType == CONST_NAME.TRACE_TYPE.AUTO){\r\n\r\n                this.draw();\r\n\r\n            } else {\r\n                //分步描红，绘制完一笔，resolve 延迟对象\r\n                currentWord.$stepAnimateDeferred.resolve({\r\n                    currentStep: currentWord.currentStroke,\r\n                    totalStep: currentWord.strokesLength\r\n                });\r\n            }\r\n\r\n        } else {\r\n\r\n            var step = currentWord.convertedWord.steps[currentStep];\r\n            //分割出动画区域\r\n            currentWord.back_context.save();\r\n            this.setClipPath(currentWord.back_context, step.points);\r\n            this.animate(currentWord, step);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    //开始动画\r\n    animate(currentWord, step) {\r\n        var interval = 0,\r\n            maxValue = step.line.getLength();\r\n\r\n        function animateInner() {\r\n            interval += currentWord.speed;\r\n\r\n            if (interval >= maxValue)\r\n                interval = maxValue;\r\n\r\n            this.drawAnimationFrame(currentWord.back_context, step, interval);\r\n\r\n            if (interval == maxValue) {\r\n                cancelAnimationFrame(currentWord.loop);\r\n                ++currentWord.currentStep;\r\n                currentWord.back_context.restore();\r\n\r\n                this.animateBySteps();\r\n                return;\r\n            }\r\n            currentWord.loop = requestAnimationFrame(animateInner.bind(this));\r\n        }\r\n\r\n        currentWord.loop = requestAnimationFrame(animateInner.bind(this));\r\n    }\r\n\r\n    //绘制要展示动画的区域,即绘制currentStep\r\n    setClipPath(context, currentStepPoints) {\r\n        var point;\r\n\r\n        context.beginPath();\r\n        for (var i = 0, len = currentStepPoints.length; i < len; i++) {\r\n            point = currentStepPoints[i];\r\n            context.lineTo(point.x, point.y);\r\n        }\r\n        context.closePath();\r\n        context.clip();\r\n    }\r\n\r\n    //animation frame\r\n    drawAnimationFrame(context, step, interval) {\r\n        var point,\r\n            rectAry = step.line.getRectangle(500, interval);\r\n\r\n        context.beginPath();\r\n        for (var i = 0, len = rectAry.length; i < len; i++) {\r\n            point = rectAry[i];\r\n            context.lineTo(point.x, point.y);\r\n        }\r\n        context.closePath();\r\n        context.fill();\r\n    }\r\n\r\n    //单步描红时，上一笔操作，实际就是撤销\r\n    preStep() {\r\n\r\n        var currentWord = this.currentWord;\r\n        var currentStroke = currentWord.currentStroke;\r\n\r\n        var stepsInfo = {\r\n            currentStep: currentStroke,\r\n            totalStep: currentWord.strokesLength\r\n        };\r\n\r\n        //初始化一遍背景字\r\n        this.initBackBoard();\r\n\r\n        var context = currentWord.back_context;\r\n        var currentStroke = --currentWord.currentStroke;\r\n\r\n        if(this.currentWord.traceType != CONST_NAME.TRACE_TYPE.STEP || currentStroke <= 0){\r\n            currentWord.currentStroke = 0;\r\n            stepsInfo.currentStep = 0;\r\n            return stepsInfo;\r\n        }\r\n\r\n        var mapIndex = this.currentWord.strokesMap[currentStroke - 1];\r\n        var maxStep = mapIndex[mapIndex.length-1];\r\n\r\n        var steps = currentWord.convertedWord.steps;\r\n\r\n        context.fillStyle = currentWord.config.animateColor;\r\n\r\n        for(var i = 0; i <= maxStep; i++) {\r\n\r\n            var points = steps[i].points;\r\n\r\n            context.beginPath();\r\n\r\n            for (var j = 0, jLen = points.length; j < jLen; j++) {\r\n                var point = points[j];\r\n                context.lineTo(point.x, point.y);\r\n            }\r\n\r\n            context.closePath();\r\n            context.fill();\r\n        }\r\n\r\n        stepsInfo.currentStep = currentStroke;\r\n\r\n        return stepsInfo;\r\n\r\n    }\r\n\r\n\r\n    //绘制特定笔画\r\n    drawSingleStroke(context, step) {\r\n        var points = step.points;\r\n        context.beginPath();\r\n        for (var i = 0, iLen = points.length; i < iLen; i++) {\r\n            var point = points[i];\r\n            context.lineTo(point.x, point.y);\r\n        }\r\n        context.closePath();\r\n        context.fill();\r\n    }\r\n\r\n    //坐标等比转换为适合当前canvas的大小\r\n    coordinateTransform(originalWord, canvasWidth, canvasHeight) {\r\n        var newWord = $.extend({}, originalWord),\r\n            originalSize = newWord.size,\r\n            scaleX = canvasWidth / originalSize,\r\n            scaleY = canvasHeight / originalSize;\r\n\r\n        if (originalSize === canvasWidth) {\r\n            return newWord;\r\n        }\r\n\r\n        newWord.size = canvasWidth;\r\n\r\n        for (var i = 0; i < newWord.strokes.length; i++) {\r\n            for (var j = 0; j < newWord.strokes[i].centers.length; j++) {\r\n                newWord.strokes[i].centers[j].x = newWord.strokes[i].centers[j].x * scaleX;\r\n                newWord.strokes[i].centers[j].y = newWord.strokes[i].centers[j].y * scaleY;\r\n            }\r\n\r\n            for (var k = 0; k < newWord.strokes[i].segments.length; k++) {\r\n                newWord.strokes[i].segments[k].start.x = newWord.strokes[i].segments[k].start.x * scaleX;\r\n                newWord.strokes[i].segments[k].start.y = newWord.strokes[i].segments[k].start.y * scaleY;\r\n\r\n                newWord.strokes[i].segments[k].end.x = newWord.strokes[i].segments[k].end.x * scaleX;\r\n                newWord.strokes[i].segments[k].end.y = newWord.strokes[i].segments[k].end.y * scaleY;\r\n\r\n                for (var l = 0; l < newWord.strokes[i].segments[k].points.length; l++) {\r\n                    newWord.strokes[i].segments[k].points[l].x = newWord.strokes[i].segments[k].points[l].x * scaleX;\r\n                    newWord.strokes[i].segments[k].points[l].y = newWord.strokes[i].segments[k].points[l].y * scaleY;\r\n                }\r\n            }\r\n        }\r\n\r\n        return newWord;\r\n    }\r\n\r\n    //坐标转换之后，对应的起终点判断范围也要等比变化\r\n    scaleValidateRange() {\r\n        //当前生字使用的坐标系大小 size * size\r\n        var size = this.currentWord.transformedWord.size;\r\n        var validateRange = this.currentWord.config.validateRange;\r\n        //计算当前size对标准size的倍率\r\n        var scale = size / validateRange.standardSize;\r\n\r\n        //乘上倍率，得到当前size下适合的检验范围\r\n        validateRange.hLimit *= scale;\r\n        validateRange.tLimit *= scale;\r\n    }\r\n\r\n    //输出前景层base64,png\r\n    getBase64Image() {\r\n        if (this.isDisplayMode) return;\r\n\r\n        var base64Image = this.currentWord.fore_canvas.toDataURL().replace('data:image/png;base64,', '');\r\n\r\n        //console.log(base64Image);\r\n        return [{key: 'traceData', value: base64Image}];\r\n    }\r\n\r\n}\r\n\r\nexport default ChineseWordTracing;\r\n\n\n\n// WEBPACK FOOTER //\n// src/trace/chinesewordtracing.js","/**\r\n * Created by Administrator on 2016/12/15.\r\n * 描红对象当前实例currentWord下的属性\r\n */\r\n\r\nimport CONST_NAME from \"../constant/const-name\";\r\nimport defaultConfig from \"../config/default.config\";\r\nimport $ from \"jQuery\";\r\n\r\nexport default (param) => {\r\n  return {\r\n\tword: param.word,//原始word\r\n\ttransformedWord: {},//转换过坐标的word\r\n\tconvertedWord: {},//转换过笔画的word\r\n\tstrokesLength: 0,\r\n\tautoTraceSteps: 0,\r\n\tconfig: $.extend({}, defaultConfig, param.config),\r\n\tback_canvas: param.back_canvas,\r\n\tfore_canvas: param.fore_canvas,\r\n\tback_context: param.back_canvas.getContext('2d'),\r\n\tfore_context: param.mode === CONST_NAME.MODE.DRAW ? param.fore_canvas.getContext('2d') : null,\r\n\tback_imageData: null,\r\n\tfore_imageData: null,\r\n\tcurrentStroke: 0,//当前笔画\r\n\tcurrentStep: 0,\r\n\tlastPoint: null,\r\n\tpoints: [],\r\n\thasDrawed: false,\r\n\tstartDraw: false,\r\n\twidth: param.width,\r\n\theight: param.height,\r\n\tallowDraw: true,\r\n\tshowGuide: true,\r\n\tisMouseDown: false,\r\n\tvalidateStep: 0,\r\n\tisWrongStep: false,\r\n\tflickerTimer: null,//错误笔画后闪烁定时器\r\n\tflickerInterval: 250,//闪烁间隔，毫秒\r\n\tflickerTimes: 6,//闪烁次数\r\n\tradicalInfo: {},//部首信息\r\n\tstructureInfo: [],//结构信息\r\n\tloop: 0,//动画loop,\r\n\tn: 0,//用于console输出当前绘制的笔画\r\n\tspeed: CONST_NAME.SPEED.NORMAL,//自动描红速度\r\n\ttraceType: null,//描红类型，自动 或 分步\r\n\tstepTraceSpeed: CONST_NAME.SPEED.NORMAL,//分步描红速度\r\n\tstrokesMap: {},//笔画strokes和segments的映射，一个stroke里包含多个segments\r\n\tshowCenterLine: false//是否显示笔画的中线，所有笔画都有的实线\r\n  };\r\n}\n\n\n// WEBPACK FOOTER //\n// src/trace/instance-propety.js","/**\r\n * Created by Administrator on 2016/12/15.\r\n * 实例对外暴露的方法\r\n */\r\n\r\nimport CONST_NAME from \"../constant/const-name\";\r\n\r\nexport default function () {\r\n\r\n    var parent = this;\r\n\r\n    //作答态提供的方法\r\n    var drawModeMethod = {\r\n\r\n        showGuideState: true,\r\n\r\n        //允许绘画\r\n        allowDraw(allow) {\r\n            parent.currentWord.allowDraw = !!allow;\r\n\r\n        },\r\n\r\n        //返回是否书写过的状态\r\n        hasDrawed() {\r\n            return parent.currentWord.hasDrawed;\r\n        },\r\n\r\n        //显示引导\r\n        showGuide(show) {\r\n            parent.showCanvasGuide(show);\r\n        },\r\n        //获取base64 data\r\n        getBase64Image() {\r\n            return parent.getBase64Image();\r\n        },\r\n        //获取描绘进度，当前描到第几笔，总共有多少笔\r\n        getTraceProgress() {\r\n            var currentWord = parent.currentWord,\r\n                curStep = parent.isDrawMode ? currentWord.validateStep : currentWord.currentStep,\r\n                totalSteps = parent.isDrawMode ? currentWord.strokesLength : currentWord.autoTraceSteps,\r\n                isInAnimation = currentWord.loop === 0 ? false : true;\r\n\r\n            return {\r\n                curStep: curStep,\r\n                totalSteps: totalSteps,\r\n                isInAnimation: isInAnimation\r\n            }\r\n        },\r\n        //重置\r\n        reset() {\r\n            parent.resetCanvasBoards();\r\n        }\r\n    };\r\n\r\n    var displayModeMethod = {\r\n        //展示部首\r\n        showRadical() {\r\n            \r\n            parent.initBackBoard(CONST_NAME.REDAW_TYPE.RADICAL);\r\n\r\n        },\r\n        //不展示部首\r\n        hideRadical() {\r\n           \r\n            parent.initBackBoard(CONST_NAME.REDAW_TYPE.NORMAL);\r\n        },\r\n        //展示结构\r\n        showStructure() {\r\n           \r\n            parent.initBackBoard(CONST_NAME.REDAW_TYPE.STRUCTURE);\r\n        },\r\n        //不展示结构\r\n        hideStructure() {\r\n           \r\n            parent.initBackBoard(CONST_NAME.REDAW_TYPE.NORMAL);\r\n        },\r\n        //开始自动描红\r\n        startAutoTrace() {\r\n           \r\n            return parent.startAnimation(CONST_NAME.TRACE_TYPE.AUTO);\r\n        },\r\n        //停止自动描红\r\n        stopAutoTrace() {\r\n           \r\n            parent.stopAnimation();\r\n        },\r\n\r\n        //开始分步描红\r\n        startSingleStepTrace() {\r\n            parent.startAnimation(CONST_NAME.TRACE_TYPE.STEP);\r\n        },\r\n\r\n        //分步描红，下一笔\r\n        nextStep() {\r\n            return parent.draw();\r\n        },\r\n\r\n        //分步描红，上一笔，实际是撤销操作\r\n        preStep() {\r\n            var stepInfo = parent.preStep();\r\n            return stepInfo;\r\n        },\r\n\r\n        //设置自动描红速度\r\n        setSpeed(speed) {\r\n           \r\n            parent.setSpeed(speed);\r\n        },\r\n        //获取描绘进度，当前描到第几笔，总共有多少笔\r\n        getTraceProgress() {\r\n            var currentWord = parent.currentWord,\r\n                curStep = parent.isDrawMode ? currentWord.validateStep : currentWord.currentStep,\r\n                totalSteps = parent.isDrawMode ? currentWord.strokesLength : currentWord.autoTraceSteps,\r\n                isInAnimation = currentWord.loop === 0 ? false : true;\r\n\r\n            return {\r\n                curStep: curStep,\r\n                totalSteps: totalSteps,\r\n                isInAnimation: isInAnimation\r\n            }\r\n        },\r\n        reset() {\r\n            parent.resetCanvasBoards();\r\n        }\r\n    };\r\n\r\n    return parent.isDrawMode ? drawModeMethod : displayModeMethod;\r\n\r\n}\r\n\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/trace/public-method.js","/**\r\n * Created by Administrator on 2016/12/15.\r\n * 描红中用到的线工具类\r\n */\r\n\r\nimport Point from \"./point\";\r\n\r\nexport default class Line {\r\n    constructor() {\r\n        if (arguments.length == 2) {\r\n            var p1 = arguments[0], p2 = arguments[1];\r\n            this.a = p1.y - p2.y;\r\n            this.b = p2.x - p1.x;\r\n            this.c = p1.x * p2.y - p2.x * p1.y;\r\n            this.p1 = p1;\r\n            this.p2 = p2;\r\n        } else if (arguments.length == 3) {\r\n            this.a = arguments[0];\r\n            this.b = arguments[1];\r\n            this.c = arguments[2];\r\n            this.p1 = null;\r\n            this.p2 = null;\r\n        }\r\n    }\r\n\r\n    getK() {\r\n        return -this.a / this.b;\r\n    }\r\n\r\n    getX(y) {\r\n        return (-this.c - this.b * y) / this.a;\r\n    }\r\n\r\n    getY(x) {\r\n        return (-this.c - this.a * x) / this.b;\r\n    }\r\n\r\n    getLength() {\r\n        return this.p1.getDistance(this.p2);\r\n    }\r\n\r\n    getDistance(p) {\r\n        return Math.abs(this.a * p.x + this.b * p.y + this.c) / Math.sqrt(this.a * this.a + this.b * this.b);\r\n    }\r\n\r\n    getRectangle(width, distance) {\r\n        var startVLine = this.getVertical(this.p1);\r\n        var endFootPoint = this.getPoint(this.p1, this.p2, distance);\r\n        var endVLine = this.getVertical(endFootPoint);\r\n        var startPoints = startVLine.getPoints(this.p1, width / 2);\r\n        var endPoints = endVLine.getPoints(endFootPoint, width / 2);\r\n\r\n        return [startPoints[0], startPoints[1], endPoints[1], endPoints[0]];\r\n    }\r\n\r\n    getVertical(p) {\r\n        var c = -this.b * p.x + this.a * p.y;\r\n        return new Line(this.b, -this.a, c);\r\n    }\r\n\r\n    getPoint(start, director, distance) {\r\n        var ps = this.getPoints(start, distance);\r\n        var d1 = director.getDistance(ps[0]);\r\n        var d2 = director.getDistance(ps[1]);\r\n        if (d1 < d2)\r\n            return ps[0];\r\n        return ps[1];\r\n    }\r\n\r\n    getPoints(p, distance) {\r\n        if (Math.round(this.b) == 0)\r\n            return [new Point(p.x, p.y - distance), new Point(p.x, p.y + distance)];\r\n        var x = Math.sqrt(distance * distance / (1 + this.getK() * this.getK()));\r\n        return [new Point(p.x + x, this.getY(p.x + x)), new Point(p.x - x, this.getY(p.x - x))];\r\n    }\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/utils/line.js","/**\r\n * Created by Administrator on 2016/12/15.\r\n */\r\n\r\nexport default {\r\n    //点到点的距离\r\n    pointToPoint(p1,p2) {\r\n        var d = 0;\r\n        try{\r\n            d = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\r\n\r\n        }catch(e){\r\n            console.log(e);\r\n        }\r\n\r\n        return d;\r\n    },\r\n\r\n    //判断一个点是否在一个多边形内\r\n    isPointInPoly(point, polyArray) {\r\n        for(var p = 0,paLen = polyArray.length;p < paLen;p++ ){\r\n            var poly = polyArray[p].points;\r\n            var length = poly.length;\r\n            for (var c = false, i = -1, j = length - 1; ++i < length; j = i) {\r\n                ((poly[i].y <= point.y && point.y < poly[j].y) || (poly[j].y <= point.y && point.y < poly[i].y))\r\n                && (point.x < (poly[j].x - poly[i].x) * (point.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)\r\n                && (c = !c);\r\n            }\r\n            if(c) return c;\r\n        }\r\n\r\n        return c;\r\n    },\r\n    //窗口到canvas坐标转换\r\n    windowToCanvas(canvas,x,y) {\r\n        var bbox = canvas.getBoundingClientRect();\r\n        return {\r\n            x: x - bbox.left * (canvas.width / bbox.width),\r\n            y: y - bbox.top * (canvas.height / bbox.height)\r\n        };\r\n    },\r\n\r\n    //mouse event和 touch event时的坐标获取\r\n    getPosition(event) {\r\n\r\n        var x = 0, y = 0;\r\n\r\n        switch (event.type){\r\n            case \"mousedown\":\r\n            case \"mousemove\":\r\n            case \"mouseup\":\r\n                x = event.pageX;\r\n                y = event.pageY;\r\n                break;\r\n            case \"touchstart\":\r\n            case \"touchmove\":\r\n            case \"touchend\":\r\n                x = event.changedTouches[0].pageX;\r\n                y = event.changedTouches[0].pageY;\r\n                break;\r\n        }\r\n\r\n        return {x, y};\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// src/utils/math-util.js","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// F:/work/module-dev/PresenterWorkspace/~/css-loader/lib/css-base.js\n// module id = 9\n// module chunks = 0","exports = module.exports = require(\"./../../../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\\r\\n.canvas_back{\\r\\n    position:absolute;\\r\\n    top:0;\\r\\n    left:0;\\r\\n    z-index:1000;\\r\\n}\\r\\n.canvas_fore{\\r\\n    position:absolute;\\r\\n    top:0;\\r\\n    left:0;\\r\\n    z-index:1001;\\r\\n}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/resource/css.css\n// module id = 10\n// module chunks = 0","/**\r\n * Created by Administrator on 2016/12/14.\r\n */\r\nimport ChineseWordTracing from \"./trace/chinesewordtracing\"\r\n\r\n(function (global, factory) {\r\n\r\n    factory(global);\r\n\r\n})(typeof window === 'undefined' ? this : window, function (window) {\r\n\r\n    window.ChineseWordTracing = ChineseWordTracing;\r\n});\n\n\n// WEBPACK FOOTER //\n// src/chinesewordtracing.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;;;;;AAKA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAFA;AArBA;;;;;;;;;;;;ACLA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAhBA;;;;;;;;;;;;;;;;;ACJA;;;;;AAMA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;;;;AARA;;;;;;ACNA;;;;;;;;;;;;;;;;;ACAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;;;AAAA;AACA;AAGA;;;;AAIA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AATA;AAAA;AACA;AAWA;AACA;AAbA;AACA;AAaA;AACA;AACA;AAAA;AACA;AAjBA;AACA;AAiBA;AACA;AAnBA;AAAA;AAAA;AAsBA;AAtBA;AACA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAIA;;;;;;;;;;;;;ACt7BA;AACA;;;AAAA;AACA;;;AAAA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCA;AAuCA;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAvCA;AACA;AAyCA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AArEA;AACA;AAuEA;AAEA;AACA;AA5HA;AACA;;;;;;;;;;;;;;;;ACNA;;;;;AAKA;AACA;;;;;;;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAEA;AACA;AAEA;AACA;AACA;;;;;;AAnEA;;;;;;;;;;;;ACPA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AACA;AAcA;AACA;AA3DA;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACJA;AACA;;;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;","sourceRoot":""}